<style> code { white-space: pre-wrap; display: block; background-color: #eee; }.executed { background-color: #afa; }.reverted { background-color: #ffa; }.unexecuted { background-color: #faa; }.neutral { background-color: #eee; }</style><b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/forge-std/lib/ds-test/src/test.sol</b>
<code>
   1 |     | <span class='unexecuted'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>// This program is free software: you can redistribute it and/or modify</span>
   4 |     | <span class='neutral'>// it under the terms of the GNU General Public License as published by</span>
   5 |     | <span class='neutral'>// the Free Software Foundation, either version 3 of the License, or</span>
   6 |     | <span class='neutral'>// (at your option) any later version.</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>// This program is distributed in the hope that it will be useful,</span>
   9 |     | <span class='neutral'>// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
  10 |     | <span class='neutral'>// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
  11 |     | <span class='neutral'>// GNU General Public License for more details.</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>// You should have received a copy of the GNU General Public License</span>
  14 |     | <span class='neutral'>// along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  17 |     | <span class='unexecuted'></span>
  18 |     | <span class='neutral'>contract DSTest {</span>
  19 |     | <span class='neutral'>    event log                    (string);</span>
  20 |     | <span class='neutral'>    event logs                   (bytes);</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    event log_address            (address);</span>
  23 |     | <span class='neutral'>    event log_bytes32            (bytes32);</span>
  24 |     | <span class='neutral'>    event log_int                (int);</span>
  25 |     | <span class='neutral'>    event log_uint               (uint);</span>
  26 |     | <span class='neutral'>    event log_bytes              (bytes);</span>
  27 |     | <span class='neutral'>    event log_string             (string);</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    event log_named_address      (string key, address val);</span>
  30 |     | <span class='neutral'>    event log_named_bytes32      (string key, bytes32 val);</span>
  31 |     | <span class='neutral'>    event log_named_decimal_int  (string key, int val, uint decimals);</span>
  32 |     | <span class='neutral'>    event log_named_decimal_uint (string key, uint val, uint decimals);</span>
  33 |     | <span class='neutral'>    event log_named_int          (string key, int val);</span>
  34 |     | <span class='neutral'>    event log_named_uint         (string key, uint val);</span>
  35 |     | <span class='neutral'>    event log_named_bytes        (string key, bytes val);</span>
  36 |     | <span class='neutral'>    event log_named_string       (string key, string val);</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='unexecuted'>    bool public IS_TEST = true;</span>
  39 |     | <span class='neutral'>    bool private _failed;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    address constant HEVM_ADDRESS =</span>
  42 |     | <span class='unexecuted'>        address(bytes20(uint160(uint256(keccak256(&#39;hevm cheat code&#39;)))));</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    modifier mayRevert() { _; }</span>
  45 |     | <span class='neutral'>    modifier testopts(string memory) { _; }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='unexecuted'>    function failed() public returns (bool) {</span>
  48 |     | <span class='unexecuted'>        if (_failed) {</span>
  49 |     | <span class='unexecuted'>            return _failed;</span>
  50 |     | <span class='neutral'>        } else {</span>
  51 |     | <span class='unexecuted'>            bool globalFailed = false;</span>
  52 |     | <span class='unexecuted'>            if (hasHEVMContext()) {</span>
  53 |     | <span class='unexecuted'>                (, bytes memory retdata) = HEVM_ADDRESS.call(</span>
  54 |     | <span class='unexecuted'>                    abi.encodePacked(</span>
  55 |     | <span class='unexecuted'>                        bytes4(keccak256(&quot;load(address,bytes32)&quot;)),</span>
  56 |     | <span class='unexecuted'>                        abi.encode(HEVM_ADDRESS, bytes32(&quot;failed&quot;))</span>
  57 |     | <span class='neutral'>                    )</span>
  58 |     | <span class='neutral'>                );</span>
  59 |     | <span class='unexecuted'>                globalFailed = abi.decode(retdata, (bool));</span>
  60 |     | <span class='neutral'>            }</span>
  61 |     | <span class='unexecuted'>            return globalFailed;</span>
  62 |     | <span class='neutral'>        }</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='unexecuted'>    function fail() internal virtual {</span>
  66 |     | <span class='unexecuted'>        if (hasHEVMContext()) {</span>
  67 |     | <span class='unexecuted'>            (bool status, ) = HEVM_ADDRESS.call(</span>
  68 |     | <span class='unexecuted'>                abi.encodePacked(</span>
  69 |     | <span class='unexecuted'>                    bytes4(keccak256(&quot;store(address,bytes32,bytes32)&quot;)),</span>
  70 |     | <span class='unexecuted'>                    abi.encode(HEVM_ADDRESS, bytes32(&quot;failed&quot;), bytes32(uint256(0x01)))</span>
  71 |     | <span class='neutral'>                )</span>
  72 |     | <span class='neutral'>            );</span>
  73 |     | <span class='neutral'>            status; // Silence compiler warnings</span>
  74 |     | <span class='neutral'>        }</span>
  75 |     | <span class='unexecuted'>        _failed = true;</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    function hasHEVMContext() internal view returns (bool) {</span>
  79 |     | <span class='neutral'>        uint256 hevmCodeSize = 0;</span>
  80 |     | <span class='neutral'>        assembly {</span>
  81 |     | <span class='unexecuted'>            hevmCodeSize := extcodesize(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)</span>
  82 |     | <span class='neutral'>        }</span>
  83 |     | <span class='unexecuted'>        return hevmCodeSize &gt; 0;</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    modifier logs_gas() {</span>
  87 |     | <span class='neutral'>        uint startGas = gasleft();</span>
  88 |     | <span class='neutral'>        _;</span>
  89 |     | <span class='neutral'>        uint endGas = gasleft();</span>
  90 |     | <span class='neutral'>        emit log_named_uint(&quot;gas&quot;, startGas - endGas);</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    function assertTrue(bool condition) internal {</span>
  94 |     | <span class='neutral'>        if (!condition) {</span>
  95 |     | <span class='neutral'>            emit log(&quot;Error: Assertion Failed&quot;);</span>
  96 |     | <span class='neutral'>            fail();</span>
  97 |     | <span class='neutral'>        }</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    function assertTrue(bool condition, string memory err) internal {</span>
 101 |     | <span class='neutral'>        if (!condition) {</span>
 102 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 103 |     | <span class='neutral'>            assertTrue(condition);</span>
 104 |     | <span class='neutral'>        }</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    function assertEq(address a, address b) internal {</span>
 108 |     | <span class='neutral'>        if (a != b) {</span>
 109 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [address]&quot;);</span>
 110 |     | <span class='neutral'>            emit log_named_address(&quot;      Left&quot;, a);</span>
 111 |     | <span class='neutral'>            emit log_named_address(&quot;     Right&quot;, b);</span>
 112 |     | <span class='neutral'>            fail();</span>
 113 |     | <span class='neutral'>        }</span>
 114 |     | <span class='neutral'>    }</span>
 115 |     | <span class='neutral'>    function assertEq(address a, address b, string memory err) internal {</span>
 116 |     | <span class='neutral'>        if (a != b) {</span>
 117 |     | <span class='neutral'>            emit log_named_string (&quot;Error&quot;, err);</span>
 118 |     | <span class='neutral'>            assertEq(a, b);</span>
 119 |     | <span class='neutral'>        }</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    function assertEq(bytes32 a, bytes32 b) internal {</span>
 123 |     | <span class='neutral'>        if (a != b) {</span>
 124 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [bytes32]&quot;);</span>
 125 |     | <span class='neutral'>            emit log_named_bytes32(&quot;      Left&quot;, a);</span>
 126 |     | <span class='neutral'>            emit log_named_bytes32(&quot;     Right&quot;, b);</span>
 127 |     | <span class='neutral'>            fail();</span>
 128 |     | <span class='neutral'>        }</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'>    function assertEq(bytes32 a, bytes32 b, string memory err) internal {</span>
 131 |     | <span class='neutral'>        if (a != b) {</span>
 132 |     | <span class='neutral'>            emit log_named_string (&quot;Error&quot;, err);</span>
 133 |     | <span class='neutral'>            assertEq(a, b);</span>
 134 |     | <span class='neutral'>        }</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'>    function assertEq32(bytes32 a, bytes32 b) internal {</span>
 137 |     | <span class='neutral'>        assertEq(a, b);</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'>    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {</span>
 140 |     | <span class='neutral'>        assertEq(a, b, err);</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    function assertEq(int a, int b) internal {</span>
 144 |     | <span class='neutral'>        if (a != b) {</span>
 145 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [int]&quot;);</span>
 146 |     | <span class='neutral'>            emit log_named_int(&quot;      Left&quot;, a);</span>
 147 |     | <span class='neutral'>            emit log_named_int(&quot;     Right&quot;, b);</span>
 148 |     | <span class='neutral'>            fail();</span>
 149 |     | <span class='neutral'>        }</span>
 150 |     | <span class='neutral'>    }</span>
 151 |     | <span class='neutral'>    function assertEq(int a, int b, string memory err) internal {</span>
 152 |     | <span class='neutral'>        if (a != b) {</span>
 153 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 154 |     | <span class='neutral'>            assertEq(a, b);</span>
 155 |     | <span class='neutral'>        }</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='unexecuted'>    function assertEq(uint a, uint b) internal {</span>
 158 |     | <span class='unexecuted'>        if (a != b) {</span>
 159 |     | <span class='unexecuted'>            emit log(&quot;Error: a == b not satisfied [uint]&quot;);</span>
 160 |     | <span class='unexecuted'>            emit log_named_uint(&quot;      Left&quot;, a);</span>
 161 |     | <span class='unexecuted'>            emit log_named_uint(&quot;     Right&quot;, b);</span>
 162 |     | <span class='unexecuted'>            fail();</span>
 163 |     | <span class='neutral'>        }</span>
 164 |     | <span class='neutral'>    }</span>
 165 |     | <span class='neutral'>    function assertEq(uint a, uint b, string memory err) internal {</span>
 166 |     | <span class='neutral'>        if (a != b) {</span>
 167 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 168 |     | <span class='neutral'>            assertEq(a, b);</span>
 169 |     | <span class='neutral'>        }</span>
 170 |     | <span class='neutral'>    }</span>
 171 |     | <span class='neutral'>    function assertEqDecimal(int a, int b, uint decimals) internal {</span>
 172 |     | <span class='neutral'>        if (a != b) {</span>
 173 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [decimal int]&quot;);</span>
 174 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;      Left&quot;, a, decimals);</span>
 175 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;     Right&quot;, b, decimals);</span>
 176 |     | <span class='neutral'>            fail();</span>
 177 |     | <span class='neutral'>        }</span>
 178 |     | <span class='neutral'>    }</span>
 179 |     | <span class='neutral'>    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {</span>
 180 |     | <span class='neutral'>        if (a != b) {</span>
 181 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 182 |     | <span class='neutral'>            assertEqDecimal(a, b, decimals);</span>
 183 |     | <span class='neutral'>        }</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'>    function assertEqDecimal(uint a, uint b, uint decimals) internal {</span>
 186 |     | <span class='neutral'>        if (a != b) {</span>
 187 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [decimal uint]&quot;);</span>
 188 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;      Left&quot;, a, decimals);</span>
 189 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;     Right&quot;, b, decimals);</span>
 190 |     | <span class='neutral'>            fail();</span>
 191 |     | <span class='neutral'>        }</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'>    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {</span>
 194 |     | <span class='neutral'>        if (a != b) {</span>
 195 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 196 |     | <span class='neutral'>            assertEqDecimal(a, b, decimals);</span>
 197 |     | <span class='neutral'>        }</span>
 198 |     | <span class='neutral'>    }</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>    function assertGt(uint a, uint b) internal {</span>
 201 |     | <span class='neutral'>        if (a &lt;= b) {</span>
 202 |     | <span class='neutral'>            emit log(&quot;Error: a &gt; b not satisfied [uint]&quot;);</span>
 203 |     | <span class='neutral'>            emit log_named_uint(&quot;  Value a&quot;, a);</span>
 204 |     | <span class='neutral'>            emit log_named_uint(&quot;  Value b&quot;, b);</span>
 205 |     | <span class='neutral'>            fail();</span>
 206 |     | <span class='neutral'>        }</span>
 207 |     | <span class='neutral'>    }</span>
 208 |     | <span class='neutral'>    function assertGt(uint a, uint b, string memory err) internal {</span>
 209 |     | <span class='neutral'>        if (a &lt;= b) {</span>
 210 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 211 |     | <span class='neutral'>            assertGt(a, b);</span>
 212 |     | <span class='neutral'>        }</span>
 213 |     | <span class='neutral'>    }</span>
 214 |     | <span class='neutral'>    function assertGt(int a, int b) internal {</span>
 215 |     | <span class='neutral'>        if (a &lt;= b) {</span>
 216 |     | <span class='neutral'>            emit log(&quot;Error: a &gt; b not satisfied [int]&quot;);</span>
 217 |     | <span class='neutral'>            emit log_named_int(&quot;  Value a&quot;, a);</span>
 218 |     | <span class='neutral'>            emit log_named_int(&quot;  Value b&quot;, b);</span>
 219 |     | <span class='neutral'>            fail();</span>
 220 |     | <span class='neutral'>        }</span>
 221 |     | <span class='neutral'>    }</span>
 222 |     | <span class='neutral'>    function assertGt(int a, int b, string memory err) internal {</span>
 223 |     | <span class='neutral'>        if (a &lt;= b) {</span>
 224 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 225 |     | <span class='neutral'>            assertGt(a, b);</span>
 226 |     | <span class='neutral'>        }</span>
 227 |     | <span class='neutral'>    }</span>
 228 |     | <span class='neutral'>    function assertGtDecimal(int a, int b, uint decimals) internal {</span>
 229 |     | <span class='neutral'>        if (a &lt;= b) {</span>
 230 |     | <span class='neutral'>            emit log(&quot;Error: a &gt; b not satisfied [decimal int]&quot;);</span>
 231 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value a&quot;, a, decimals);</span>
 232 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value b&quot;, b, decimals);</span>
 233 |     | <span class='neutral'>            fail();</span>
 234 |     | <span class='neutral'>        }</span>
 235 |     | <span class='neutral'>    }</span>
 236 |     | <span class='neutral'>    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {</span>
 237 |     | <span class='neutral'>        if (a &lt;= b) {</span>
 238 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 239 |     | <span class='neutral'>            assertGtDecimal(a, b, decimals);</span>
 240 |     | <span class='neutral'>        }</span>
 241 |     | <span class='neutral'>    }</span>
 242 |     | <span class='neutral'>    function assertGtDecimal(uint a, uint b, uint decimals) internal {</span>
 243 |     | <span class='neutral'>        if (a &lt;= b) {</span>
 244 |     | <span class='neutral'>            emit log(&quot;Error: a &gt; b not satisfied [decimal uint]&quot;);</span>
 245 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value a&quot;, a, decimals);</span>
 246 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value b&quot;, b, decimals);</span>
 247 |     | <span class='neutral'>            fail();</span>
 248 |     | <span class='neutral'>        }</span>
 249 |     | <span class='neutral'>    }</span>
 250 |     | <span class='neutral'>    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {</span>
 251 |     | <span class='neutral'>        if (a &lt;= b) {</span>
 252 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 253 |     | <span class='neutral'>            assertGtDecimal(a, b, decimals);</span>
 254 |     | <span class='neutral'>        }</span>
 255 |     | <span class='neutral'>    }</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='neutral'>    function assertGe(uint a, uint b) internal {</span>
 258 |     | <span class='neutral'>        if (a &lt; b) {</span>
 259 |     | <span class='neutral'>            emit log(&quot;Error: a &gt;= b not satisfied [uint]&quot;);</span>
 260 |     | <span class='neutral'>            emit log_named_uint(&quot;  Value a&quot;, a);</span>
 261 |     | <span class='neutral'>            emit log_named_uint(&quot;  Value b&quot;, b);</span>
 262 |     | <span class='neutral'>            fail();</span>
 263 |     | <span class='neutral'>        }</span>
 264 |     | <span class='neutral'>    }</span>
 265 |     | <span class='neutral'>    function assertGe(uint a, uint b, string memory err) internal {</span>
 266 |     | <span class='neutral'>        if (a &lt; b) {</span>
 267 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 268 |     | <span class='neutral'>            assertGe(a, b);</span>
 269 |     | <span class='neutral'>        }</span>
 270 |     | <span class='neutral'>    }</span>
 271 |     | <span class='neutral'>    function assertGe(int a, int b) internal {</span>
 272 |     | <span class='neutral'>        if (a &lt; b) {</span>
 273 |     | <span class='neutral'>            emit log(&quot;Error: a &gt;= b not satisfied [int]&quot;);</span>
 274 |     | <span class='neutral'>            emit log_named_int(&quot;  Value a&quot;, a);</span>
 275 |     | <span class='neutral'>            emit log_named_int(&quot;  Value b&quot;, b);</span>
 276 |     | <span class='neutral'>            fail();</span>
 277 |     | <span class='neutral'>        }</span>
 278 |     | <span class='neutral'>    }</span>
 279 |     | <span class='neutral'>    function assertGe(int a, int b, string memory err) internal {</span>
 280 |     | <span class='neutral'>        if (a &lt; b) {</span>
 281 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 282 |     | <span class='neutral'>            assertGe(a, b);</span>
 283 |     | <span class='neutral'>        }</span>
 284 |     | <span class='neutral'>    }</span>
 285 |     | <span class='neutral'>    function assertGeDecimal(int a, int b, uint decimals) internal {</span>
 286 |     | <span class='neutral'>        if (a &lt; b) {</span>
 287 |     | <span class='neutral'>            emit log(&quot;Error: a &gt;= b not satisfied [decimal int]&quot;);</span>
 288 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value a&quot;, a, decimals);</span>
 289 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value b&quot;, b, decimals);</span>
 290 |     | <span class='neutral'>            fail();</span>
 291 |     | <span class='neutral'>        }</span>
 292 |     | <span class='neutral'>    }</span>
 293 |     | <span class='neutral'>    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {</span>
 294 |     | <span class='neutral'>        if (a &lt; b) {</span>
 295 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 296 |     | <span class='neutral'>            assertGeDecimal(a, b, decimals);</span>
 297 |     | <span class='neutral'>        }</span>
 298 |     | <span class='neutral'>    }</span>
 299 |     | <span class='neutral'>    function assertGeDecimal(uint a, uint b, uint decimals) internal {</span>
 300 |     | <span class='neutral'>        if (a &lt; b) {</span>
 301 |     | <span class='neutral'>            emit log(&quot;Error: a &gt;= b not satisfied [decimal uint]&quot;);</span>
 302 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value a&quot;, a, decimals);</span>
 303 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value b&quot;, b, decimals);</span>
 304 |     | <span class='neutral'>            fail();</span>
 305 |     | <span class='neutral'>        }</span>
 306 |     | <span class='neutral'>    }</span>
 307 |     | <span class='neutral'>    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {</span>
 308 |     | <span class='neutral'>        if (a &lt; b) {</span>
 309 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 310 |     | <span class='neutral'>            assertGeDecimal(a, b, decimals);</span>
 311 |     | <span class='neutral'>        }</span>
 312 |     | <span class='neutral'>    }</span>
 313 |     | <span class='neutral'></span>
 314 |     | <span class='neutral'>    function assertLt(uint a, uint b) internal {</span>
 315 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 316 |     | <span class='neutral'>            emit log(&quot;Error: a &lt; b not satisfied [uint]&quot;);</span>
 317 |     | <span class='neutral'>            emit log_named_uint(&quot;  Value a&quot;, a);</span>
 318 |     | <span class='neutral'>            emit log_named_uint(&quot;  Value b&quot;, b);</span>
 319 |     | <span class='neutral'>            fail();</span>
 320 |     | <span class='neutral'>        }</span>
 321 |     | <span class='neutral'>    }</span>
 322 |     | <span class='neutral'>    function assertLt(uint a, uint b, string memory err) internal {</span>
 323 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 324 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 325 |     | <span class='neutral'>            assertLt(a, b);</span>
 326 |     | <span class='neutral'>        }</span>
 327 |     | <span class='neutral'>    }</span>
 328 |     | <span class='neutral'>    function assertLt(int a, int b) internal {</span>
 329 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 330 |     | <span class='neutral'>            emit log(&quot;Error: a &lt; b not satisfied [int]&quot;);</span>
 331 |     | <span class='neutral'>            emit log_named_int(&quot;  Value a&quot;, a);</span>
 332 |     | <span class='neutral'>            emit log_named_int(&quot;  Value b&quot;, b);</span>
 333 |     | <span class='neutral'>            fail();</span>
 334 |     | <span class='neutral'>        }</span>
 335 |     | <span class='neutral'>    }</span>
 336 |     | <span class='neutral'>    function assertLt(int a, int b, string memory err) internal {</span>
 337 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 338 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 339 |     | <span class='neutral'>            assertLt(a, b);</span>
 340 |     | <span class='neutral'>        }</span>
 341 |     | <span class='neutral'>    }</span>
 342 |     | <span class='neutral'>    function assertLtDecimal(int a, int b, uint decimals) internal {</span>
 343 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 344 |     | <span class='neutral'>            emit log(&quot;Error: a &lt; b not satisfied [decimal int]&quot;);</span>
 345 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value a&quot;, a, decimals);</span>
 346 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value b&quot;, b, decimals);</span>
 347 |     | <span class='neutral'>            fail();</span>
 348 |     | <span class='neutral'>        }</span>
 349 |     | <span class='neutral'>    }</span>
 350 |     | <span class='neutral'>    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {</span>
 351 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 352 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 353 |     | <span class='neutral'>            assertLtDecimal(a, b, decimals);</span>
 354 |     | <span class='neutral'>        }</span>
 355 |     | <span class='neutral'>    }</span>
 356 |     | <span class='neutral'>    function assertLtDecimal(uint a, uint b, uint decimals) internal {</span>
 357 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 358 |     | <span class='neutral'>            emit log(&quot;Error: a &lt; b not satisfied [decimal uint]&quot;);</span>
 359 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value a&quot;, a, decimals);</span>
 360 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value b&quot;, b, decimals);</span>
 361 |     | <span class='neutral'>            fail();</span>
 362 |     | <span class='neutral'>        }</span>
 363 |     | <span class='neutral'>    }</span>
 364 |     | <span class='neutral'>    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {</span>
 365 |     | <span class='neutral'>        if (a &gt;= b) {</span>
 366 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 367 |     | <span class='neutral'>            assertLtDecimal(a, b, decimals);</span>
 368 |     | <span class='neutral'>        }</span>
 369 |     | <span class='neutral'>    }</span>
 370 |     | <span class='neutral'></span>
 371 |     | <span class='neutral'>    function assertLe(uint a, uint b) internal {</span>
 372 |     | <span class='neutral'>        if (a &gt; b) {</span>
 373 |     | <span class='neutral'>            emit log(&quot;Error: a &lt;= b not satisfied [uint]&quot;);</span>
 374 |     | <span class='neutral'>            emit log_named_uint(&quot;  Value a&quot;, a);</span>
 375 |     | <span class='neutral'>            emit log_named_uint(&quot;  Value b&quot;, b);</span>
 376 |     | <span class='neutral'>            fail();</span>
 377 |     | <span class='neutral'>        }</span>
 378 |     | <span class='neutral'>    }</span>
 379 |     | <span class='neutral'>    function assertLe(uint a, uint b, string memory err) internal {</span>
 380 |     | <span class='neutral'>        if (a &gt; b) {</span>
 381 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 382 |     | <span class='neutral'>            assertLe(a, b);</span>
 383 |     | <span class='neutral'>        }</span>
 384 |     | <span class='neutral'>    }</span>
 385 |     | <span class='neutral'>    function assertLe(int a, int b) internal {</span>
 386 |     | <span class='neutral'>        if (a &gt; b) {</span>
 387 |     | <span class='neutral'>            emit log(&quot;Error: a &lt;= b not satisfied [int]&quot;);</span>
 388 |     | <span class='neutral'>            emit log_named_int(&quot;  Value a&quot;, a);</span>
 389 |     | <span class='neutral'>            emit log_named_int(&quot;  Value b&quot;, b);</span>
 390 |     | <span class='neutral'>            fail();</span>
 391 |     | <span class='neutral'>        }</span>
 392 |     | <span class='neutral'>    }</span>
 393 |     | <span class='neutral'>    function assertLe(int a, int b, string memory err) internal {</span>
 394 |     | <span class='neutral'>        if (a &gt; b) {</span>
 395 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 396 |     | <span class='neutral'>            assertLe(a, b);</span>
 397 |     | <span class='neutral'>        }</span>
 398 |     | <span class='neutral'>    }</span>
 399 |     | <span class='neutral'>    function assertLeDecimal(int a, int b, uint decimals) internal {</span>
 400 |     | <span class='neutral'>        if (a &gt; b) {</span>
 401 |     | <span class='neutral'>            emit log(&quot;Error: a &lt;= b not satisfied [decimal int]&quot;);</span>
 402 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value a&quot;, a, decimals);</span>
 403 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;  Value b&quot;, b, decimals);</span>
 404 |     | <span class='neutral'>            fail();</span>
 405 |     | <span class='neutral'>        }</span>
 406 |     | <span class='neutral'>    }</span>
 407 |     | <span class='neutral'>    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {</span>
 408 |     | <span class='neutral'>        if (a &gt; b) {</span>
 409 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 410 |     | <span class='neutral'>            assertLeDecimal(a, b, decimals);</span>
 411 |     | <span class='neutral'>        }</span>
 412 |     | <span class='neutral'>    }</span>
 413 |     | <span class='neutral'>    function assertLeDecimal(uint a, uint b, uint decimals) internal {</span>
 414 |     | <span class='neutral'>        if (a &gt; b) {</span>
 415 |     | <span class='neutral'>            emit log(&quot;Error: a &lt;= b not satisfied [decimal uint]&quot;);</span>
 416 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value a&quot;, a, decimals);</span>
 417 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;  Value b&quot;, b, decimals);</span>
 418 |     | <span class='neutral'>            fail();</span>
 419 |     | <span class='neutral'>        }</span>
 420 |     | <span class='neutral'>    }</span>
 421 |     | <span class='neutral'>    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {</span>
 422 |     | <span class='neutral'>        if (a &gt; b) {</span>
 423 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 424 |     | <span class='neutral'>            assertLeDecimal(a, b, decimals);</span>
 425 |     | <span class='neutral'>        }</span>
 426 |     | <span class='neutral'>    }</span>
 427 |     | <span class='neutral'></span>
 428 |     | <span class='neutral'>    function assertEq(string memory a, string memory b) internal {</span>
 429 |     | <span class='neutral'>        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {</span>
 430 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [string]&quot;);</span>
 431 |     | <span class='neutral'>            emit log_named_string(&quot;      Left&quot;, a);</span>
 432 |     | <span class='neutral'>            emit log_named_string(&quot;     Right&quot;, b);</span>
 433 |     | <span class='neutral'>            fail();</span>
 434 |     | <span class='neutral'>        }</span>
 435 |     | <span class='neutral'>    }</span>
 436 |     | <span class='neutral'>    function assertEq(string memory a, string memory b, string memory err) internal {</span>
 437 |     | <span class='neutral'>        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {</span>
 438 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 439 |     | <span class='neutral'>            assertEq(a, b);</span>
 440 |     | <span class='neutral'>        }</span>
 441 |     | <span class='neutral'>    }</span>
 442 |     | <span class='neutral'></span>
 443 |     | <span class='neutral'>    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {</span>
 444 |     | <span class='neutral'>        ok = true;</span>
 445 |     | <span class='neutral'>        if (a.length == b.length) {</span>
 446 |     | <span class='neutral'>            for (uint i = 0; i &lt; a.length; i++) {</span>
 447 |     | <span class='neutral'>                if (a[i] != b[i]) {</span>
 448 |     | <span class='neutral'>                    ok = false;</span>
 449 |     | <span class='neutral'>                }</span>
 450 |     | <span class='neutral'>            }</span>
 451 |     | <span class='neutral'>        } else {</span>
 452 |     | <span class='neutral'>            ok = false;</span>
 453 |     | <span class='neutral'>        }</span>
 454 |     | <span class='neutral'>    }</span>
 455 |     | <span class='neutral'>    function assertEq0(bytes memory a, bytes memory b) internal {</span>
 456 |     | <span class='neutral'>        if (!checkEq0(a, b)) {</span>
 457 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [bytes]&quot;);</span>
 458 |     | <span class='neutral'>            emit log_named_bytes(&quot;      Left&quot;, a);</span>
 459 |     | <span class='neutral'>            emit log_named_bytes(&quot;     Right&quot;, b);</span>
 460 |     | <span class='neutral'>            fail();</span>
 461 |     | <span class='neutral'>        }</span>
 462 |     | <span class='neutral'>    }</span>
 463 |     | <span class='neutral'>    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {</span>
 464 |     | <span class='neutral'>        if (!checkEq0(a, b)) {</span>
 465 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 466 |     | <span class='neutral'>            assertEq0(a, b);</span>
 467 |     | <span class='neutral'>        }</span>
 468 |     | <span class='neutral'>    }</span>
 469 |     | <span class='neutral'>}</span>
 470 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/forge-std/src/Base.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {StdStorage} from &quot;./StdStorage.sol&quot;;</span>
  5 |     | <span class='neutral'>import {Vm, VmSafe} from &quot;./Vm.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>abstract contract CommonBase {</span>
  8 |     | <span class='neutral'>    // Cheat code address, 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D.</span>
  9 |     | <span class='unexecuted'>    address internal constant VM_ADDRESS = address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;))));</span>
 10 |     | <span class='neutral'>    // console.sol and console2.sol work by executing a staticcall to this address.</span>
 11 |     | <span class='neutral'>    address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;</span>
 12 |     | <span class='neutral'>    // Default address for tx.origin and msg.sender, 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38.</span>
 13 |     | <span class='neutral'>    address internal constant DEFAULT_SENDER = address(uint160(uint256(keccak256(&quot;foundry default caller&quot;))));</span>
 14 |     | <span class='neutral'>    // Address of the test contract, deployed by the DEFAULT_SENDER.</span>
 15 |     | <span class='neutral'>    address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;</span>
 16 |     | <span class='neutral'>    // Deterministic deployment address of the Multicall3 contract.</span>
 17 |     | <span class='neutral'>    address internal constant MULTICALL3_ADDRESS = 0xcA11bde05977b3631167028862bE2a173976CA11;</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    uint256 internal constant UINT256_MAX =</span>
 20 |     | <span class='neutral'>        115792089237316195423570985008687907853269984665640564039457584007913129639935;</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    Vm internal constant vm = Vm(VM_ADDRESS);</span>
 23 |     | <span class='neutral'>    StdStorage internal stdstore;</span>
 24 |     | <span class='neutral'>}</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>abstract contract TestBase is CommonBase {}</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>abstract contract ScriptBase is CommonBase {</span>
 29 |     | <span class='neutral'>    // Used when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.</span>
 30 |     | <span class='neutral'>    address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>    VmSafe internal constant vmSafe = VmSafe(VM_ADDRESS);</span>
 33 |     | <span class='neutral'>}</span>
 34 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/forge-std/src/Script.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>// üí¨ ABOUT</span>
  5 |     | <span class='neutral'>// Standard Library&#39;s default Script.</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>// üß© MODULES</span>
  8 |     | <span class='neutral'>import {ScriptBase} from &quot;./Base.sol&quot;;</span>
  9 |     | <span class='neutral'>import {console} from &quot;./console.sol&quot;;</span>
 10 |     | <span class='neutral'>import {console2} from &quot;./console2.sol&quot;;</span>
 11 |     | <span class='neutral'>import {StdChains} from &quot;./StdChains.sol&quot;;</span>
 12 |     | <span class='neutral'>import {StdCheatsSafe} from &quot;./StdCheats.sol&quot;;</span>
 13 |     | <span class='neutral'>import {stdJson} from &quot;./StdJson.sol&quot;;</span>
 14 |     | <span class='neutral'>import {stdMath} from &quot;./StdMath.sol&quot;;</span>
 15 |     | <span class='neutral'>import {StdStorage, stdStorageSafe} from &quot;./StdStorage.sol&quot;;</span>
 16 |     | <span class='neutral'>import {StdUtils} from &quot;./StdUtils.sol&quot;;</span>
 17 |     | <span class='neutral'>import {VmSafe} from &quot;./Vm.sol&quot;;</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>// üì¶ BOILERPLATE</span>
 20 |     | <span class='neutral'>import {ScriptBase} from &quot;./Base.sol&quot;;</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>// ‚≠êÔ∏è SCRIPT</span>
 23 |     | <span class='neutral'>abstract contract Script is StdChains, StdCheatsSafe, StdUtils, ScriptBase {</span>
 24 |     | <span class='neutral'>    // Note: IS_SCRIPT() must return true.</span>
 25 |     | <span class='unexecuted'>    bool public IS_SCRIPT = true;</span>
 26 |     | <span class='neutral'>}</span>
 27 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/forge-std/src/StdAssertions.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {DSTest} from &quot;ds-test/test.sol&quot;;</span>
   5 |     | <span class='neutral'>import {stdMath} from &quot;./StdMath.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>abstract contract StdAssertions is DSTest {</span>
   8 |     | <span class='neutral'>    event log_array(uint256[] val);</span>
   9 |     | <span class='neutral'>    event log_array(int256[] val);</span>
  10 |     | <span class='neutral'>    event log_array(address[] val);</span>
  11 |     | <span class='neutral'>    event log_named_array(string key, uint256[] val);</span>
  12 |     | <span class='neutral'>    event log_named_array(string key, int256[] val);</span>
  13 |     | <span class='neutral'>    event log_named_array(string key, address[] val);</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    function fail(string memory err) internal virtual {</span>
  16 |     | <span class='neutral'>        emit log_named_string(&quot;Error&quot;, err);</span>
  17 |     | <span class='neutral'>        fail();</span>
  18 |     | <span class='neutral'>    }</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    function assertFalse(bool data) internal virtual {</span>
  21 |     | <span class='neutral'>        assertTrue(!data);</span>
  22 |     | <span class='neutral'>    }</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    function assertFalse(bool data, string memory err) internal virtual {</span>
  25 |     | <span class='neutral'>        assertTrue(!data, err);</span>
  26 |     | <span class='neutral'>    }</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='unexecuted'>    function assertEq(bool a, bool b) internal virtual {</span>
  29 |     | <span class='unexecuted'>        if (a != b) {</span>
  30 |     | <span class='unexecuted'>            emit log(&quot;Error: a == b not satisfied [bool]&quot;);</span>
  31 |     | <span class='unexecuted'>            emit log_named_string(&quot;      Left&quot;, a ? &quot;true&quot; : &quot;false&quot;);</span>
  32 |     | <span class='unexecuted'>            emit log_named_string(&quot;     Right&quot;, b ? &quot;true&quot; : &quot;false&quot;);</span>
  33 |     | <span class='unexecuted'>            fail();</span>
  34 |     | <span class='neutral'>        }</span>
  35 |     | <span class='neutral'>    }</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    function assertEq(bool a, bool b, string memory err) internal virtual {</span>
  38 |     | <span class='neutral'>        if (a != b) {</span>
  39 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
  40 |     | <span class='neutral'>            assertEq(a, b);</span>
  41 |     | <span class='neutral'>        }</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    function assertEq(bytes memory a, bytes memory b) internal virtual {</span>
  45 |     | <span class='neutral'>        assertEq0(a, b);</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    function assertEq(bytes memory a, bytes memory b, string memory err) internal virtual {</span>
  49 |     | <span class='neutral'>        assertEq0(a, b, err);</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    function assertEq(uint256[] memory a, uint256[] memory b) internal virtual {</span>
  53 |     | <span class='neutral'>        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {</span>
  54 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [uint[]]&quot;);</span>
  55 |     | <span class='neutral'>            emit log_named_array(&quot;      Left&quot;, a);</span>
  56 |     | <span class='neutral'>            emit log_named_array(&quot;     Right&quot;, b);</span>
  57 |     | <span class='neutral'>            fail();</span>
  58 |     | <span class='neutral'>        }</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    function assertEq(int256[] memory a, int256[] memory b) internal virtual {</span>
  62 |     | <span class='neutral'>        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {</span>
  63 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [int[]]&quot;);</span>
  64 |     | <span class='neutral'>            emit log_named_array(&quot;      Left&quot;, a);</span>
  65 |     | <span class='neutral'>            emit log_named_array(&quot;     Right&quot;, b);</span>
  66 |     | <span class='neutral'>            fail();</span>
  67 |     | <span class='neutral'>        }</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    function assertEq(address[] memory a, address[] memory b) internal virtual {</span>
  71 |     | <span class='neutral'>        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {</span>
  72 |     | <span class='neutral'>            emit log(&quot;Error: a == b not satisfied [address[]]&quot;);</span>
  73 |     | <span class='neutral'>            emit log_named_array(&quot;      Left&quot;, a);</span>
  74 |     | <span class='neutral'>            emit log_named_array(&quot;     Right&quot;, b);</span>
  75 |     | <span class='neutral'>            fail();</span>
  76 |     | <span class='neutral'>        }</span>
  77 |     | <span class='neutral'>    }</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>    function assertEq(uint256[] memory a, uint256[] memory b, string memory err) internal virtual {</span>
  80 |     | <span class='neutral'>        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {</span>
  81 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
  82 |     | <span class='neutral'>            assertEq(a, b);</span>
  83 |     | <span class='neutral'>        }</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    function assertEq(int256[] memory a, int256[] memory b, string memory err) internal virtual {</span>
  87 |     | <span class='neutral'>        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {</span>
  88 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
  89 |     | <span class='neutral'>            assertEq(a, b);</span>
  90 |     | <span class='neutral'>        }</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    function assertEq(address[] memory a, address[] memory b, string memory err) internal virtual {</span>
  94 |     | <span class='neutral'>        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {</span>
  95 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
  96 |     | <span class='neutral'>            assertEq(a, b);</span>
  97 |     | <span class='neutral'>        }</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    // Legacy helper</span>
 101 |     | <span class='neutral'>    function assertEqUint(uint256 a, uint256 b) internal virtual {</span>
 102 |     | <span class='neutral'>        assertEq(uint256(a), uint256(b));</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta) internal virtual {</span>
 106 |     | <span class='neutral'>        uint256 delta = stdMath.delta(a, b);</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>        if (delta &gt; maxDelta) {</span>
 109 |     | <span class='neutral'>            emit log(&quot;Error: a ~= b not satisfied [uint]&quot;);</span>
 110 |     | <span class='neutral'>            emit log_named_uint(&quot;      Left&quot;, a);</span>
 111 |     | <span class='neutral'>            emit log_named_uint(&quot;     Right&quot;, b);</span>
 112 |     | <span class='neutral'>            emit log_named_uint(&quot; Max Delta&quot;, maxDelta);</span>
 113 |     | <span class='neutral'>            emit log_named_uint(&quot;     Delta&quot;, delta);</span>
 114 |     | <span class='neutral'>            fail();</span>
 115 |     | <span class='neutral'>        }</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta, string memory err) internal virtual {</span>
 119 |     | <span class='neutral'>        uint256 delta = stdMath.delta(a, b);</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>        if (delta &gt; maxDelta) {</span>
 122 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 123 |     | <span class='neutral'>            assertApproxEqAbs(a, b, maxDelta);</span>
 124 |     | <span class='neutral'>        }</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>    function assertApproxEqAbsDecimal(uint256 a, uint256 b, uint256 maxDelta, uint256 decimals) internal virtual {</span>
 128 |     | <span class='neutral'>        uint256 delta = stdMath.delta(a, b);</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>        if (delta &gt; maxDelta) {</span>
 131 |     | <span class='neutral'>            emit log(&quot;Error: a ~= b not satisfied [uint]&quot;);</span>
 132 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;      Left&quot;, a, decimals);</span>
 133 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;     Right&quot;, b, decimals);</span>
 134 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot; Max Delta&quot;, maxDelta, decimals);</span>
 135 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;     Delta&quot;, delta, decimals);</span>
 136 |     | <span class='neutral'>            fail();</span>
 137 |     | <span class='neutral'>        }</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    function assertApproxEqAbsDecimal(uint256 a, uint256 b, uint256 maxDelta, uint256 decimals, string memory err)</span>
 141 |     | <span class='neutral'>        internal</span>
 142 |     | <span class='neutral'>        virtual</span>
 143 |     | <span class='neutral'>    {</span>
 144 |     | <span class='neutral'>        uint256 delta = stdMath.delta(a, b);</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>        if (delta &gt; maxDelta) {</span>
 147 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 148 |     | <span class='neutral'>            assertApproxEqAbsDecimal(a, b, maxDelta, decimals);</span>
 149 |     | <span class='neutral'>        }</span>
 150 |     | <span class='neutral'>    }</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>    function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta) internal virtual {</span>
 153 |     | <span class='neutral'>        uint256 delta = stdMath.delta(a, b);</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>        if (delta &gt; maxDelta) {</span>
 156 |     | <span class='neutral'>            emit log(&quot;Error: a ~= b not satisfied [int]&quot;);</span>
 157 |     | <span class='neutral'>            emit log_named_int(&quot;       Left&quot;, a);</span>
 158 |     | <span class='neutral'>            emit log_named_int(&quot;      Right&quot;, b);</span>
 159 |     | <span class='neutral'>            emit log_named_uint(&quot; Max Delta&quot;, maxDelta);</span>
 160 |     | <span class='neutral'>            emit log_named_uint(&quot;     Delta&quot;, delta);</span>
 161 |     | <span class='neutral'>            fail();</span>
 162 |     | <span class='neutral'>        }</span>
 163 |     | <span class='neutral'>    }</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>    function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta, string memory err) internal virtual {</span>
 166 |     | <span class='neutral'>        uint256 delta = stdMath.delta(a, b);</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>        if (delta &gt; maxDelta) {</span>
 169 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 170 |     | <span class='neutral'>            assertApproxEqAbs(a, b, maxDelta);</span>
 171 |     | <span class='neutral'>        }</span>
 172 |     | <span class='neutral'>    }</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>    function assertApproxEqAbsDecimal(int256 a, int256 b, uint256 maxDelta, uint256 decimals) internal virtual {</span>
 175 |     | <span class='neutral'>        uint256 delta = stdMath.delta(a, b);</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='neutral'>        if (delta &gt; maxDelta) {</span>
 178 |     | <span class='neutral'>            emit log(&quot;Error: a ~= b not satisfied [int]&quot;);</span>
 179 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;      Left&quot;, a, decimals);</span>
 180 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;     Right&quot;, b, decimals);</span>
 181 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot; Max Delta&quot;, maxDelta, decimals);</span>
 182 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;     Delta&quot;, delta, decimals);</span>
 183 |     | <span class='neutral'>            fail();</span>
 184 |     | <span class='neutral'>        }</span>
 185 |     | <span class='neutral'>    }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>    function assertApproxEqAbsDecimal(int256 a, int256 b, uint256 maxDelta, uint256 decimals, string memory err)</span>
 188 |     | <span class='neutral'>        internal</span>
 189 |     | <span class='neutral'>        virtual</span>
 190 |     | <span class='neutral'>    {</span>
 191 |     | <span class='neutral'>        uint256 delta = stdMath.delta(a, b);</span>
 192 |     | <span class='neutral'></span>
 193 |     | <span class='neutral'>        if (delta &gt; maxDelta) {</span>
 194 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 195 |     | <span class='neutral'>            assertApproxEqAbsDecimal(a, b, maxDelta, decimals);</span>
 196 |     | <span class='neutral'>        }</span>
 197 |     | <span class='neutral'>    }</span>
 198 |     | <span class='neutral'></span>
 199 |     | <span class='neutral'>    function assertApproxEqRel(</span>
 200 |     | <span class='neutral'>        uint256 a,</span>
 201 |     | <span class='neutral'>        uint256 b,</span>
 202 |     | <span class='neutral'>        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%</span>
 203 |     | <span class='neutral'>    ) internal virtual {</span>
 204 |     | <span class='neutral'>        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='neutral'>        uint256 percentDelta = stdMath.percentDelta(a, b);</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>        if (percentDelta &gt; maxPercentDelta) {</span>
 209 |     | <span class='neutral'>            emit log(&quot;Error: a ~= b not satisfied [uint]&quot;);</span>
 210 |     | <span class='neutral'>            emit log_named_uint(&quot;        Left&quot;, a);</span>
 211 |     | <span class='neutral'>            emit log_named_uint(&quot;       Right&quot;, b);</span>
 212 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot; Max % Delta&quot;, maxPercentDelta, 18);</span>
 213 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;     % Delta&quot;, percentDelta, 18);</span>
 214 |     | <span class='neutral'>            fail();</span>
 215 |     | <span class='neutral'>        }</span>
 216 |     | <span class='neutral'>    }</span>
 217 |     | <span class='neutral'></span>
 218 |     | <span class='neutral'>    function assertApproxEqRel(</span>
 219 |     | <span class='neutral'>        uint256 a,</span>
 220 |     | <span class='neutral'>        uint256 b,</span>
 221 |     | <span class='neutral'>        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%</span>
 222 |     | <span class='neutral'>        string memory err</span>
 223 |     | <span class='neutral'>    ) internal virtual {</span>
 224 |     | <span class='neutral'>        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='neutral'>        uint256 percentDelta = stdMath.percentDelta(a, b);</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='neutral'>        if (percentDelta &gt; maxPercentDelta) {</span>
 229 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 230 |     | <span class='neutral'>            assertApproxEqRel(a, b, maxPercentDelta);</span>
 231 |     | <span class='neutral'>        }</span>
 232 |     | <span class='neutral'>    }</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='neutral'>    function assertApproxEqRelDecimal(</span>
 235 |     | <span class='neutral'>        uint256 a,</span>
 236 |     | <span class='neutral'>        uint256 b,</span>
 237 |     | <span class='neutral'>        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%</span>
 238 |     | <span class='neutral'>        uint256 decimals</span>
 239 |     | <span class='neutral'>    ) internal virtual {</span>
 240 |     | <span class='neutral'>        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='neutral'>        uint256 percentDelta = stdMath.percentDelta(a, b);</span>
 243 |     | <span class='neutral'></span>
 244 |     | <span class='neutral'>        if (percentDelta &gt; maxPercentDelta) {</span>
 245 |     | <span class='neutral'>            emit log(&quot;Error: a ~= b not satisfied [uint]&quot;);</span>
 246 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;        Left&quot;, a, decimals);</span>
 247 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;       Right&quot;, b, decimals);</span>
 248 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot; Max % Delta&quot;, maxPercentDelta, 18);</span>
 249 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;     % Delta&quot;, percentDelta, 18);</span>
 250 |     | <span class='neutral'>            fail();</span>
 251 |     | <span class='neutral'>        }</span>
 252 |     | <span class='neutral'>    }</span>
 253 |     | <span class='neutral'></span>
 254 |     | <span class='neutral'>    function assertApproxEqRelDecimal(</span>
 255 |     | <span class='neutral'>        uint256 a,</span>
 256 |     | <span class='neutral'>        uint256 b,</span>
 257 |     | <span class='neutral'>        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%</span>
 258 |     | <span class='neutral'>        uint256 decimals,</span>
 259 |     | <span class='neutral'>        string memory err</span>
 260 |     | <span class='neutral'>    ) internal virtual {</span>
 261 |     | <span class='neutral'>        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.</span>
 262 |     | <span class='neutral'></span>
 263 |     | <span class='neutral'>        uint256 percentDelta = stdMath.percentDelta(a, b);</span>
 264 |     | <span class='neutral'></span>
 265 |     | <span class='neutral'>        if (percentDelta &gt; maxPercentDelta) {</span>
 266 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 267 |     | <span class='neutral'>            assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals);</span>
 268 |     | <span class='neutral'>        }</span>
 269 |     | <span class='neutral'>    }</span>
 270 |     | <span class='neutral'></span>
 271 |     | <span class='neutral'>    function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta) internal virtual {</span>
 272 |     | <span class='neutral'>        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.</span>
 273 |     | <span class='neutral'></span>
 274 |     | <span class='neutral'>        uint256 percentDelta = stdMath.percentDelta(a, b);</span>
 275 |     | <span class='neutral'></span>
 276 |     | <span class='neutral'>        if (percentDelta &gt; maxPercentDelta) {</span>
 277 |     | <span class='neutral'>            emit log(&quot;Error: a ~= b not satisfied [int]&quot;);</span>
 278 |     | <span class='neutral'>            emit log_named_int(&quot;        Left&quot;, a);</span>
 279 |     | <span class='neutral'>            emit log_named_int(&quot;       Right&quot;, b);</span>
 280 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot; Max % Delta&quot;, maxPercentDelta, 18);</span>
 281 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;     % Delta&quot;, percentDelta, 18);</span>
 282 |     | <span class='neutral'>            fail();</span>
 283 |     | <span class='neutral'>        }</span>
 284 |     | <span class='neutral'>    }</span>
 285 |     | <span class='neutral'></span>
 286 |     | <span class='neutral'>    function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta, string memory err) internal virtual {</span>
 287 |     | <span class='neutral'>        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.</span>
 288 |     | <span class='neutral'></span>
 289 |     | <span class='neutral'>        uint256 percentDelta = stdMath.percentDelta(a, b);</span>
 290 |     | <span class='neutral'></span>
 291 |     | <span class='neutral'>        if (percentDelta &gt; maxPercentDelta) {</span>
 292 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 293 |     | <span class='neutral'>            assertApproxEqRel(a, b, maxPercentDelta);</span>
 294 |     | <span class='neutral'>        }</span>
 295 |     | <span class='neutral'>    }</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='neutral'>    function assertApproxEqRelDecimal(int256 a, int256 b, uint256 maxPercentDelta, uint256 decimals) internal virtual {</span>
 298 |     | <span class='neutral'>        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.</span>
 299 |     | <span class='neutral'></span>
 300 |     | <span class='neutral'>        uint256 percentDelta = stdMath.percentDelta(a, b);</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='neutral'>        if (percentDelta &gt; maxPercentDelta) {</span>
 303 |     | <span class='neutral'>            emit log(&quot;Error: a ~= b not satisfied [int]&quot;);</span>
 304 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;        Left&quot;, a, decimals);</span>
 305 |     | <span class='neutral'>            emit log_named_decimal_int(&quot;       Right&quot;, b, decimals);</span>
 306 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot; Max % Delta&quot;, maxPercentDelta, 18);</span>
 307 |     | <span class='neutral'>            emit log_named_decimal_uint(&quot;     % Delta&quot;, percentDelta, 18);</span>
 308 |     | <span class='neutral'>            fail();</span>
 309 |     | <span class='neutral'>        }</span>
 310 |     | <span class='neutral'>    }</span>
 311 |     | <span class='neutral'></span>
 312 |     | <span class='neutral'>    function assertApproxEqRelDecimal(int256 a, int256 b, uint256 maxPercentDelta, uint256 decimals, string memory err)</span>
 313 |     | <span class='neutral'>        internal</span>
 314 |     | <span class='neutral'>        virtual</span>
 315 |     | <span class='neutral'>    {</span>
 316 |     | <span class='neutral'>        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.</span>
 317 |     | <span class='neutral'></span>
 318 |     | <span class='neutral'>        uint256 percentDelta = stdMath.percentDelta(a, b);</span>
 319 |     | <span class='neutral'></span>
 320 |     | <span class='neutral'>        if (percentDelta &gt; maxPercentDelta) {</span>
 321 |     | <span class='neutral'>            emit log_named_string(&quot;Error&quot;, err);</span>
 322 |     | <span class='neutral'>            assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals);</span>
 323 |     | <span class='neutral'>        }</span>
 324 |     | <span class='neutral'>    }</span>
 325 |     | <span class='neutral'></span>
 326 |     | <span class='neutral'>    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB) internal virtual {</span>
 327 |     | <span class='neutral'>        assertEqCall(target, callDataA, target, callDataB, true);</span>
 328 |     | <span class='neutral'>    }</span>
 329 |     | <span class='neutral'></span>
 330 |     | <span class='neutral'>    function assertEqCall(address targetA, bytes memory callDataA, address targetB, bytes memory callDataB)</span>
 331 |     | <span class='neutral'>        internal</span>
 332 |     | <span class='neutral'>        virtual</span>
 333 |     | <span class='neutral'>    {</span>
 334 |     | <span class='neutral'>        assertEqCall(targetA, callDataA, targetB, callDataB, true);</span>
 335 |     | <span class='neutral'>    }</span>
 336 |     | <span class='neutral'></span>
 337 |     | <span class='neutral'>    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB, bool strictRevertData)</span>
 338 |     | <span class='neutral'>        internal</span>
 339 |     | <span class='neutral'>        virtual</span>
 340 |     | <span class='neutral'>    {</span>
 341 |     | <span class='neutral'>        assertEqCall(target, callDataA, target, callDataB, strictRevertData);</span>
 342 |     | <span class='neutral'>    }</span>
 343 |     | <span class='neutral'></span>
 344 |     | <span class='neutral'>    function assertEqCall(</span>
 345 |     | <span class='neutral'>        address targetA,</span>
 346 |     | <span class='neutral'>        bytes memory callDataA,</span>
 347 |     | <span class='neutral'>        address targetB,</span>
 348 |     | <span class='neutral'>        bytes memory callDataB,</span>
 349 |     | <span class='neutral'>        bool strictRevertData</span>
 350 |     | <span class='neutral'>    ) internal virtual {</span>
 351 |     | <span class='neutral'>        (bool successA, bytes memory returnDataA) = address(targetA).call(callDataA);</span>
 352 |     | <span class='neutral'>        (bool successB, bytes memory returnDataB) = address(targetB).call(callDataB);</span>
 353 |     | <span class='neutral'></span>
 354 |     | <span class='neutral'>        if (successA &amp;&amp; successB) {</span>
 355 |     | <span class='neutral'>            assertEq(returnDataA, returnDataB, &quot;Call return data does not match&quot;);</span>
 356 |     | <span class='neutral'>        }</span>
 357 |     | <span class='neutral'></span>
 358 |     | <span class='neutral'>        if (!successA &amp;&amp; !successB &amp;&amp; strictRevertData) {</span>
 359 |     | <span class='neutral'>            assertEq(returnDataA, returnDataB, &quot;Call revert data does not match&quot;);</span>
 360 |     | <span class='neutral'>        }</span>
 361 |     | <span class='neutral'></span>
 362 |     | <span class='neutral'>        if (!successA &amp;&amp; successB) {</span>
 363 |     | <span class='neutral'>            emit log(&quot;Error: Calls were not equal&quot;);</span>
 364 |     | <span class='neutral'>            emit log_named_bytes(&quot;  Left call revert data&quot;, returnDataA);</span>
 365 |     | <span class='neutral'>            emit log_named_bytes(&quot; Right call return data&quot;, returnDataB);</span>
 366 |     | <span class='neutral'>            fail();</span>
 367 |     | <span class='neutral'>        }</span>
 368 |     | <span class='neutral'></span>
 369 |     | <span class='neutral'>        if (successA &amp;&amp; !successB) {</span>
 370 |     | <span class='neutral'>            emit log(&quot;Error: Calls were not equal&quot;);</span>
 371 |     | <span class='neutral'>            emit log_named_bytes(&quot;  Left call return data&quot;, returnDataA);</span>
 372 |     | <span class='neutral'>            emit log_named_bytes(&quot; Right call revert data&quot;, returnDataB);</span>
 373 |     | <span class='neutral'>            fail();</span>
 374 |     | <span class='neutral'>        }</span>
 375 |     | <span class='neutral'>    }</span>
 376 |     | <span class='neutral'>}</span>
 377 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/forge-std/src/StdChains.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {VmSafe} from &quot;./Vm.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/**</span>
   9 |     | <span class='neutral'> * StdChains provides information about EVM compatible chains that can be used in scripts/tests.</span>
  10 |     | <span class='neutral'> * For each chain, the chain&#39;s name, chain ID, and a default RPC URL are provided. Chains are</span>
  11 |     | <span class='neutral'> * identified by their alias, which is the same as the alias in the `[rpc_endpoints]` section of</span>
  12 |     | <span class='neutral'> * the `foundry.toml` file. For best UX, ensure the alias in the `foundry.toml` file match the</span>
  13 |     | <span class='neutral'> * alias used in this contract, which can be found as the first argument to the</span>
  14 |     | <span class='neutral'> * `setChainWithDefaultRpcUrl` call in the `initialize` function.</span>
  15 |     | <span class='neutral'> *</span>
  16 |     | <span class='neutral'> * There are two main ways to use this contract:</span>
  17 |     | <span class='neutral'> *   1. Set a chain with `setChain(string memory chainAlias, ChainData memory chain)` or</span>
  18 |     | <span class='neutral'> *      `setChain(string memory chainAlias, Chain memory chain)`</span>
  19 |     | <span class='neutral'> *   2. Get a chain with `getChain(string memory chainAlias)` or `getChain(uint256 chainId)`.</span>
  20 |     | <span class='neutral'> *</span>
  21 |     | <span class='neutral'> * The first time either of those are used, chains are initialized with the default set of RPC URLs.</span>
  22 |     | <span class='neutral'> * This is done in `initialize`, which uses `setChainWithDefaultRpcUrl`. Defaults are recorded in</span>
  23 |     | <span class='neutral'> * `defaultRpcUrls`.</span>
  24 |     | <span class='neutral'> *</span>
  25 |     | <span class='neutral'> * The `setChain` function is straightforward, and it simply saves off the given chain data.</span>
  26 |     | <span class='neutral'> *</span>
  27 |     | <span class='neutral'> * The `getChain` methods use `getChainWithUpdatedRpcUrl` to return a chain. For example, let&#39;s say</span>
  28 |     | <span class='neutral'> * we want to retrieve `mainnet`&#39;s RPC URL:</span>
  29 |     | <span class='neutral'> *   - If you haven&#39;t set any mainnet chain info with `setChain`, you haven&#39;t specified that</span>
  30 |     | <span class='neutral'> *     chain in `foundry.toml` and no env var is set, the default data and RPC URL will be returned.</span>
  31 |     | <span class='neutral'> *   - If you have set a mainnet RPC URL in `foundry.toml` it will return that, if valid (e.g. if</span>
  32 |     | <span class='neutral'> *     a URL is given or if an environment variable is given and that environment variable exists).</span>
  33 |     | <span class='neutral'> *     Otherwise, the default data is returned.</span>
  34 |     | <span class='neutral'> *   - If you specified data with `setChain` it will return that.</span>
  35 |     | <span class='neutral'> *</span>
  36 |     | <span class='neutral'> * Summarizing the above, the prioritization hierarchy is `setChain` -&gt; `foundry.toml` -&gt; environment variable -&gt; defaults.</span>
  37 |     | <span class='neutral'> */</span>
  38 |     | <span class='neutral'>abstract contract StdChains {</span>
  39 |     | <span class='neutral'>    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    bool private initialized;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    struct ChainData {</span>
  44 |     | <span class='neutral'>        string name;</span>
  45 |     | <span class='neutral'>        uint256 chainId;</span>
  46 |     | <span class='neutral'>        string rpcUrl;</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    struct Chain {</span>
  50 |     | <span class='neutral'>        // The chain name.</span>
  51 |     | <span class='neutral'>        string name;</span>
  52 |     | <span class='neutral'>        // The chain&#39;s Chain ID.</span>
  53 |     | <span class='neutral'>        uint256 chainId;</span>
  54 |     | <span class='neutral'>        // The chain&#39;s alias. (i.e. what gets specified in `foundry.toml`).</span>
  55 |     | <span class='neutral'>        string chainAlias;</span>
  56 |     | <span class='neutral'>        // A default RPC endpoint for this chain.</span>
  57 |     | <span class='neutral'>        // NOTE: This default RPC URL is included for convenience to facilitate quick tests and</span>
  58 |     | <span class='neutral'>        // experimentation. Do not use this RPC URL for production test suites, CI, or other heavy</span>
  59 |     | <span class='neutral'>        // usage as you will be throttled and this is a disservice to others who need this endpoint.</span>
  60 |     | <span class='neutral'>        string rpcUrl;</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    // Maps from the chain&#39;s alias (matching the alias in the `foundry.toml` file) to chain data.</span>
  64 |     | <span class='neutral'>    mapping(string =&gt; Chain) private chains;</span>
  65 |     | <span class='neutral'>    // Maps from the chain&#39;s alias to it&#39;s default RPC URL.</span>
  66 |     | <span class='neutral'>    mapping(string =&gt; string) private defaultRpcUrls;</span>
  67 |     | <span class='neutral'>    // Maps from a chain ID to it&#39;s alias.</span>
  68 |     | <span class='neutral'>    mapping(uint256 =&gt; string) private idToAlias;</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='unexecuted'>    bool private fallbackToDefaultRpcUrls = true;</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    // The RPC URL will be fetched from config or defaultRpcUrls if possible.</span>
  73 |     | <span class='neutral'>    function getChain(string memory chainAlias) internal virtual returns (Chain memory chain) {</span>
  74 |     | <span class='neutral'>        require(bytes(chainAlias).length != 0, &quot;StdChains getChain(string): Chain alias cannot be the empty string.&quot;);</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>        initialize();</span>
  77 |     | <span class='neutral'>        chain = chains[chainAlias];</span>
  78 |     | <span class='neutral'>        require(</span>
  79 |     | <span class='neutral'>            chain.chainId != 0,</span>
  80 |     | <span class='neutral'>            string(abi.encodePacked(&quot;StdChains getChain(string): Chain with alias \&quot;&quot;, chainAlias, &quot;\&quot; not found.&quot;))</span>
  81 |     | <span class='neutral'>        );</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    function getChain(uint256 chainId) internal virtual returns (Chain memory chain) {</span>
  87 |     | <span class='neutral'>        require(chainId != 0, &quot;StdChains getChain(uint256): Chain ID cannot be 0.&quot;);</span>
  88 |     | <span class='neutral'>        initialize();</span>
  89 |     | <span class='neutral'>        string memory chainAlias = idToAlias[chainId];</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>        chain = chains[chainAlias];</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>        require(</span>
  94 |     | <span class='neutral'>            chain.chainId != 0,</span>
  95 |     | <span class='neutral'>            string(abi.encodePacked(&quot;StdChains getChain(uint256): Chain with ID &quot;, vm.toString(chainId), &quot; not found.&quot;))</span>
  96 |     | <span class='neutral'>        );</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);</span>
  99 |     | <span class='neutral'>    }</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>    // set chain info, with priority to argument&#39;s rpcUrl field.</span>
 102 |     | <span class='neutral'>    function setChain(string memory chainAlias, ChainData memory chain) internal virtual {</span>
 103 |     | <span class='neutral'>        require(</span>
 104 |     | <span class='neutral'>            bytes(chainAlias).length != 0,</span>
 105 |     | <span class='neutral'>            &quot;StdChains setChain(string,ChainData): Chain alias cannot be the empty string.&quot;</span>
 106 |     | <span class='neutral'>        );</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>        require(chain.chainId != 0, &quot;StdChains setChain(string,ChainData): Chain ID cannot be 0.&quot;);</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>        initialize();</span>
 111 |     | <span class='neutral'>        string memory foundAlias = idToAlias[chain.chainId];</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>        require(</span>
 114 |     | <span class='neutral'>            bytes(foundAlias).length == 0 || keccak256(bytes(foundAlias)) == keccak256(bytes(chainAlias)),</span>
 115 |     | <span class='neutral'>            string(</span>
 116 |     | <span class='neutral'>                abi.encodePacked(</span>
 117 |     | <span class='neutral'>                    &quot;StdChains setChain(string,ChainData): Chain ID &quot;,</span>
 118 |     | <span class='neutral'>                    vm.toString(chain.chainId),</span>
 119 |     | <span class='neutral'>                    &quot; already used by \&quot;&quot;,</span>
 120 |     | <span class='neutral'>                    foundAlias,</span>
 121 |     | <span class='neutral'>                    &quot;\&quot;.&quot;</span>
 122 |     | <span class='neutral'>                )</span>
 123 |     | <span class='neutral'>            )</span>
 124 |     | <span class='neutral'>        );</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>        uint256 oldChainId = chains[chainAlias].chainId;</span>
 127 |     | <span class='neutral'>        delete idToAlias[oldChainId];</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>        chains[chainAlias] =</span>
 130 |     | <span class='neutral'>            Chain({name: chain.name, chainId: chain.chainId, chainAlias: chainAlias, rpcUrl: chain.rpcUrl});</span>
 131 |     | <span class='neutral'>        idToAlias[chain.chainId] = chainAlias;</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>    // set chain info, with priority to argument&#39;s rpcUrl field.</span>
 135 |     | <span class='neutral'>    function setChain(string memory chainAlias, Chain memory chain) internal virtual {</span>
 136 |     | <span class='neutral'>        setChain(chainAlias, ChainData({name: chain.name, chainId: chain.chainId, rpcUrl: chain.rpcUrl}));</span>
 137 |     | <span class='neutral'>    }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>    function _toUpper(string memory str) private pure returns (string memory) {</span>
 140 |     | <span class='neutral'>        bytes memory strb = bytes(str);</span>
 141 |     | <span class='neutral'>        bytes memory copy = new bytes(strb.length);</span>
 142 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; strb.length; i++) {</span>
 143 |     | <span class='neutral'>            bytes1 b = strb[i];</span>
 144 |     | <span class='neutral'>            if (b &gt;= 0x61 &amp;&amp; b &lt;= 0x7A) {</span>
 145 |     | <span class='neutral'>                copy[i] = bytes1(uint8(b) - 32);</span>
 146 |     | <span class='neutral'>            } else {</span>
 147 |     | <span class='neutral'>                copy[i] = b;</span>
 148 |     | <span class='neutral'>            }</span>
 149 |     | <span class='neutral'>        }</span>
 150 |     | <span class='neutral'>        return string(copy);</span>
 151 |     | <span class='neutral'>    }</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='neutral'>    // lookup rpcUrl, in descending order of priority:</span>
 154 |     | <span class='neutral'>    // current -&gt; config (foundry.toml) -&gt; environment variable -&gt; default</span>
 155 |     | <span class='neutral'>    function getChainWithUpdatedRpcUrl(string memory chainAlias, Chain memory chain) private returns (Chain memory) {</span>
 156 |     | <span class='neutral'>        if (bytes(chain.rpcUrl).length == 0) {</span>
 157 |     | <span class='neutral'>            try vm.rpcUrl(chainAlias) returns (string memory configRpcUrl) {</span>
 158 |     | <span class='neutral'>                chain.rpcUrl = configRpcUrl;</span>
 159 |     | <span class='neutral'>            } catch (bytes memory err) {</span>
 160 |     | <span class='neutral'>                string memory envName = string(abi.encodePacked(_toUpper(chainAlias), &quot;_RPC_URL&quot;));</span>
 161 |     | <span class='neutral'>                if (fallbackToDefaultRpcUrls) {</span>
 162 |     | <span class='neutral'>                    chain.rpcUrl = vm.envOr(envName, defaultRpcUrls[chainAlias]);</span>
 163 |     | <span class='neutral'>                } else {</span>
 164 |     | <span class='neutral'>                    chain.rpcUrl = vm.envString(envName);</span>
 165 |     | <span class='neutral'>                }</span>
 166 |     | <span class='neutral'>                // distinguish &#39;not found&#39; from &#39;cannot read&#39;</span>
 167 |     | <span class='neutral'>                bytes memory notFoundError =</span>
 168 |     | <span class='neutral'>                    abi.encodeWithSignature(&quot;CheatCodeError&quot;, string(abi.encodePacked(&quot;invalid rpc url &quot;, chainAlias)));</span>
 169 |     | <span class='neutral'>                if (keccak256(notFoundError) != keccak256(err) || bytes(chain.rpcUrl).length == 0) {</span>
 170 |     | <span class='neutral'>                    /// @solidity memory-safe-assembly</span>
 171 |     | <span class='neutral'>                    assembly {</span>
 172 |     | <span class='neutral'>                        revert(add(32, err), mload(err))</span>
 173 |     | <span class='neutral'>                    }</span>
 174 |     | <span class='neutral'>                }</span>
 175 |     | <span class='neutral'>            }</span>
 176 |     | <span class='neutral'>        }</span>
 177 |     | <span class='neutral'>        return chain;</span>
 178 |     | <span class='neutral'>    }</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='neutral'>    function setFallbackToDefaultRpcUrls(bool useDefault) internal {</span>
 181 |     | <span class='neutral'>        fallbackToDefaultRpcUrls = useDefault;</span>
 182 |     | <span class='neutral'>    }</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>    function initialize() private {</span>
 185 |     | <span class='neutral'>        if (initialized) return;</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>        initialized = true;</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='neutral'>        // If adding an RPC here, make sure to test the default RPC URL in `testRpcs`</span>
 190 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;anvil&quot;, ChainData(&quot;Anvil&quot;, 31337, &quot;http://127.0.0.1:8545&quot;));</span>
 191 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 192 |     | <span class='neutral'>            &quot;mainnet&quot;, ChainData(&quot;Mainnet&quot;, 1, &quot;https://mainnet.infura.io/v3/f4a0bdad42674adab5fc0ac077ffab2b&quot;)</span>
 193 |     | <span class='neutral'>        );</span>
 194 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 195 |     | <span class='neutral'>            &quot;goerli&quot;, ChainData(&quot;Goerli&quot;, 5, &quot;https://goerli.infura.io/v3/f4a0bdad42674adab5fc0ac077ffab2b&quot;)</span>
 196 |     | <span class='neutral'>        );</span>
 197 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 198 |     | <span class='neutral'>            &quot;sepolia&quot;, ChainData(&quot;Sepolia&quot;, 11155111, &quot;https://sepolia.infura.io/v3/f4a0bdad42674adab5fc0ac077ffab2b&quot;)</span>
 199 |     | <span class='neutral'>        );</span>
 200 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;optimism&quot;, ChainData(&quot;Optimism&quot;, 10, &quot;https://mainnet.optimism.io&quot;));</span>
 201 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;optimism_goerli&quot;, ChainData(&quot;Optimism Goerli&quot;, 420, &quot;https://goerli.optimism.io&quot;));</span>
 202 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;arbitrum_one&quot;, ChainData(&quot;Arbitrum One&quot;, 42161, &quot;https://arb1.arbitrum.io/rpc&quot;));</span>
 203 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 204 |     | <span class='neutral'>            &quot;arbitrum_one_goerli&quot;, ChainData(&quot;Arbitrum One Goerli&quot;, 421613, &quot;https://goerli-rollup.arbitrum.io/rpc&quot;)</span>
 205 |     | <span class='neutral'>        );</span>
 206 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;arbitrum_nova&quot;, ChainData(&quot;Arbitrum Nova&quot;, 42170, &quot;https://nova.arbitrum.io/rpc&quot;));</span>
 207 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;polygon&quot;, ChainData(&quot;Polygon&quot;, 137, &quot;https://polygon-rpc.com&quot;));</span>
 208 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 209 |     | <span class='neutral'>            &quot;polygon_mumbai&quot;, ChainData(&quot;Polygon Mumbai&quot;, 80001, &quot;https://rpc-mumbai.maticvigil.com&quot;)</span>
 210 |     | <span class='neutral'>        );</span>
 211 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;avalanche&quot;, ChainData(&quot;Avalanche&quot;, 43114, &quot;https://api.avax.network/ext/bc/C/rpc&quot;));</span>
 212 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 213 |     | <span class='neutral'>            &quot;avalanche_fuji&quot;, ChainData(&quot;Avalanche Fuji&quot;, 43113, &quot;https://api.avax-test.network/ext/bc/C/rpc&quot;)</span>
 214 |     | <span class='neutral'>        );</span>
 215 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 216 |     | <span class='neutral'>            &quot;bnb_smart_chain&quot;, ChainData(&quot;BNB Smart Chain&quot;, 56, &quot;https://bsc-dataseed1.binance.org&quot;)</span>
 217 |     | <span class='neutral'>        );</span>
 218 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 219 |     | <span class='neutral'>            &quot;bnb_smart_chain_testnet&quot;,</span>
 220 |     | <span class='neutral'>            ChainData(&quot;BNB Smart Chain Testnet&quot;, 97, &quot;https://rpc.ankr.com/bsc_testnet_chapel&quot;)</span>
 221 |     | <span class='neutral'>        );</span>
 222 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;gnosis_chain&quot;, ChainData(&quot;Gnosis Chain&quot;, 100, &quot;https://rpc.gnosischain.com&quot;));</span>
 223 |     | <span class='neutral'>    }</span>
 224 |     | <span class='neutral'></span>
 225 |     | <span class='neutral'>    // set chain info, with priority to chainAlias&#39; rpc url in foundry.toml</span>
 226 |     | <span class='neutral'>    function setChainWithDefaultRpcUrl(string memory chainAlias, ChainData memory chain) private {</span>
 227 |     | <span class='neutral'>        string memory rpcUrl = chain.rpcUrl;</span>
 228 |     | <span class='neutral'>        defaultRpcUrls[chainAlias] = rpcUrl;</span>
 229 |     | <span class='neutral'>        chain.rpcUrl = &quot;&quot;;</span>
 230 |     | <span class='neutral'>        setChain(chainAlias, chain);</span>
 231 |     | <span class='neutral'>        chain.rpcUrl = rpcUrl; // restore argument</span>
 232 |     | <span class='neutral'>    }</span>
 233 |     | <span class='neutral'>}</span>
 234 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/forge-std/src/StdCheats.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {StdStorage, stdStorage} from &quot;./StdStorage.sol&quot;;</span>
   7 |     | <span class='neutral'>import {Vm} from &quot;./Vm.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>abstract contract StdCheatsSafe {</span>
  10 |     | <span class='neutral'>    Vm private constant vm = Vm(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>    bool private gasMeteringOff;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>    // Data structures to parse Transaction objects from the broadcast artifact</span>
  15 |     | <span class='neutral'>    // that conform to EIP1559. The Raw structs is what is parsed from the JSON</span>
  16 |     | <span class='neutral'>    // and then converted to the one that is used by the user for better UX.</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    struct RawTx1559 {</span>
  19 |     | <span class='neutral'>        string[] arguments;</span>
  20 |     | <span class='neutral'>        address contractAddress;</span>
  21 |     | <span class='neutral'>        string contractName;</span>
  22 |     | <span class='neutral'>        // json value name = function</span>
  23 |     | <span class='neutral'>        string functionSig;</span>
  24 |     | <span class='neutral'>        bytes32 hash;</span>
  25 |     | <span class='neutral'>        // json value name = tx</span>
  26 |     | <span class='neutral'>        RawTx1559Detail txDetail;</span>
  27 |     | <span class='neutral'>        // json value name = type</span>
  28 |     | <span class='neutral'>        string opcode;</span>
  29 |     | <span class='neutral'>    }</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    struct RawTx1559Detail {</span>
  32 |     | <span class='neutral'>        AccessList[] accessList;</span>
  33 |     | <span class='neutral'>        bytes data;</span>
  34 |     | <span class='neutral'>        address from;</span>
  35 |     | <span class='neutral'>        bytes gas;</span>
  36 |     | <span class='neutral'>        bytes nonce;</span>
  37 |     | <span class='neutral'>        address to;</span>
  38 |     | <span class='neutral'>        bytes txType;</span>
  39 |     | <span class='neutral'>        bytes value;</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    struct Tx1559 {</span>
  43 |     | <span class='neutral'>        string[] arguments;</span>
  44 |     | <span class='neutral'>        address contractAddress;</span>
  45 |     | <span class='neutral'>        string contractName;</span>
  46 |     | <span class='neutral'>        string functionSig;</span>
  47 |     | <span class='neutral'>        bytes32 hash;</span>
  48 |     | <span class='neutral'>        Tx1559Detail txDetail;</span>
  49 |     | <span class='neutral'>        string opcode;</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    struct Tx1559Detail {</span>
  53 |     | <span class='neutral'>        AccessList[] accessList;</span>
  54 |     | <span class='neutral'>        bytes data;</span>
  55 |     | <span class='neutral'>        address from;</span>
  56 |     | <span class='neutral'>        uint256 gas;</span>
  57 |     | <span class='neutral'>        uint256 nonce;</span>
  58 |     | <span class='neutral'>        address to;</span>
  59 |     | <span class='neutral'>        uint256 txType;</span>
  60 |     | <span class='neutral'>        uint256 value;</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    // Data structures to parse Transaction objects from the broadcast artifact</span>
  64 |     | <span class='neutral'>    // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON</span>
  65 |     | <span class='neutral'>    // and then converted to the one that is used by the user for better UX.</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    struct TxLegacy {</span>
  68 |     | <span class='neutral'>        string[] arguments;</span>
  69 |     | <span class='neutral'>        address contractAddress;</span>
  70 |     | <span class='neutral'>        string contractName;</span>
  71 |     | <span class='neutral'>        string functionSig;</span>
  72 |     | <span class='neutral'>        string hash;</span>
  73 |     | <span class='neutral'>        string opcode;</span>
  74 |     | <span class='neutral'>        TxDetailLegacy transaction;</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    struct TxDetailLegacy {</span>
  78 |     | <span class='neutral'>        AccessList[] accessList;</span>
  79 |     | <span class='neutral'>        uint256 chainId;</span>
  80 |     | <span class='neutral'>        bytes data;</span>
  81 |     | <span class='neutral'>        address from;</span>
  82 |     | <span class='neutral'>        uint256 gas;</span>
  83 |     | <span class='neutral'>        uint256 gasPrice;</span>
  84 |     | <span class='neutral'>        bytes32 hash;</span>
  85 |     | <span class='neutral'>        uint256 nonce;</span>
  86 |     | <span class='neutral'>        bytes1 opcode;</span>
  87 |     | <span class='neutral'>        bytes32 r;</span>
  88 |     | <span class='neutral'>        bytes32 s;</span>
  89 |     | <span class='neutral'>        uint256 txType;</span>
  90 |     | <span class='neutral'>        address to;</span>
  91 |     | <span class='neutral'>        uint8 v;</span>
  92 |     | <span class='neutral'>        uint256 value;</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    struct AccessList {</span>
  96 |     | <span class='neutral'>        address accessAddress;</span>
  97 |     | <span class='neutral'>        bytes32[] storageKeys;</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    // Data structures to parse Receipt objects from the broadcast artifact.</span>
 101 |     | <span class='neutral'>    // The Raw structs is what is parsed from the JSON</span>
 102 |     | <span class='neutral'>    // and then converted to the one that is used by the user for better UX.</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    struct RawReceipt {</span>
 105 |     | <span class='neutral'>        bytes32 blockHash;</span>
 106 |     | <span class='neutral'>        bytes blockNumber;</span>
 107 |     | <span class='neutral'>        address contractAddress;</span>
 108 |     | <span class='neutral'>        bytes cumulativeGasUsed;</span>
 109 |     | <span class='neutral'>        bytes effectiveGasPrice;</span>
 110 |     | <span class='neutral'>        address from;</span>
 111 |     | <span class='neutral'>        bytes gasUsed;</span>
 112 |     | <span class='neutral'>        RawReceiptLog[] logs;</span>
 113 |     | <span class='neutral'>        bytes logsBloom;</span>
 114 |     | <span class='neutral'>        bytes status;</span>
 115 |     | <span class='neutral'>        address to;</span>
 116 |     | <span class='neutral'>        bytes32 transactionHash;</span>
 117 |     | <span class='neutral'>        bytes transactionIndex;</span>
 118 |     | <span class='neutral'>    }</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>    struct Receipt {</span>
 121 |     | <span class='neutral'>        bytes32 blockHash;</span>
 122 |     | <span class='neutral'>        uint256 blockNumber;</span>
 123 |     | <span class='neutral'>        address contractAddress;</span>
 124 |     | <span class='neutral'>        uint256 cumulativeGasUsed;</span>
 125 |     | <span class='neutral'>        uint256 effectiveGasPrice;</span>
 126 |     | <span class='neutral'>        address from;</span>
 127 |     | <span class='neutral'>        uint256 gasUsed;</span>
 128 |     | <span class='neutral'>        ReceiptLog[] logs;</span>
 129 |     | <span class='neutral'>        bytes logsBloom;</span>
 130 |     | <span class='neutral'>        uint256 status;</span>
 131 |     | <span class='neutral'>        address to;</span>
 132 |     | <span class='neutral'>        bytes32 transactionHash;</span>
 133 |     | <span class='neutral'>        uint256 transactionIndex;</span>
 134 |     | <span class='neutral'>    }</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>    // Data structures to parse the entire broadcast artifact, assuming the</span>
 137 |     | <span class='neutral'>    // transactions conform to EIP1559.</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>    struct EIP1559ScriptArtifact {</span>
 140 |     | <span class='neutral'>        string[] libraries;</span>
 141 |     | <span class='neutral'>        string path;</span>
 142 |     | <span class='neutral'>        string[] pending;</span>
 143 |     | <span class='neutral'>        Receipt[] receipts;</span>
 144 |     | <span class='neutral'>        uint256 timestamp;</span>
 145 |     | <span class='neutral'>        Tx1559[] transactions;</span>
 146 |     | <span class='neutral'>        TxReturn[] txReturns;</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    struct RawEIP1559ScriptArtifact {</span>
 150 |     | <span class='neutral'>        string[] libraries;</span>
 151 |     | <span class='neutral'>        string path;</span>
 152 |     | <span class='neutral'>        string[] pending;</span>
 153 |     | <span class='neutral'>        RawReceipt[] receipts;</span>
 154 |     | <span class='neutral'>        TxReturn[] txReturns;</span>
 155 |     | <span class='neutral'>        uint256 timestamp;</span>
 156 |     | <span class='neutral'>        RawTx1559[] transactions;</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>    struct RawReceiptLog {</span>
 160 |     | <span class='neutral'>        // json value = address</span>
 161 |     | <span class='neutral'>        address logAddress;</span>
 162 |     | <span class='neutral'>        bytes32 blockHash;</span>
 163 |     | <span class='neutral'>        bytes blockNumber;</span>
 164 |     | <span class='neutral'>        bytes data;</span>
 165 |     | <span class='neutral'>        bytes logIndex;</span>
 166 |     | <span class='neutral'>        bool removed;</span>
 167 |     | <span class='neutral'>        bytes32[] topics;</span>
 168 |     | <span class='neutral'>        bytes32 transactionHash;</span>
 169 |     | <span class='neutral'>        bytes transactionIndex;</span>
 170 |     | <span class='neutral'>        bytes transactionLogIndex;</span>
 171 |     | <span class='neutral'>    }</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='neutral'>    struct ReceiptLog {</span>
 174 |     | <span class='neutral'>        // json value = address</span>
 175 |     | <span class='neutral'>        address logAddress;</span>
 176 |     | <span class='neutral'>        bytes32 blockHash;</span>
 177 |     | <span class='neutral'>        uint256 blockNumber;</span>
 178 |     | <span class='neutral'>        bytes data;</span>
 179 |     | <span class='neutral'>        uint256 logIndex;</span>
 180 |     | <span class='neutral'>        bytes32[] topics;</span>
 181 |     | <span class='neutral'>        uint256 transactionIndex;</span>
 182 |     | <span class='neutral'>        uint256 transactionLogIndex;</span>
 183 |     | <span class='neutral'>        bool removed;</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>    struct TxReturn {</span>
 187 |     | <span class='neutral'>        string internalType;</span>
 188 |     | <span class='neutral'>        string value;</span>
 189 |     | <span class='neutral'>    }</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>    function assumeNoPrecompiles(address addr) internal virtual {</span>
 192 |     | <span class='neutral'>        // Assembly required since `block.chainid` was introduced in 0.8.0.</span>
 193 |     | <span class='neutral'>        uint256 chainId;</span>
 194 |     | <span class='neutral'>        assembly {</span>
 195 |     | <span class='neutral'>            chainId := chainid()</span>
 196 |     | <span class='neutral'>        }</span>
 197 |     | <span class='neutral'>        assumeNoPrecompiles(addr, chainId);</span>
 198 |     | <span class='neutral'>    }</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>    function assumeNoPrecompiles(address addr, uint256 chainId) internal pure virtual {</span>
 201 |     | <span class='neutral'>        // Note: For some chains like Optimism these are technically predeploys (i.e. bytecode placed at a specific</span>
 202 |     | <span class='neutral'>        // address), but the same rationale for excluding them applies so we include those too.</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='neutral'>        // These should be present on all EVM-compatible chains.</span>
 205 |     | <span class='neutral'>        vm.assume(addr &lt; address(0x1) || addr &gt; address(0x9));</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='neutral'>        // forgefmt: disable-start</span>
 208 |     | <span class='neutral'>        if (chainId == 10 || chainId == 420) {</span>
 209 |     | <span class='neutral'>            // https://github.com/ethereum-optimism/optimism/blob/eaa371a0184b56b7ca6d9eb9cb0a2b78b2ccd864/op-bindings/predeploys/addresses.go#L6-L21</span>
 210 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x4200000000000000000000000000000000000000) || addr &gt; address(0x4200000000000000000000000000000000000800));</span>
 211 |     | <span class='neutral'>        } else if (chainId == 42161 || chainId == 421613) {</span>
 212 |     | <span class='neutral'>            // https://developer.arbitrum.io/useful-addresses#arbitrum-precompiles-l2-same-on-all-arb-chains</span>
 213 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x0000000000000000000000000000000000000064) || addr &gt; address(0x0000000000000000000000000000000000000068));</span>
 214 |     | <span class='neutral'>        } else if (chainId == 43114 || chainId == 43113) {</span>
 215 |     | <span class='neutral'>            // https://github.com/ava-labs/subnet-evm/blob/47c03fd007ecaa6de2c52ea081596e0a88401f58/precompile/params.go#L18-L59</span>
 216 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x0100000000000000000000000000000000000000) || addr &gt; address(0x01000000000000000000000000000000000000ff));</span>
 217 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x0200000000000000000000000000000000000000) || addr &gt; address(0x02000000000000000000000000000000000000FF));</span>
 218 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x0300000000000000000000000000000000000000) || addr &gt; address(0x03000000000000000000000000000000000000Ff));</span>
 219 |     | <span class='neutral'>        }</span>
 220 |     | <span class='neutral'>        // forgefmt: disable-end</span>
 221 |     | <span class='neutral'>    }</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='neutral'>    function readEIP1559ScriptArtifact(string memory path)</span>
 224 |     | <span class='neutral'>        internal</span>
 225 |     | <span class='neutral'>        view</span>
 226 |     | <span class='neutral'>        virtual</span>
 227 |     | <span class='neutral'>        returns (EIP1559ScriptArtifact memory)</span>
 228 |     | <span class='neutral'>    {</span>
 229 |     | <span class='neutral'>        string memory data = vm.readFile(path);</span>
 230 |     | <span class='neutral'>        bytes memory parsedData = vm.parseJson(data);</span>
 231 |     | <span class='neutral'>        RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));</span>
 232 |     | <span class='neutral'>        EIP1559ScriptArtifact memory artifact;</span>
 233 |     | <span class='neutral'>        artifact.libraries = rawArtifact.libraries;</span>
 234 |     | <span class='neutral'>        artifact.path = rawArtifact.path;</span>
 235 |     | <span class='neutral'>        artifact.timestamp = rawArtifact.timestamp;</span>
 236 |     | <span class='neutral'>        artifact.pending = rawArtifact.pending;</span>
 237 |     | <span class='neutral'>        artifact.txReturns = rawArtifact.txReturns;</span>
 238 |     | <span class='neutral'>        artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);</span>
 239 |     | <span class='neutral'>        artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);</span>
 240 |     | <span class='neutral'>        return artifact;</span>
 241 |     | <span class='neutral'>    }</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='neutral'>    function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs) internal pure virtual returns (Tx1559[] memory) {</span>
 244 |     | <span class='neutral'>        Tx1559[] memory txs = new Tx1559[](rawTxs.length);</span>
 245 |     | <span class='neutral'>        for (uint256 i; i &lt; rawTxs.length; i++) {</span>
 246 |     | <span class='neutral'>            txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);</span>
 247 |     | <span class='neutral'>        }</span>
 248 |     | <span class='neutral'>        return txs;</span>
 249 |     | <span class='neutral'>    }</span>
 250 |     | <span class='neutral'></span>
 251 |     | <span class='neutral'>    function rawToConvertedEIPTx1559(RawTx1559 memory rawTx) internal pure virtual returns (Tx1559 memory) {</span>
 252 |     | <span class='neutral'>        Tx1559 memory transaction;</span>
 253 |     | <span class='neutral'>        transaction.arguments = rawTx.arguments;</span>
 254 |     | <span class='neutral'>        transaction.contractName = rawTx.contractName;</span>
 255 |     | <span class='neutral'>        transaction.functionSig = rawTx.functionSig;</span>
 256 |     | <span class='neutral'>        transaction.hash = rawTx.hash;</span>
 257 |     | <span class='neutral'>        transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);</span>
 258 |     | <span class='neutral'>        transaction.opcode = rawTx.opcode;</span>
 259 |     | <span class='neutral'>        return transaction;</span>
 260 |     | <span class='neutral'>    }</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='neutral'>    function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)</span>
 263 |     | <span class='neutral'>        internal</span>
 264 |     | <span class='neutral'>        pure</span>
 265 |     | <span class='neutral'>        virtual</span>
 266 |     | <span class='neutral'>        returns (Tx1559Detail memory)</span>
 267 |     | <span class='neutral'>    {</span>
 268 |     | <span class='neutral'>        Tx1559Detail memory txDetail;</span>
 269 |     | <span class='neutral'>        txDetail.data = rawDetail.data;</span>
 270 |     | <span class='neutral'>        txDetail.from = rawDetail.from;</span>
 271 |     | <span class='neutral'>        txDetail.to = rawDetail.to;</span>
 272 |     | <span class='neutral'>        txDetail.nonce = _bytesToUint(rawDetail.nonce);</span>
 273 |     | <span class='neutral'>        txDetail.txType = _bytesToUint(rawDetail.txType);</span>
 274 |     | <span class='neutral'>        txDetail.value = _bytesToUint(rawDetail.value);</span>
 275 |     | <span class='neutral'>        txDetail.gas = _bytesToUint(rawDetail.gas);</span>
 276 |     | <span class='neutral'>        txDetail.accessList = rawDetail.accessList;</span>
 277 |     | <span class='neutral'>        return txDetail;</span>
 278 |     | <span class='neutral'>    }</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>    function readTx1559s(string memory path) internal view virtual returns (Tx1559[] memory) {</span>
 281 |     | <span class='neutral'>        string memory deployData = vm.readFile(path);</span>
 282 |     | <span class='neutral'>        bytes memory parsedDeployData = vm.parseJson(deployData, &quot;.transactions&quot;);</span>
 283 |     | <span class='neutral'>        RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));</span>
 284 |     | <span class='neutral'>        return rawToConvertedEIPTx1559s(rawTxs);</span>
 285 |     | <span class='neutral'>    }</span>
 286 |     | <span class='neutral'></span>
 287 |     | <span class='neutral'>    function readTx1559(string memory path, uint256 index) internal view virtual returns (Tx1559 memory) {</span>
 288 |     | <span class='neutral'>        string memory deployData = vm.readFile(path);</span>
 289 |     | <span class='neutral'>        string memory key = string(abi.encodePacked(&quot;.transactions[&quot;, vm.toString(index), &quot;]&quot;));</span>
 290 |     | <span class='neutral'>        bytes memory parsedDeployData = vm.parseJson(deployData, key);</span>
 291 |     | <span class='neutral'>        RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));</span>
 292 |     | <span class='neutral'>        return rawToConvertedEIPTx1559(rawTx);</span>
 293 |     | <span class='neutral'>    }</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='neutral'>    // Analogous to readTransactions, but for receipts.</span>
 296 |     | <span class='neutral'>    function readReceipts(string memory path) internal view virtual returns (Receipt[] memory) {</span>
 297 |     | <span class='neutral'>        string memory deployData = vm.readFile(path);</span>
 298 |     | <span class='neutral'>        bytes memory parsedDeployData = vm.parseJson(deployData, &quot;.receipts&quot;);</span>
 299 |     | <span class='neutral'>        RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));</span>
 300 |     | <span class='neutral'>        return rawToConvertedReceipts(rawReceipts);</span>
 301 |     | <span class='neutral'>    }</span>
 302 |     | <span class='neutral'></span>
 303 |     | <span class='neutral'>    function readReceipt(string memory path, uint256 index) internal view virtual returns (Receipt memory) {</span>
 304 |     | <span class='neutral'>        string memory deployData = vm.readFile(path);</span>
 305 |     | <span class='neutral'>        string memory key = string(abi.encodePacked(&quot;.receipts[&quot;, vm.toString(index), &quot;]&quot;));</span>
 306 |     | <span class='neutral'>        bytes memory parsedDeployData = vm.parseJson(deployData, key);</span>
 307 |     | <span class='neutral'>        RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));</span>
 308 |     | <span class='neutral'>        return rawToConvertedReceipt(rawReceipt);</span>
 309 |     | <span class='neutral'>    }</span>
 310 |     | <span class='neutral'></span>
 311 |     | <span class='neutral'>    function rawToConvertedReceipts(RawReceipt[] memory rawReceipts) internal pure virtual returns (Receipt[] memory) {</span>
 312 |     | <span class='neutral'>        Receipt[] memory receipts = new Receipt[](rawReceipts.length);</span>
 313 |     | <span class='neutral'>        for (uint256 i; i &lt; rawReceipts.length; i++) {</span>
 314 |     | <span class='neutral'>            receipts[i] = rawToConvertedReceipt(rawReceipts[i]);</span>
 315 |     | <span class='neutral'>        }</span>
 316 |     | <span class='neutral'>        return receipts;</span>
 317 |     | <span class='neutral'>    }</span>
 318 |     | <span class='neutral'></span>
 319 |     | <span class='neutral'>    function rawToConvertedReceipt(RawReceipt memory rawReceipt) internal pure virtual returns (Receipt memory) {</span>
 320 |     | <span class='neutral'>        Receipt memory receipt;</span>
 321 |     | <span class='neutral'>        receipt.blockHash = rawReceipt.blockHash;</span>
 322 |     | <span class='neutral'>        receipt.to = rawReceipt.to;</span>
 323 |     | <span class='neutral'>        receipt.from = rawReceipt.from;</span>
 324 |     | <span class='neutral'>        receipt.contractAddress = rawReceipt.contractAddress;</span>
 325 |     | <span class='neutral'>        receipt.effectiveGasPrice = _bytesToUint(rawReceipt.effectiveGasPrice);</span>
 326 |     | <span class='neutral'>        receipt.cumulativeGasUsed = _bytesToUint(rawReceipt.cumulativeGasUsed);</span>
 327 |     | <span class='neutral'>        receipt.gasUsed = _bytesToUint(rawReceipt.gasUsed);</span>
 328 |     | <span class='neutral'>        receipt.status = _bytesToUint(rawReceipt.status);</span>
 329 |     | <span class='neutral'>        receipt.transactionIndex = _bytesToUint(rawReceipt.transactionIndex);</span>
 330 |     | <span class='neutral'>        receipt.blockNumber = _bytesToUint(rawReceipt.blockNumber);</span>
 331 |     | <span class='neutral'>        receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);</span>
 332 |     | <span class='neutral'>        receipt.logsBloom = rawReceipt.logsBloom;</span>
 333 |     | <span class='neutral'>        receipt.transactionHash = rawReceipt.transactionHash;</span>
 334 |     | <span class='neutral'>        return receipt;</span>
 335 |     | <span class='neutral'>    }</span>
 336 |     | <span class='neutral'></span>
 337 |     | <span class='neutral'>    function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)</span>
 338 |     | <span class='neutral'>        internal</span>
 339 |     | <span class='neutral'>        pure</span>
 340 |     | <span class='neutral'>        virtual</span>
 341 |     | <span class='neutral'>        returns (ReceiptLog[] memory)</span>
 342 |     | <span class='neutral'>    {</span>
 343 |     | <span class='neutral'>        ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);</span>
 344 |     | <span class='neutral'>        for (uint256 i; i &lt; rawLogs.length; i++) {</span>
 345 |     | <span class='neutral'>            logs[i].logAddress = rawLogs[i].logAddress;</span>
 346 |     | <span class='neutral'>            logs[i].blockHash = rawLogs[i].blockHash;</span>
 347 |     | <span class='neutral'>            logs[i].blockNumber = _bytesToUint(rawLogs[i].blockNumber);</span>
 348 |     | <span class='neutral'>            logs[i].data = rawLogs[i].data;</span>
 349 |     | <span class='neutral'>            logs[i].logIndex = _bytesToUint(rawLogs[i].logIndex);</span>
 350 |     | <span class='neutral'>            logs[i].topics = rawLogs[i].topics;</span>
 351 |     | <span class='neutral'>            logs[i].transactionIndex = _bytesToUint(rawLogs[i].transactionIndex);</span>
 352 |     | <span class='neutral'>            logs[i].transactionLogIndex = _bytesToUint(rawLogs[i].transactionLogIndex);</span>
 353 |     | <span class='neutral'>            logs[i].removed = rawLogs[i].removed;</span>
 354 |     | <span class='neutral'>        }</span>
 355 |     | <span class='neutral'>        return logs;</span>
 356 |     | <span class='neutral'>    }</span>
 357 |     | <span class='neutral'></span>
 358 |     | <span class='neutral'>    // Deploy a contract by fetching the contract bytecode from</span>
 359 |     | <span class='neutral'>    // the artifacts directory</span>
 360 |     | <span class='neutral'>    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`</span>
 361 |     | <span class='neutral'>    function deployCode(string memory what, bytes memory args) internal virtual returns (address addr) {</span>
 362 |     | <span class='neutral'>        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);</span>
 363 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 364 |     | <span class='neutral'>        assembly {</span>
 365 |     | <span class='neutral'>            addr := create(0, add(bytecode, 0x20), mload(bytecode))</span>
 366 |     | <span class='neutral'>        }</span>
 367 |     | <span class='neutral'></span>
 368 |     | <span class='neutral'>        require(addr != address(0), &quot;StdCheats deployCode(string,bytes): Deployment failed.&quot;);</span>
 369 |     | <span class='neutral'>    }</span>
 370 |     | <span class='neutral'></span>
 371 |     | <span class='neutral'>    function deployCode(string memory what) internal virtual returns (address addr) {</span>
 372 |     | <span class='neutral'>        bytes memory bytecode = vm.getCode(what);</span>
 373 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 374 |     | <span class='neutral'>        assembly {</span>
 375 |     | <span class='neutral'>            addr := create(0, add(bytecode, 0x20), mload(bytecode))</span>
 376 |     | <span class='neutral'>        }</span>
 377 |     | <span class='neutral'></span>
 378 |     | <span class='neutral'>        require(addr != address(0), &quot;StdCheats deployCode(string): Deployment failed.&quot;);</span>
 379 |     | <span class='neutral'>    }</span>
 380 |     | <span class='neutral'></span>
 381 |     | <span class='neutral'>    /// @dev deploy contract with value on construction</span>
 382 |     | <span class='neutral'>    function deployCode(string memory what, bytes memory args, uint256 val) internal virtual returns (address addr) {</span>
 383 |     | <span class='neutral'>        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);</span>
 384 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 385 |     | <span class='neutral'>        assembly {</span>
 386 |     | <span class='neutral'>            addr := create(val, add(bytecode, 0x20), mload(bytecode))</span>
 387 |     | <span class='neutral'>        }</span>
 388 |     | <span class='neutral'></span>
 389 |     | <span class='neutral'>        require(addr != address(0), &quot;StdCheats deployCode(string,bytes,uint256): Deployment failed.&quot;);</span>
 390 |     | <span class='neutral'>    }</span>
 391 |     | <span class='neutral'></span>
 392 |     | <span class='neutral'>    function deployCode(string memory what, uint256 val) internal virtual returns (address addr) {</span>
 393 |     | <span class='neutral'>        bytes memory bytecode = vm.getCode(what);</span>
 394 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 395 |     | <span class='neutral'>        assembly {</span>
 396 |     | <span class='neutral'>            addr := create(val, add(bytecode, 0x20), mload(bytecode))</span>
 397 |     | <span class='neutral'>        }</span>
 398 |     | <span class='neutral'></span>
 399 |     | <span class='neutral'>        require(addr != address(0), &quot;StdCheats deployCode(string,uint256): Deployment failed.&quot;);</span>
 400 |     | <span class='neutral'>    }</span>
 401 |     | <span class='neutral'></span>
 402 |     | <span class='neutral'>    // creates a labeled address and the corresponding private key</span>
 403 |     | <span class='neutral'>    function makeAddrAndKey(string memory name) internal virtual returns (address addr, uint256 privateKey) {</span>
 404 |     | <span class='neutral'>        privateKey = uint256(keccak256(abi.encodePacked(name)));</span>
 405 |     | <span class='neutral'>        addr = vm.addr(privateKey);</span>
 406 |     | <span class='neutral'>        vm.label(addr, name);</span>
 407 |     | <span class='neutral'>    }</span>
 408 |     | <span class='neutral'></span>
 409 |     | <span class='neutral'>    // creates a labeled address</span>
 410 |     | <span class='neutral'>    function makeAddr(string memory name) internal virtual returns (address addr) {</span>
 411 |     | <span class='neutral'>        (addr,) = makeAddrAndKey(name);</span>
 412 |     | <span class='neutral'>    }</span>
 413 |     | <span class='neutral'></span>
 414 |     | <span class='neutral'>    function deriveRememberKey(string memory mnemonic, uint32 index)</span>
 415 |     | <span class='neutral'>        internal</span>
 416 |     | <span class='neutral'>        virtual</span>
 417 |     | <span class='neutral'>        returns (address who, uint256 privateKey)</span>
 418 |     | <span class='neutral'>    {</span>
 419 |     | <span class='neutral'>        privateKey = vm.deriveKey(mnemonic, index);</span>
 420 |     | <span class='neutral'>        who = vm.rememberKey(privateKey);</span>
 421 |     | <span class='neutral'>    }</span>
 422 |     | <span class='neutral'></span>
 423 |     | <span class='neutral'>    function _bytesToUint(bytes memory b) private pure returns (uint256) {</span>
 424 |     | <span class='neutral'>        require(b.length &lt;= 32, &quot;StdCheats _bytesToUint(bytes): Bytes length exceeds 32.&quot;);</span>
 425 |     | <span class='neutral'>        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));</span>
 426 |     | <span class='neutral'>    }</span>
 427 |     | <span class='neutral'></span>
 428 |     | <span class='neutral'>    function isFork() internal view virtual returns (bool status) {</span>
 429 |     | <span class='neutral'>        try vm.activeFork() {</span>
 430 |     | <span class='neutral'>            status = true;</span>
 431 |     | <span class='neutral'>        } catch (bytes memory) {}</span>
 432 |     | <span class='neutral'>    }</span>
 433 |     | <span class='neutral'></span>
 434 |     | <span class='neutral'>    modifier skipWhenForking() {</span>
 435 |     | <span class='neutral'>        if (!isFork()) {</span>
 436 |     | <span class='neutral'>            _;</span>
 437 |     | <span class='neutral'>        }</span>
 438 |     | <span class='neutral'>    }</span>
 439 |     | <span class='neutral'></span>
 440 |     | <span class='neutral'>    modifier skipWhenNotForking() {</span>
 441 |     | <span class='neutral'>        if (isFork()) {</span>
 442 |     | <span class='neutral'>            _;</span>
 443 |     | <span class='neutral'>        }</span>
 444 |     | <span class='neutral'>    }</span>
 445 |     | <span class='neutral'></span>
 446 |     | <span class='neutral'>    modifier noGasMetering() {</span>
 447 |     | <span class='neutral'>        vm.pauseGasMetering();</span>
 448 |     | <span class='neutral'>        // To prevent turning gas monitoring back on with nested functions that use this modifier,</span>
 449 |     | <span class='neutral'>        // we check if gasMetering started in the off position. If it did, we don&#39;t want to turn</span>
 450 |     | <span class='neutral'>        // it back on until we exit the top level function that used the modifier</span>
 451 |     | <span class='neutral'>        //</span>
 452 |     | <span class='neutral'>        // i.e. funcA() noGasMetering { funcB() }, where funcB has noGasMetering as well.</span>
 453 |     | <span class='neutral'>        // funcA will have `gasStartedOff` as false, funcB will have it as true,</span>
 454 |     | <span class='neutral'>        // so we only turn metering back on at the end of the funcA</span>
 455 |     | <span class='neutral'>        bool gasStartedOff = gasMeteringOff;</span>
 456 |     | <span class='neutral'>        gasMeteringOff = true;</span>
 457 |     | <span class='neutral'></span>
 458 |     | <span class='neutral'>        _;</span>
 459 |     | <span class='neutral'></span>
 460 |     | <span class='neutral'>        // if gas metering was on when this modifier was called, turn it back on at the end</span>
 461 |     | <span class='neutral'>        if (!gasStartedOff) {</span>
 462 |     | <span class='neutral'>            gasMeteringOff = false;</span>
 463 |     | <span class='neutral'>            vm.resumeGasMetering();</span>
 464 |     | <span class='neutral'>        }</span>
 465 |     | <span class='neutral'>    }</span>
 466 |     | <span class='neutral'></span>
 467 |     | <span class='neutral'>    // a cheat for fuzzing addresses that are payable only</span>
 468 |     | <span class='neutral'>    // see https://github.com/foundry-rs/foundry/issues/3631</span>
 469 |     | <span class='neutral'>    function assumePayable(address addr) internal virtual {</span>
 470 |     | <span class='neutral'>        (bool success,) = payable(addr).call{value: 0}(&quot;&quot;);</span>
 471 |     | <span class='neutral'>        vm.assume(success);</span>
 472 |     | <span class='neutral'>    }</span>
 473 |     | <span class='neutral'>}</span>
 474 |     | <span class='neutral'></span>
 475 |     | <span class='neutral'>// Wrappers around cheatcodes to avoid footguns</span>
 476 |     | <span class='neutral'>abstract contract StdCheats is StdCheatsSafe {</span>
 477 |     | <span class='neutral'>    using stdStorage for StdStorage;</span>
 478 |     | <span class='neutral'></span>
 479 |     | <span class='neutral'>    StdStorage private stdstore;</span>
 480 |     | <span class='neutral'>    Vm private constant vm = Vm(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
 481 |     | <span class='neutral'></span>
 482 |     | <span class='neutral'>    // Skip forward or rewind time by the specified number of seconds</span>
 483 |     | <span class='neutral'>    function skip(uint256 time) internal virtual {</span>
 484 |     | <span class='neutral'>        vm.warp(block.timestamp + time);</span>
 485 |     | <span class='neutral'>    }</span>
 486 |     | <span class='neutral'></span>
 487 |     | <span class='neutral'>    function rewind(uint256 time) internal virtual {</span>
 488 |     | <span class='neutral'>        vm.warp(block.timestamp - time);</span>
 489 |     | <span class='neutral'>    }</span>
 490 |     | <span class='neutral'></span>
 491 |     | <span class='neutral'>    // Setup a prank from an address that has some ether</span>
 492 |     | <span class='neutral'>    function hoax(address msgSender) internal virtual {</span>
 493 |     | <span class='neutral'>        vm.deal(msgSender, 1 &lt;&lt; 128);</span>
 494 |     | <span class='neutral'>        vm.prank(msgSender);</span>
 495 |     | <span class='neutral'>    }</span>
 496 |     | <span class='neutral'></span>
 497 |     | <span class='neutral'>    function hoax(address msgSender, uint256 give) internal virtual {</span>
 498 |     | <span class='neutral'>        vm.deal(msgSender, give);</span>
 499 |     | <span class='neutral'>        vm.prank(msgSender);</span>
 500 |     | <span class='neutral'>    }</span>
 501 |     | <span class='neutral'></span>
 502 |     | <span class='neutral'>    function hoax(address msgSender, address origin) internal virtual {</span>
 503 |     | <span class='neutral'>        vm.deal(msgSender, 1 &lt;&lt; 128);</span>
 504 |     | <span class='neutral'>        vm.prank(msgSender, origin);</span>
 505 |     | <span class='neutral'>    }</span>
 506 |     | <span class='neutral'></span>
 507 |     | <span class='neutral'>    function hoax(address msgSender, address origin, uint256 give) internal virtual {</span>
 508 |     | <span class='neutral'>        vm.deal(msgSender, give);</span>
 509 |     | <span class='neutral'>        vm.prank(msgSender, origin);</span>
 510 |     | <span class='neutral'>    }</span>
 511 |     | <span class='neutral'></span>
 512 |     | <span class='neutral'>    // Start perpetual prank from an address that has some ether</span>
 513 |     | <span class='neutral'>    function startHoax(address msgSender) internal virtual {</span>
 514 |     | <span class='neutral'>        vm.deal(msgSender, 1 &lt;&lt; 128);</span>
 515 |     | <span class='neutral'>        vm.startPrank(msgSender);</span>
 516 |     | <span class='neutral'>    }</span>
 517 |     | <span class='neutral'></span>
 518 |     | <span class='neutral'>    function startHoax(address msgSender, uint256 give) internal virtual {</span>
 519 |     | <span class='neutral'>        vm.deal(msgSender, give);</span>
 520 |     | <span class='neutral'>        vm.startPrank(msgSender);</span>
 521 |     | <span class='neutral'>    }</span>
 522 |     | <span class='neutral'></span>
 523 |     | <span class='neutral'>    // Start perpetual prank from an address that has some ether</span>
 524 |     | <span class='neutral'>    // tx.origin is set to the origin parameter</span>
 525 |     | <span class='neutral'>    function startHoax(address msgSender, address origin) internal virtual {</span>
 526 |     | <span class='neutral'>        vm.deal(msgSender, 1 &lt;&lt; 128);</span>
 527 |     | <span class='neutral'>        vm.startPrank(msgSender, origin);</span>
 528 |     | <span class='neutral'>    }</span>
 529 |     | <span class='neutral'></span>
 530 |     | <span class='neutral'>    function startHoax(address msgSender, address origin, uint256 give) internal virtual {</span>
 531 |     | <span class='neutral'>        vm.deal(msgSender, give);</span>
 532 |     | <span class='neutral'>        vm.startPrank(msgSender, origin);</span>
 533 |     | <span class='neutral'>    }</span>
 534 |     | <span class='neutral'></span>
 535 |     | <span class='neutral'>    function changePrank(address msgSender) internal virtual {</span>
 536 |     | <span class='neutral'>        vm.stopPrank();</span>
 537 |     | <span class='neutral'>        vm.startPrank(msgSender);</span>
 538 |     | <span class='neutral'>    }</span>
 539 |     | <span class='neutral'></span>
 540 |     | <span class='neutral'>    // The same as Vm&#39;s `deal`</span>
 541 |     | <span class='neutral'>    // Use the alternative signature for ERC20 tokens</span>
 542 |     | <span class='neutral'>    function deal(address to, uint256 give) internal virtual {</span>
 543 |     | <span class='neutral'>        vm.deal(to, give);</span>
 544 |     | <span class='neutral'>    }</span>
 545 |     | <span class='neutral'></span>
 546 |     | <span class='neutral'>    // Set the balance of an account for any ERC20 token</span>
 547 |     | <span class='neutral'>    // Use the alternative signature to update `totalSupply`</span>
 548 |     | <span class='neutral'>    function deal(address token, address to, uint256 give) internal virtual {</span>
 549 |     | <span class='neutral'>        deal(token, to, give, false);</span>
 550 |     | <span class='neutral'>    }</span>
 551 |     | <span class='neutral'></span>
 552 |     | <span class='neutral'>    // Set the balance of an account for any ERC1155 token</span>
 553 |     | <span class='neutral'>    // Use the alternative signature to update `totalSupply`</span>
 554 |     | <span class='neutral'>    function dealERC1155(address token, address to, uint256 id, uint256 give) internal virtual {</span>
 555 |     | <span class='neutral'>        dealERC1155(token, to, id, give, false);</span>
 556 |     | <span class='neutral'>    }</span>
 557 |     | <span class='neutral'></span>
 558 |     | <span class='neutral'>    function deal(address token, address to, uint256 give, bool adjust) internal virtual {</span>
 559 |     | <span class='neutral'>        // get current balance</span>
 560 |     | <span class='neutral'>        (, bytes memory balData) = token.call(abi.encodeWithSelector(0x70a08231, to));</span>
 561 |     | <span class='neutral'>        uint256 prevBal = abi.decode(balData, (uint256));</span>
 562 |     | <span class='neutral'></span>
 563 |     | <span class='neutral'>        // update balance</span>
 564 |     | <span class='neutral'>        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(give);</span>
 565 |     | <span class='neutral'></span>
 566 |     | <span class='neutral'>        // update total supply</span>
 567 |     | <span class='neutral'>        if (adjust) {</span>
 568 |     | <span class='neutral'>            (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0x18160ddd));</span>
 569 |     | <span class='neutral'>            uint256 totSup = abi.decode(totSupData, (uint256));</span>
 570 |     | <span class='neutral'>            if (give &lt; prevBal) {</span>
 571 |     | <span class='neutral'>                totSup -= (prevBal - give);</span>
 572 |     | <span class='neutral'>            } else {</span>
 573 |     | <span class='neutral'>                totSup += (give - prevBal);</span>
 574 |     | <span class='neutral'>            }</span>
 575 |     | <span class='neutral'>            stdstore.target(token).sig(0x18160ddd).checked_write(totSup);</span>
 576 |     | <span class='neutral'>        }</span>
 577 |     | <span class='neutral'>    }</span>
 578 |     | <span class='neutral'></span>
 579 |     | <span class='neutral'>    function dealERC1155(address token, address to, uint256 id, uint256 give, bool adjust) internal virtual {</span>
 580 |     | <span class='neutral'>        // get current balance</span>
 581 |     | <span class='neutral'>        (, bytes memory balData) = token.call(abi.encodeWithSelector(0x00fdd58e, to, id));</span>
 582 |     | <span class='neutral'>        uint256 prevBal = abi.decode(balData, (uint256));</span>
 583 |     | <span class='neutral'></span>
 584 |     | <span class='neutral'>        // update balance</span>
 585 |     | <span class='neutral'>        stdstore.target(token).sig(0x00fdd58e).with_key(to).with_key(id).checked_write(give);</span>
 586 |     | <span class='neutral'></span>
 587 |     | <span class='neutral'>        // update total supply</span>
 588 |     | <span class='neutral'>        if (adjust) {</span>
 589 |     | <span class='neutral'>            (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0xbd85b039, id));</span>
 590 |     | <span class='neutral'>            require(</span>
 591 |     | <span class='neutral'>                totSupData.length != 0,</span>
 592 |     | <span class='neutral'>                &quot;StdCheats deal(address,address,uint,uint,bool): target contract is not ERC1155Supply.&quot;</span>
 593 |     | <span class='neutral'>            );</span>
 594 |     | <span class='neutral'>            uint256 totSup = abi.decode(totSupData, (uint256));</span>
 595 |     | <span class='neutral'>            if (give &lt; prevBal) {</span>
 596 |     | <span class='neutral'>                totSup -= (prevBal - give);</span>
 597 |     | <span class='neutral'>            } else {</span>
 598 |     | <span class='neutral'>                totSup += (give - prevBal);</span>
 599 |     | <span class='neutral'>            }</span>
 600 |     | <span class='neutral'>            stdstore.target(token).sig(0xbd85b039).with_key(id).checked_write(totSup);</span>
 601 |     | <span class='neutral'>        }</span>
 602 |     | <span class='neutral'>    }</span>
 603 |     | <span class='neutral'></span>
 604 |     | <span class='neutral'>    function dealERC721(address token, address to, uint256 id) internal virtual {</span>
 605 |     | <span class='neutral'>        // check if token id is already minted and the actual owner.</span>
 606 |     | <span class='neutral'>        (bool successMinted, bytes memory ownerData) = token.staticcall(abi.encodeWithSelector(0x6352211e, id));</span>
 607 |     | <span class='neutral'>        require(successMinted, &quot;StdCheats deal(address,address,uint,bool): id not minted.&quot;);</span>
 608 |     | <span class='neutral'></span>
 609 |     | <span class='neutral'>        // get owner current balance</span>
 610 |     | <span class='neutral'>        (, bytes memory fromBalData) = token.call(abi.encodeWithSelector(0x70a08231, abi.decode(ownerData, (address))));</span>
 611 |     | <span class='neutral'>        uint256 fromPrevBal = abi.decode(fromBalData, (uint256));</span>
 612 |     | <span class='neutral'></span>
 613 |     | <span class='neutral'>        // get new user current balance</span>
 614 |     | <span class='neutral'>        (, bytes memory toBalData) = token.call(abi.encodeWithSelector(0x70a08231, to));</span>
 615 |     | <span class='neutral'>        uint256 toPrevBal = abi.decode(toBalData, (uint256));</span>
 616 |     | <span class='neutral'></span>
 617 |     | <span class='neutral'>        // update balances</span>
 618 |     | <span class='neutral'>        stdstore.target(token).sig(0x70a08231).with_key(abi.decode(ownerData, (address))).checked_write(--fromPrevBal);</span>
 619 |     | <span class='neutral'>        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(++toPrevBal);</span>
 620 |     | <span class='neutral'></span>
 621 |     | <span class='neutral'>        // update owner</span>
 622 |     | <span class='neutral'>        stdstore.target(token).sig(0x6352211e).with_key(id).checked_write(to);</span>
 623 |     | <span class='neutral'>    }</span>
 624 |     | <span class='neutral'>}</span>
 625 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/forge-std/src/StdError.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// Panics work for versions &gt;=0.8.0, but we lowered the pragma to make this compatible with Test</span>
  3 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  4 |     | <span class='unexecuted'></span>
  5 |     | <span class='neutral'>library stdError {</span>
  6 |     | <span class='unexecuted'>    bytes public constant assertionError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x01);</span>
  7 |     | <span class='unexecuted'>    bytes public constant arithmeticError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x11);</span>
  8 |     | <span class='unexecuted'>    bytes public constant divisionError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x12);</span>
  9 |     | <span class='unexecuted'>    bytes public constant enumConversionError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x21);</span>
 10 |     | <span class='unexecuted'>    bytes public constant encodeStorageError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x22);</span>
 11 |     | <span class='unexecuted'>    bytes public constant popError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x31);</span>
 12 |     | <span class='unexecuted'>    bytes public constant indexOOBError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x32);</span>
 13 |     | <span class='unexecuted'>    bytes public constant memOverflowError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x41);</span>
 14 |     | <span class='unexecuted'>    bytes public constant zeroVarError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x51);</span>
 15 |     | <span class='neutral'>}</span>
 16 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/forge-std/src/StdInvariant.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
  5 |     | <span class='unexecuted'></span>
  6 |     | <span class='neutral'>contract StdInvariant {</span>
  7 |     | <span class='neutral'>    struct FuzzSelector {</span>
  8 |     | <span class='neutral'>        address addr;</span>
  9 |     | <span class='neutral'>        bytes4[] selectors;</span>
 10 |     | <span class='neutral'>    }</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    address[] private _excludedContracts;</span>
 13 |     | <span class='neutral'>    address[] private _excludedSenders;</span>
 14 |     | <span class='neutral'>    address[] private _targetedContracts;</span>
 15 |     | <span class='neutral'>    address[] private _targetedSenders;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    string[] private _excludedArtifacts;</span>
 18 |     | <span class='neutral'>    string[] private _targetedArtifacts;</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    FuzzSelector[] private _targetedArtifactSelectors;</span>
 21 |     | <span class='neutral'>    FuzzSelector[] private _targetedSelectors;</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    // Functions for users:</span>
 24 |     | <span class='neutral'>    // These are intended to be called in tests.</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    function excludeContract(address newExcludedContract_) internal {</span>
 27 |     | <span class='neutral'>        _excludedContracts.push(newExcludedContract_);</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    function excludeSender(address newExcludedSender_) internal {</span>
 31 |     | <span class='neutral'>        _excludedSenders.push(newExcludedSender_);</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    function excludeArtifact(string memory newExcludedArtifact_) internal {</span>
 35 |     | <span class='neutral'>        _excludedArtifacts.push(newExcludedArtifact_);</span>
 36 |     | <span class='neutral'>    }</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='neutral'>    function targetArtifact(string memory newTargetedArtifact_) internal {</span>
 39 |     | <span class='neutral'>        _targetedArtifacts.push(newTargetedArtifact_);</span>
 40 |     | <span class='neutral'>    }</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>    function targetArtifactSelector(FuzzSelector memory newTargetedArtifactSelector_) internal {</span>
 43 |     | <span class='neutral'>        _targetedArtifactSelectors.push(newTargetedArtifactSelector_);</span>
 44 |     | <span class='neutral'>    }</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    function targetContract(address newTargetedContract_) internal {</span>
 47 |     | <span class='neutral'>        _targetedContracts.push(newTargetedContract_);</span>
 48 |     | <span class='neutral'>    }</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    function targetSelector(FuzzSelector memory newTargetedSelector_) internal {</span>
 51 |     | <span class='neutral'>        _targetedSelectors.push(newTargetedSelector_);</span>
 52 |     | <span class='neutral'>    }</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>    function targetSender(address newTargetedSender_) internal {</span>
 55 |     | <span class='neutral'>        _targetedSenders.push(newTargetedSender_);</span>
 56 |     | <span class='neutral'>    }</span>
 57 |     | <span class='neutral'></span>
 58 |     | <span class='neutral'>    // Functions for forge:</span>
 59 |     | <span class='neutral'>    // These are called by forge to run invariant tests and don&#39;t need to be called in tests.</span>
 60 |     | <span class='neutral'></span>
 61 |     | <span class='unexecuted'>    function excludeArtifacts() public view returns (string[] memory excludedArtifacts_) {</span>
 62 |     | <span class='unexecuted'>        excludedArtifacts_ = _excludedArtifacts;</span>
 63 |     | <span class='neutral'>    }</span>
 64 |     | <span class='neutral'></span>
 65 |     | <span class='unexecuted'>    function excludeContracts() public view returns (address[] memory excludedContracts_) {</span>
 66 |     | <span class='unexecuted'>        excludedContracts_ = _excludedContracts;</span>
 67 |     | <span class='neutral'>    }</span>
 68 |     | <span class='neutral'></span>
 69 |     | <span class='unexecuted'>    function excludeSenders() public view returns (address[] memory excludedSenders_) {</span>
 70 |     | <span class='unexecuted'>        excludedSenders_ = _excludedSenders;</span>
 71 |     | <span class='neutral'>    }</span>
 72 |     | <span class='neutral'></span>
 73 |     | <span class='unexecuted'>    function targetArtifacts() public view returns (string[] memory targetedArtifacts_) {</span>
 74 |     | <span class='unexecuted'>        targetedArtifacts_ = _targetedArtifacts;</span>
 75 |     | <span class='neutral'>    }</span>
 76 |     | <span class='neutral'></span>
 77 |     | <span class='unexecuted'>    function targetArtifactSelectors() public view returns (FuzzSelector[] memory targetedArtifactSelectors_) {</span>
 78 |     | <span class='unexecuted'>        targetedArtifactSelectors_ = _targetedArtifactSelectors;</span>
 79 |     | <span class='neutral'>    }</span>
 80 |     | <span class='neutral'></span>
 81 |     | <span class='unexecuted'>    function targetContracts() public view returns (address[] memory targetedContracts_) {</span>
 82 |     | <span class='unexecuted'>        targetedContracts_ = _targetedContracts;</span>
 83 |     | <span class='neutral'>    }</span>
 84 |     | <span class='neutral'></span>
 85 |     | <span class='unexecuted'>    function targetSelectors() public view returns (FuzzSelector[] memory targetedSelectors_) {</span>
 86 |     | <span class='unexecuted'>        targetedSelectors_ = _targetedSelectors;</span>
 87 |     | <span class='neutral'>    }</span>
 88 |     | <span class='neutral'></span>
 89 |     | <span class='unexecuted'>    function targetSenders() public view returns (address[] memory targetedSenders_) {</span>
 90 |     | <span class='unexecuted'>        targetedSenders_ = _targetedSenders;</span>
 91 |     | <span class='neutral'>    }</span>
 92 |     | <span class='neutral'>}</span>
 93 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/forge-std/src/StdJson.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.0 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {VmSafe} from &quot;./Vm.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>// Helpers for parsing and writing JSON files</span>
   9 |     | <span class='neutral'>// To parse:</span>
  10 |     | <span class='neutral'>// ```</span>
  11 |     | <span class='neutral'>// using stdJson for string;</span>
  12 |     | <span class='neutral'>// string memory json = vm.readFile(&quot;some_peth&quot;);</span>
  13 |     | <span class='neutral'>// json.parseUint(&quot;&lt;json_path&gt;&quot;);</span>
  14 |     | <span class='neutral'>// ```</span>
  15 |     | <span class='neutral'>// To write:</span>
  16 |     | <span class='neutral'>// ```</span>
  17 |     | <span class='neutral'>// using stdJson for string;</span>
  18 |     | <span class='neutral'>// string memory json = &quot;deploymentArtifact&quot;;</span>
  19 |     | <span class='neutral'>// Contract contract = new Contract();</span>
  20 |     | <span class='neutral'>// json.serialize(&quot;contractAddress&quot;, address(contract));</span>
  21 |     | <span class='neutral'>// json = json.serialize(&quot;deploymentTimes&quot;, uint(1));</span>
  22 |     | <span class='neutral'>// // store the stringified JSON to the &#39;json&#39; variable we have been using as a key</span>
  23 |     | <span class='neutral'>// // as we won&#39;t need it any longer</span>
  24 |     | <span class='neutral'>// string memory json2 = &quot;finalArtifact&quot;;</span>
  25 |     | <span class='neutral'>// string memory final = json2.serialize(&quot;depArtifact&quot;, json);</span>
  26 |     | <span class='neutral'>// final.write(&quot;&lt;some_path&gt;&quot;);</span>
  27 |     | <span class='neutral'>// ```</span>
  28 |     | <span class='unexecuted'></span>
  29 |     | <span class='neutral'>library stdJson {</span>
  30 |     | <span class='neutral'>    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {</span>
  33 |     | <span class='neutral'>        return vm.parseJson(json, key);</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    function readUint(string memory json, string memory key) internal returns (uint256) {</span>
  37 |     | <span class='neutral'>        return vm.parseJsonUint(json, key);</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    function readUintArray(string memory json, string memory key) internal returns (uint256[] memory) {</span>
  41 |     | <span class='neutral'>        return vm.parseJsonUintArray(json, key);</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    function readInt(string memory json, string memory key) internal returns (int256) {</span>
  45 |     | <span class='neutral'>        return vm.parseJsonInt(json, key);</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    function readIntArray(string memory json, string memory key) internal returns (int256[] memory) {</span>
  49 |     | <span class='neutral'>        return vm.parseJsonIntArray(json, key);</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    function readBytes32(string memory json, string memory key) internal returns (bytes32) {</span>
  53 |     | <span class='neutral'>        return vm.parseJsonBytes32(json, key);</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    function readBytes32Array(string memory json, string memory key) internal returns (bytes32[] memory) {</span>
  57 |     | <span class='neutral'>        return vm.parseJsonBytes32Array(json, key);</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    function readString(string memory json, string memory key) internal returns (string memory) {</span>
  61 |     | <span class='neutral'>        return vm.parseJsonString(json, key);</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    function readStringArray(string memory json, string memory key) internal returns (string[] memory) {</span>
  65 |     | <span class='neutral'>        return vm.parseJsonStringArray(json, key);</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    function readAddress(string memory json, string memory key) internal returns (address) {</span>
  69 |     | <span class='neutral'>        return vm.parseJsonAddress(json, key);</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    function readAddressArray(string memory json, string memory key) internal returns (address[] memory) {</span>
  73 |     | <span class='neutral'>        return vm.parseJsonAddressArray(json, key);</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    function readBool(string memory json, string memory key) internal returns (bool) {</span>
  77 |     | <span class='neutral'>        return vm.parseJsonBool(json, key);</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    function readBoolArray(string memory json, string memory key) internal returns (bool[] memory) {</span>
  81 |     | <span class='neutral'>        return vm.parseJsonBoolArray(json, key);</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    function readBytes(string memory json, string memory key) internal returns (bytes memory) {</span>
  85 |     | <span class='neutral'>        return vm.parseJsonBytes(json, key);</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    function readBytesArray(string memory json, string memory key) internal returns (bytes[] memory) {</span>
  89 |     | <span class='neutral'>        return vm.parseJsonBytesArray(json, key);</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {</span>
  93 |     | <span class='neutral'>        return vm.serializeBool(jsonKey, key, value);</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bool[] memory value)</span>
  97 |     | <span class='neutral'>        internal</span>
  98 |     | <span class='neutral'>        returns (string memory)</span>
  99 |     | <span class='neutral'>    {</span>
 100 |     | <span class='neutral'>        return vm.serializeBool(jsonKey, key, value);</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {</span>
 104 |     | <span class='neutral'>        return vm.serializeUint(jsonKey, key, value);</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, uint256[] memory value)</span>
 108 |     | <span class='neutral'>        internal</span>
 109 |     | <span class='neutral'>        returns (string memory)</span>
 110 |     | <span class='neutral'>    {</span>
 111 |     | <span class='neutral'>        return vm.serializeUint(jsonKey, key, value);</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {</span>
 115 |     | <span class='neutral'>        return vm.serializeInt(jsonKey, key, value);</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, int256[] memory value)</span>
 119 |     | <span class='neutral'>        internal</span>
 120 |     | <span class='neutral'>        returns (string memory)</span>
 121 |     | <span class='neutral'>    {</span>
 122 |     | <span class='neutral'>        return vm.serializeInt(jsonKey, key, value);</span>
 123 |     | <span class='neutral'>    }</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {</span>
 126 |     | <span class='neutral'>        return vm.serializeAddress(jsonKey, key, value);</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, address[] memory value)</span>
 130 |     | <span class='neutral'>        internal</span>
 131 |     | <span class='neutral'>        returns (string memory)</span>
 132 |     | <span class='neutral'>    {</span>
 133 |     | <span class='neutral'>        return vm.serializeAddress(jsonKey, key, value);</span>
 134 |     | <span class='neutral'>    }</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {</span>
 137 |     | <span class='neutral'>        return vm.serializeBytes32(jsonKey, key, value);</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes32[] memory value)</span>
 141 |     | <span class='neutral'>        internal</span>
 142 |     | <span class='neutral'>        returns (string memory)</span>
 143 |     | <span class='neutral'>    {</span>
 144 |     | <span class='neutral'>        return vm.serializeBytes32(jsonKey, key, value);</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {</span>
 148 |     | <span class='neutral'>        return vm.serializeBytes(jsonKey, key, value);</span>
 149 |     | <span class='neutral'>    }</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes[] memory value)</span>
 152 |     | <span class='neutral'>        internal</span>
 153 |     | <span class='neutral'>        returns (string memory)</span>
 154 |     | <span class='neutral'>    {</span>
 155 |     | <span class='neutral'>        return vm.serializeBytes(jsonKey, key, value);</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, string memory value)</span>
 159 |     | <span class='neutral'>        internal</span>
 160 |     | <span class='neutral'>        returns (string memory)</span>
 161 |     | <span class='neutral'>    {</span>
 162 |     | <span class='neutral'>        return vm.serializeString(jsonKey, key, value);</span>
 163 |     | <span class='neutral'>    }</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, string[] memory value)</span>
 166 |     | <span class='neutral'>        internal</span>
 167 |     | <span class='neutral'>        returns (string memory)</span>
 168 |     | <span class='neutral'>    {</span>
 169 |     | <span class='neutral'>        return vm.serializeString(jsonKey, key, value);</span>
 170 |     | <span class='neutral'>    }</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='neutral'>    function write(string memory jsonKey, string memory path) internal {</span>
 173 |     | <span class='neutral'>        vm.writeJson(jsonKey, path);</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    function write(string memory jsonKey, string memory path, string memory valueKey) internal {</span>
 177 |     | <span class='neutral'>        vm.writeJson(jsonKey, path, valueKey);</span>
 178 |     | <span class='neutral'>    }</span>
 179 |     | <span class='neutral'>}</span>
 180 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/forge-std/src/StdMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  3 |     | <span class='unexecuted'></span>
  4 |     | <span class='neutral'>library stdMath {</span>
  5 |     | <span class='neutral'>    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function abs(int256 a) internal pure returns (uint256) {</span>
  8 |     | <span class='neutral'>        // Required or it will fail when `a = type(int256).min`</span>
  9 |     | <span class='neutral'>        if (a == INT256_MIN) {</span>
 10 |     | <span class='neutral'>            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span>
 11 |     | <span class='neutral'>        }</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>        return uint256(a &gt; 0 ? a : -a);</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    function delta(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 17 |     | <span class='neutral'>        return a &gt; b ? a - b : b - a;</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    function delta(int256 a, int256 b) internal pure returns (uint256) {</span>
 21 |     | <span class='neutral'>        // a and b are of the same sign</span>
 22 |     | <span class='neutral'>        // this works thanks to two&#39;s complement, the left-most bit is the sign bit</span>
 23 |     | <span class='neutral'>        if ((a ^ b) &gt; -1) {</span>
 24 |     | <span class='neutral'>            return delta(abs(a), abs(b));</span>
 25 |     | <span class='neutral'>        }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>        // a and b are of opposite signs</span>
 28 |     | <span class='neutral'>        return abs(a) + abs(b);</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 32 |     | <span class='neutral'>        uint256 absDelta = delta(a, b);</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>        return absDelta * 1e18 / b;</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {</span>
 38 |     | <span class='neutral'>        uint256 absDelta = delta(a, b);</span>
 39 |     | <span class='neutral'>        uint256 absB = abs(b);</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>        return absDelta * 1e18 / absB;</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'>}</span>
 44 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/forge-std/src/StdStorage.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {Vm} from &quot;./Vm.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>struct StdStorage {</span>
   7 |     | <span class='neutral'>    mapping(address =&gt; mapping(bytes4 =&gt; mapping(bytes32 =&gt; uint256))) slots;</span>
   8 |     | <span class='neutral'>    mapping(address =&gt; mapping(bytes4 =&gt; mapping(bytes32 =&gt; bool))) finds;</span>
   9 |     | <span class='neutral'>    bytes32[] _keys;</span>
  10 |     | <span class='neutral'>    bytes4 _sig;</span>
  11 |     | <span class='neutral'>    uint256 _depth;</span>
  12 |     | <span class='neutral'>    address _target;</span>
  13 |     | <span class='neutral'>    bytes32 _set;</span>
  14 |     | <span class='neutral'>}</span>
  15 |     | <span class='unexecuted'></span>
  16 |     | <span class='neutral'>library stdStorageSafe {</span>
  17 |     | <span class='neutral'>    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);</span>
  18 |     | <span class='neutral'>    event WARNING_UninitedSlot(address who, uint256 slot);</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    Vm private constant vm = Vm(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    function sigs(string memory sigStr) internal pure returns (bytes4) {</span>
  23 |     | <span class='neutral'>        return bytes4(keccak256(bytes(sigStr)));</span>
  24 |     | <span class='neutral'>    }</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against</span>
  27 |     | <span class='neutral'>    // slot complexity:</span>
  28 |     | <span class='neutral'>    //  if flat, will be bytes32(uint256(uint));</span>
  29 |     | <span class='neutral'>    //  if map, will be keccak256(abi.encode(key, uint(slot)));</span>
  30 |     | <span class='neutral'>    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));</span>
  31 |     | <span class='neutral'>    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);</span>
  32 |     | <span class='neutral'>    function find(StdStorage storage self) internal returns (uint256) {</span>
  33 |     | <span class='neutral'>        address who = self._target;</span>
  34 |     | <span class='neutral'>        bytes4 fsig = self._sig;</span>
  35 |     | <span class='neutral'>        uint256 field_depth = self._depth;</span>
  36 |     | <span class='neutral'>        bytes32[] memory ins = self._keys;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>        // calldata to test against</span>
  39 |     | <span class='neutral'>        if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {</span>
  40 |     | <span class='neutral'>            return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];</span>
  41 |     | <span class='neutral'>        }</span>
  42 |     | <span class='neutral'>        bytes memory cald = abi.encodePacked(fsig, flatten(ins));</span>
  43 |     | <span class='neutral'>        vm.record();</span>
  44 |     | <span class='neutral'>        bytes32 fdat;</span>
  45 |     | <span class='neutral'>        {</span>
  46 |     | <span class='neutral'>            (, bytes memory rdat) = who.staticcall(cald);</span>
  47 |     | <span class='neutral'>            fdat = bytesToBytes32(rdat, 32 * field_depth);</span>
  48 |     | <span class='neutral'>        }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>        (bytes32[] memory reads,) = vm.accesses(address(who));</span>
  51 |     | <span class='neutral'>        if (reads.length == 1) {</span>
  52 |     | <span class='neutral'>            bytes32 curr = vm.load(who, reads[0]);</span>
  53 |     | <span class='neutral'>            if (curr == bytes32(0)) {</span>
  54 |     | <span class='neutral'>                emit WARNING_UninitedSlot(who, uint256(reads[0]));</span>
  55 |     | <span class='neutral'>            }</span>
  56 |     | <span class='neutral'>            if (fdat != curr) {</span>
  57 |     | <span class='neutral'>                require(</span>
  58 |     | <span class='neutral'>                    false,</span>
  59 |     | <span class='neutral'>                    &quot;stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn&#39;t supported.&quot;</span>
  60 |     | <span class='neutral'>                );</span>
  61 |     | <span class='neutral'>            }</span>
  62 |     | <span class='neutral'>            emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));</span>
  63 |     | <span class='neutral'>            self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);</span>
  64 |     | <span class='neutral'>            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;</span>
  65 |     | <span class='neutral'>        } else if (reads.length &gt; 1) {</span>
  66 |     | <span class='neutral'>            for (uint256 i = 0; i &lt; reads.length; i++) {</span>
  67 |     | <span class='neutral'>                bytes32 prev = vm.load(who, reads[i]);</span>
  68 |     | <span class='neutral'>                if (prev == bytes32(0)) {</span>
  69 |     | <span class='neutral'>                    emit WARNING_UninitedSlot(who, uint256(reads[i]));</span>
  70 |     | <span class='neutral'>                }</span>
  71 |     | <span class='neutral'>                // store</span>
  72 |     | <span class='neutral'>                vm.store(who, reads[i], bytes32(hex&quot;1337&quot;));</span>
  73 |     | <span class='neutral'>                bool success;</span>
  74 |     | <span class='neutral'>                bytes memory rdat;</span>
  75 |     | <span class='neutral'>                {</span>
  76 |     | <span class='neutral'>                    (success, rdat) = who.staticcall(cald);</span>
  77 |     | <span class='neutral'>                    fdat = bytesToBytes32(rdat, 32 * field_depth);</span>
  78 |     | <span class='neutral'>                }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>                if (success &amp;&amp; fdat == bytes32(hex&quot;1337&quot;)) {</span>
  81 |     | <span class='neutral'>                    // we found which of the slots is the actual one</span>
  82 |     | <span class='neutral'>                    emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));</span>
  83 |     | <span class='neutral'>                    self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);</span>
  84 |     | <span class='neutral'>                    self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;</span>
  85 |     | <span class='neutral'>                    vm.store(who, reads[i], prev);</span>
  86 |     | <span class='neutral'>                    break;</span>
  87 |     | <span class='neutral'>                }</span>
  88 |     | <span class='neutral'>                vm.store(who, reads[i], prev);</span>
  89 |     | <span class='neutral'>            }</span>
  90 |     | <span class='neutral'>        } else {</span>
  91 |     | <span class='neutral'>            revert(&quot;stdStorage find(StdStorage): No storage use detected for target.&quot;);</span>
  92 |     | <span class='neutral'>        }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>        require(</span>
  95 |     | <span class='neutral'>            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))],</span>
  96 |     | <span class='neutral'>            &quot;stdStorage find(StdStorage): Slot(s) not found.&quot;</span>
  97 |     | <span class='neutral'>        );</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>        delete self._target;</span>
 100 |     | <span class='neutral'>        delete self._sig;</span>
 101 |     | <span class='neutral'>        delete self._keys;</span>
 102 |     | <span class='neutral'>        delete self._depth;</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>        return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {</span>
 108 |     | <span class='neutral'>        self._target = _target;</span>
 109 |     | <span class='neutral'>        return self;</span>
 110 |     | <span class='neutral'>    }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {</span>
 113 |     | <span class='neutral'>        self._sig = _sig;</span>
 114 |     | <span class='neutral'>        return self;</span>
 115 |     | <span class='neutral'>    }</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {</span>
 118 |     | <span class='neutral'>        self._sig = sigs(_sig);</span>
 119 |     | <span class='neutral'>        return self;</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {</span>
 123 |     | <span class='neutral'>        self._keys.push(bytes32(uint256(uint160(who))));</span>
 124 |     | <span class='neutral'>        return self;</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {</span>
 128 |     | <span class='neutral'>        self._keys.push(bytes32(amt));</span>
 129 |     | <span class='neutral'>        return self;</span>
 130 |     | <span class='neutral'>    }</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {</span>
 133 |     | <span class='neutral'>        self._keys.push(key);</span>
 134 |     | <span class='neutral'>        return self;</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {</span>
 138 |     | <span class='neutral'>        self._depth = _depth;</span>
 139 |     | <span class='neutral'>        return self;</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    function read(StdStorage storage self) private returns (bytes memory) {</span>
 143 |     | <span class='neutral'>        address t = self._target;</span>
 144 |     | <span class='neutral'>        uint256 s = find(self);</span>
 145 |     | <span class='neutral'>        return abi.encode(vm.load(t, bytes32(s)));</span>
 146 |     | <span class='neutral'>    }</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>    function read_bytes32(StdStorage storage self) internal returns (bytes32) {</span>
 149 |     | <span class='neutral'>        return abi.decode(read(self), (bytes32));</span>
 150 |     | <span class='neutral'>    }</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>    function read_bool(StdStorage storage self) internal returns (bool) {</span>
 153 |     | <span class='neutral'>        int256 v = read_int(self);</span>
 154 |     | <span class='neutral'>        if (v == 0) return false;</span>
 155 |     | <span class='neutral'>        if (v == 1) return true;</span>
 156 |     | <span class='neutral'>        revert(&quot;stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.&quot;);</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>    function read_address(StdStorage storage self) internal returns (address) {</span>
 160 |     | <span class='neutral'>        return abi.decode(read(self), (address));</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>    function read_uint(StdStorage storage self) internal returns (uint256) {</span>
 164 |     | <span class='neutral'>        return abi.decode(read(self), (uint256));</span>
 165 |     | <span class='neutral'>    }</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    function read_int(StdStorage storage self) internal returns (int256) {</span>
 168 |     | <span class='neutral'>        return abi.decode(read(self), (int256));</span>
 169 |     | <span class='neutral'>    }</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='neutral'>    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {</span>
 172 |     | <span class='neutral'>        bytes32 out;</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>        uint256 max = b.length &gt; 32 ? 32 : b.length;</span>
 175 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; max; i++) {</span>
 176 |     | <span class='neutral'>            out |= bytes32(b[offset + i] &amp; 0xFF) &gt;&gt; (i * 8);</span>
 177 |     | <span class='neutral'>        }</span>
 178 |     | <span class='neutral'>        return out;</span>
 179 |     | <span class='neutral'>    }</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='neutral'>    function flatten(bytes32[] memory b) private pure returns (bytes memory) {</span>
 182 |     | <span class='neutral'>        bytes memory result = new bytes(b.length * 32);</span>
 183 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; b.length; i++) {</span>
 184 |     | <span class='neutral'>            bytes32 k = b[i];</span>
 185 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
 186 |     | <span class='neutral'>            assembly {</span>
 187 |     | <span class='neutral'>                mstore(add(result, add(32, mul(32, i))), k)</span>
 188 |     | <span class='neutral'>            }</span>
 189 |     | <span class='neutral'>        }</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>        return result;</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'>}</span>
 194 |     | <span class='unexecuted'></span>
 195 |     | <span class='neutral'>library stdStorage {</span>
 196 |     | <span class='neutral'>    Vm private constant vm = Vm(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='neutral'>    function sigs(string memory sigStr) internal pure returns (bytes4) {</span>
 199 |     | <span class='neutral'>        return stdStorageSafe.sigs(sigStr);</span>
 200 |     | <span class='neutral'>    }</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='neutral'>    function find(StdStorage storage self) internal returns (uint256) {</span>
 203 |     | <span class='neutral'>        return stdStorageSafe.find(self);</span>
 204 |     | <span class='neutral'>    }</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='neutral'>    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {</span>
 207 |     | <span class='neutral'>        return stdStorageSafe.target(self, _target);</span>
 208 |     | <span class='neutral'>    }</span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='neutral'>    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {</span>
 211 |     | <span class='neutral'>        return stdStorageSafe.sig(self, _sig);</span>
 212 |     | <span class='neutral'>    }</span>
 213 |     | <span class='neutral'></span>
 214 |     | <span class='neutral'>    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {</span>
 215 |     | <span class='neutral'>        return stdStorageSafe.sig(self, _sig);</span>
 216 |     | <span class='neutral'>    }</span>
 217 |     | <span class='neutral'></span>
 218 |     | <span class='neutral'>    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {</span>
 219 |     | <span class='neutral'>        return stdStorageSafe.with_key(self, who);</span>
 220 |     | <span class='neutral'>    }</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='neutral'>    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {</span>
 223 |     | <span class='neutral'>        return stdStorageSafe.with_key(self, amt);</span>
 224 |     | <span class='neutral'>    }</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='neutral'>    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {</span>
 227 |     | <span class='neutral'>        return stdStorageSafe.with_key(self, key);</span>
 228 |     | <span class='neutral'>    }</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='neutral'>    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {</span>
 231 |     | <span class='neutral'>        return stdStorageSafe.depth(self, _depth);</span>
 232 |     | <span class='neutral'>    }</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='neutral'>    function checked_write(StdStorage storage self, address who) internal {</span>
 235 |     | <span class='neutral'>        checked_write(self, bytes32(uint256(uint160(who))));</span>
 236 |     | <span class='neutral'>    }</span>
 237 |     | <span class='neutral'></span>
 238 |     | <span class='neutral'>    function checked_write(StdStorage storage self, uint256 amt) internal {</span>
 239 |     | <span class='neutral'>        checked_write(self, bytes32(amt));</span>
 240 |     | <span class='neutral'>    }</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='neutral'>    function checked_write(StdStorage storage self, bool write) internal {</span>
 243 |     | <span class='neutral'>        bytes32 t;</span>
 244 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 245 |     | <span class='neutral'>        assembly {</span>
 246 |     | <span class='neutral'>            t := write</span>
 247 |     | <span class='neutral'>        }</span>
 248 |     | <span class='neutral'>        checked_write(self, t);</span>
 249 |     | <span class='neutral'>    }</span>
 250 |     | <span class='neutral'></span>
 251 |     | <span class='neutral'>    function checked_write(StdStorage storage self, bytes32 set) internal {</span>
 252 |     | <span class='neutral'>        address who = self._target;</span>
 253 |     | <span class='neutral'>        bytes4 fsig = self._sig;</span>
 254 |     | <span class='neutral'>        uint256 field_depth = self._depth;</span>
 255 |     | <span class='neutral'>        bytes32[] memory ins = self._keys;</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='neutral'>        bytes memory cald = abi.encodePacked(fsig, flatten(ins));</span>
 258 |     | <span class='neutral'>        if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {</span>
 259 |     | <span class='neutral'>            find(self);</span>
 260 |     | <span class='neutral'>        }</span>
 261 |     | <span class='neutral'>        bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);</span>
 262 |     | <span class='neutral'></span>
 263 |     | <span class='neutral'>        bytes32 fdat;</span>
 264 |     | <span class='neutral'>        {</span>
 265 |     | <span class='neutral'>            (, bytes memory rdat) = who.staticcall(cald);</span>
 266 |     | <span class='neutral'>            fdat = bytesToBytes32(rdat, 32 * field_depth);</span>
 267 |     | <span class='neutral'>        }</span>
 268 |     | <span class='neutral'>        bytes32 curr = vm.load(who, slot);</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='neutral'>        if (fdat != curr) {</span>
 271 |     | <span class='neutral'>            require(</span>
 272 |     | <span class='neutral'>                false,</span>
 273 |     | <span class='neutral'>                &quot;stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn&#39;t supported.&quot;</span>
 274 |     | <span class='neutral'>            );</span>
 275 |     | <span class='neutral'>        }</span>
 276 |     | <span class='neutral'>        vm.store(who, slot, set);</span>
 277 |     | <span class='neutral'>        delete self._target;</span>
 278 |     | <span class='neutral'>        delete self._sig;</span>
 279 |     | <span class='neutral'>        delete self._keys;</span>
 280 |     | <span class='neutral'>        delete self._depth;</span>
 281 |     | <span class='neutral'>    }</span>
 282 |     | <span class='neutral'></span>
 283 |     | <span class='neutral'>    function read_bytes32(StdStorage storage self) internal returns (bytes32) {</span>
 284 |     | <span class='neutral'>        return stdStorageSafe.read_bytes32(self);</span>
 285 |     | <span class='neutral'>    }</span>
 286 |     | <span class='neutral'></span>
 287 |     | <span class='neutral'>    function read_bool(StdStorage storage self) internal returns (bool) {</span>
 288 |     | <span class='neutral'>        return stdStorageSafe.read_bool(self);</span>
 289 |     | <span class='neutral'>    }</span>
 290 |     | <span class='neutral'></span>
 291 |     | <span class='neutral'>    function read_address(StdStorage storage self) internal returns (address) {</span>
 292 |     | <span class='neutral'>        return stdStorageSafe.read_address(self);</span>
 293 |     | <span class='neutral'>    }</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='neutral'>    function read_uint(StdStorage storage self) internal returns (uint256) {</span>
 296 |     | <span class='neutral'>        return stdStorageSafe.read_uint(self);</span>
 297 |     | <span class='neutral'>    }</span>
 298 |     | <span class='neutral'></span>
 299 |     | <span class='neutral'>    function read_int(StdStorage storage self) internal returns (int256) {</span>
 300 |     | <span class='neutral'>        return stdStorageSafe.read_int(self);</span>
 301 |     | <span class='neutral'>    }</span>
 302 |     | <span class='neutral'></span>
 303 |     | <span class='neutral'>    // Private function so needs to be copied over</span>
 304 |     | <span class='neutral'>    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {</span>
 305 |     | <span class='neutral'>        bytes32 out;</span>
 306 |     | <span class='neutral'></span>
 307 |     | <span class='neutral'>        uint256 max = b.length &gt; 32 ? 32 : b.length;</span>
 308 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; max; i++) {</span>
 309 |     | <span class='neutral'>            out |= bytes32(b[offset + i] &amp; 0xFF) &gt;&gt; (i * 8);</span>
 310 |     | <span class='neutral'>        }</span>
 311 |     | <span class='neutral'>        return out;</span>
 312 |     | <span class='neutral'>    }</span>
 313 |     | <span class='neutral'></span>
 314 |     | <span class='neutral'>    // Private function so needs to be copied over</span>
 315 |     | <span class='neutral'>    function flatten(bytes32[] memory b) private pure returns (bytes memory) {</span>
 316 |     | <span class='neutral'>        bytes memory result = new bytes(b.length * 32);</span>
 317 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; b.length; i++) {</span>
 318 |     | <span class='neutral'>            bytes32 k = b[i];</span>
 319 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
 320 |     | <span class='neutral'>            assembly {</span>
 321 |     | <span class='neutral'>                mstore(add(result, add(32, mul(32, i))), k)</span>
 322 |     | <span class='neutral'>            }</span>
 323 |     | <span class='neutral'>        }</span>
 324 |     | <span class='neutral'></span>
 325 |     | <span class='neutral'>        return result;</span>
 326 |     | <span class='neutral'>    }</span>
 327 |     | <span class='neutral'>}</span>
 328 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/forge-std/src/StdStyle.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.4.22 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {Vm} from &quot;./Vm.sol&quot;;</span>
   5 |     | <span class='unexecuted'></span>
   6 |     | <span class='neutral'>library StdStyle {</span>
   7 |     | <span class='neutral'>    Vm private constant vm = Vm(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>    string constant RED = &quot;\u001b[91m&quot;;</span>
  10 |     | <span class='neutral'>    string constant GREEN = &quot;\u001b[92m&quot;;</span>
  11 |     | <span class='neutral'>    string constant YELLOW = &quot;\u001b[93m&quot;;</span>
  12 |     | <span class='neutral'>    string constant BLUE = &quot;\u001b[94m&quot;;</span>
  13 |     | <span class='neutral'>    string constant MAGENTA = &quot;\u001b[95m&quot;;</span>
  14 |     | <span class='neutral'>    string constant CYAN = &quot;\u001b[96m&quot;;</span>
  15 |     | <span class='neutral'>    string constant BOLD = &quot;\u001b[1m&quot;;</span>
  16 |     | <span class='neutral'>    string constant DIM = &quot;\u001b[2m&quot;;</span>
  17 |     | <span class='neutral'>    string constant ITALIC = &quot;\u001b[3m&quot;;</span>
  18 |     | <span class='neutral'>    string constant UNDERLINE = &quot;\u001b[4m&quot;;</span>
  19 |     | <span class='neutral'>    string constant INVERSE = &quot;\u001b[7m&quot;;</span>
  20 |     | <span class='neutral'>    string constant RESET = &quot;\u001b[0m&quot;;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    function styleConcat(string memory style, string memory self) private pure returns (string memory) {</span>
  23 |     | <span class='neutral'>        return string(abi.encodePacked(style, self, RESET));</span>
  24 |     | <span class='neutral'>    }</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    function red(string memory self) internal pure returns (string memory) {</span>
  27 |     | <span class='neutral'>        return styleConcat(RED, self);</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    function red(uint256 self) internal pure returns (string memory) {</span>
  31 |     | <span class='neutral'>        return red(vm.toString(self));</span>
  32 |     | <span class='neutral'>    }</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    function red(int256 self) internal pure returns (string memory) {</span>
  35 |     | <span class='neutral'>        return red(vm.toString(self));</span>
  36 |     | <span class='neutral'>    }</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    function red(address self) internal pure returns (string memory) {</span>
  39 |     | <span class='neutral'>        return red(vm.toString(self));</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    function red(bool self) internal pure returns (string memory) {</span>
  43 |     | <span class='neutral'>        return red(vm.toString(self));</span>
  44 |     | <span class='neutral'>    }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    function redBytes(bytes memory self) internal pure returns (string memory) {</span>
  47 |     | <span class='neutral'>        return red(vm.toString(self));</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    function redBytes32(bytes32 self) internal pure returns (string memory) {</span>
  51 |     | <span class='neutral'>        return red(vm.toString(self));</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    function green(string memory self) internal pure returns (string memory) {</span>
  55 |     | <span class='neutral'>        return styleConcat(GREEN, self);</span>
  56 |     | <span class='neutral'>    }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    function green(uint256 self) internal pure returns (string memory) {</span>
  59 |     | <span class='neutral'>        return green(vm.toString(self));</span>
  60 |     | <span class='neutral'>    }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    function green(int256 self) internal pure returns (string memory) {</span>
  63 |     | <span class='neutral'>        return green(vm.toString(self));</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    function green(address self) internal pure returns (string memory) {</span>
  67 |     | <span class='neutral'>        return green(vm.toString(self));</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    function green(bool self) internal pure returns (string memory) {</span>
  71 |     | <span class='neutral'>        return green(vm.toString(self));</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    function greenBytes(bytes memory self) internal pure returns (string memory) {</span>
  75 |     | <span class='neutral'>        return green(vm.toString(self));</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    function greenBytes32(bytes32 self) internal pure returns (string memory) {</span>
  79 |     | <span class='neutral'>        return green(vm.toString(self));</span>
  80 |     | <span class='neutral'>    }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    function yellow(string memory self) internal pure returns (string memory) {</span>
  83 |     | <span class='neutral'>        return styleConcat(YELLOW, self);</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    function yellow(uint256 self) internal pure returns (string memory) {</span>
  87 |     | <span class='neutral'>        return yellow(vm.toString(self));</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    function yellow(int256 self) internal pure returns (string memory) {</span>
  91 |     | <span class='neutral'>        return yellow(vm.toString(self));</span>
  92 |     | <span class='neutral'>    }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    function yellow(address self) internal pure returns (string memory) {</span>
  95 |     | <span class='neutral'>        return yellow(vm.toString(self));</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    function yellow(bool self) internal pure returns (string memory) {</span>
  99 |     | <span class='neutral'>        return yellow(vm.toString(self));</span>
 100 |     | <span class='neutral'>    }</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>    function yellowBytes(bytes memory self) internal pure returns (string memory) {</span>
 103 |     | <span class='neutral'>        return yellow(vm.toString(self));</span>
 104 |     | <span class='neutral'>    }</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>    function yellowBytes32(bytes32 self) internal pure returns (string memory) {</span>
 107 |     | <span class='neutral'>        return yellow(vm.toString(self));</span>
 108 |     | <span class='neutral'>    }</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>    function blue(string memory self) internal pure returns (string memory) {</span>
 111 |     | <span class='neutral'>        return styleConcat(BLUE, self);</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    function blue(uint256 self) internal pure returns (string memory) {</span>
 115 |     | <span class='neutral'>        return blue(vm.toString(self));</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    function blue(int256 self) internal pure returns (string memory) {</span>
 119 |     | <span class='neutral'>        return blue(vm.toString(self));</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    function blue(address self) internal pure returns (string memory) {</span>
 123 |     | <span class='neutral'>        return blue(vm.toString(self));</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    function blue(bool self) internal pure returns (string memory) {</span>
 127 |     | <span class='neutral'>        return blue(vm.toString(self));</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    function blueBytes(bytes memory self) internal pure returns (string memory) {</span>
 131 |     | <span class='neutral'>        return blue(vm.toString(self));</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>    function blueBytes32(bytes32 self) internal pure returns (string memory) {</span>
 135 |     | <span class='neutral'>        return blue(vm.toString(self));</span>
 136 |     | <span class='neutral'>    }</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>    function magenta(string memory self) internal pure returns (string memory) {</span>
 139 |     | <span class='neutral'>        return styleConcat(MAGENTA, self);</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    function magenta(uint256 self) internal pure returns (string memory) {</span>
 143 |     | <span class='neutral'>        return magenta(vm.toString(self));</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>    function magenta(int256 self) internal pure returns (string memory) {</span>
 147 |     | <span class='neutral'>        return magenta(vm.toString(self));</span>
 148 |     | <span class='neutral'>    }</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>    function magenta(address self) internal pure returns (string memory) {</span>
 151 |     | <span class='neutral'>        return magenta(vm.toString(self));</span>
 152 |     | <span class='neutral'>    }</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>    function magenta(bool self) internal pure returns (string memory) {</span>
 155 |     | <span class='neutral'>        return magenta(vm.toString(self));</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>    function magentaBytes(bytes memory self) internal pure returns (string memory) {</span>
 159 |     | <span class='neutral'>        return magenta(vm.toString(self));</span>
 160 |     | <span class='neutral'>    }</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>    function magentaBytes32(bytes32 self) internal pure returns (string memory) {</span>
 163 |     | <span class='neutral'>        return magenta(vm.toString(self));</span>
 164 |     | <span class='neutral'>    }</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='neutral'>    function cyan(string memory self) internal pure returns (string memory) {</span>
 167 |     | <span class='neutral'>        return styleConcat(CYAN, self);</span>
 168 |     | <span class='neutral'>    }</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='neutral'>    function cyan(uint256 self) internal pure returns (string memory) {</span>
 171 |     | <span class='neutral'>        return cyan(vm.toString(self));</span>
 172 |     | <span class='neutral'>    }</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>    function cyan(int256 self) internal pure returns (string memory) {</span>
 175 |     | <span class='neutral'>        return cyan(vm.toString(self));</span>
 176 |     | <span class='neutral'>    }</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='neutral'>    function cyan(address self) internal pure returns (string memory) {</span>
 179 |     | <span class='neutral'>        return cyan(vm.toString(self));</span>
 180 |     | <span class='neutral'>    }</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='neutral'>    function cyan(bool self) internal pure returns (string memory) {</span>
 183 |     | <span class='neutral'>        return cyan(vm.toString(self));</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>    function cyanBytes(bytes memory self) internal pure returns (string memory) {</span>
 187 |     | <span class='neutral'>        return cyan(vm.toString(self));</span>
 188 |     | <span class='neutral'>    }</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='neutral'>    function cyanBytes32(bytes32 self) internal pure returns (string memory) {</span>
 191 |     | <span class='neutral'>        return cyan(vm.toString(self));</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='neutral'>    function bold(string memory self) internal pure returns (string memory) {</span>
 195 |     | <span class='neutral'>        return styleConcat(BOLD, self);</span>
 196 |     | <span class='neutral'>    }</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='neutral'>    function bold(uint256 self) internal pure returns (string memory) {</span>
 199 |     | <span class='neutral'>        return bold(vm.toString(self));</span>
 200 |     | <span class='neutral'>    }</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='neutral'>    function bold(int256 self) internal pure returns (string memory) {</span>
 203 |     | <span class='neutral'>        return bold(vm.toString(self));</span>
 204 |     | <span class='neutral'>    }</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='neutral'>    function bold(address self) internal pure returns (string memory) {</span>
 207 |     | <span class='neutral'>        return bold(vm.toString(self));</span>
 208 |     | <span class='neutral'>    }</span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='neutral'>    function bold(bool self) internal pure returns (string memory) {</span>
 211 |     | <span class='neutral'>        return bold(vm.toString(self));</span>
 212 |     | <span class='neutral'>    }</span>
 213 |     | <span class='neutral'></span>
 214 |     | <span class='neutral'>    function boldBytes(bytes memory self) internal pure returns (string memory) {</span>
 215 |     | <span class='neutral'>        return bold(vm.toString(self));</span>
 216 |     | <span class='neutral'>    }</span>
 217 |     | <span class='neutral'></span>
 218 |     | <span class='neutral'>    function boldBytes32(bytes32 self) internal pure returns (string memory) {</span>
 219 |     | <span class='neutral'>        return bold(vm.toString(self));</span>
 220 |     | <span class='neutral'>    }</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='neutral'>    function dim(string memory self) internal pure returns (string memory) {</span>
 223 |     | <span class='neutral'>        return styleConcat(DIM, self);</span>
 224 |     | <span class='neutral'>    }</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='neutral'>    function dim(uint256 self) internal pure returns (string memory) {</span>
 227 |     | <span class='neutral'>        return dim(vm.toString(self));</span>
 228 |     | <span class='neutral'>    }</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='neutral'>    function dim(int256 self) internal pure returns (string memory) {</span>
 231 |     | <span class='neutral'>        return dim(vm.toString(self));</span>
 232 |     | <span class='neutral'>    }</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='neutral'>    function dim(address self) internal pure returns (string memory) {</span>
 235 |     | <span class='neutral'>        return dim(vm.toString(self));</span>
 236 |     | <span class='neutral'>    }</span>
 237 |     | <span class='neutral'></span>
 238 |     | <span class='neutral'>    function dim(bool self) internal pure returns (string memory) {</span>
 239 |     | <span class='neutral'>        return dim(vm.toString(self));</span>
 240 |     | <span class='neutral'>    }</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='neutral'>    function dimBytes(bytes memory self) internal pure returns (string memory) {</span>
 243 |     | <span class='neutral'>        return dim(vm.toString(self));</span>
 244 |     | <span class='neutral'>    }</span>
 245 |     | <span class='neutral'></span>
 246 |     | <span class='neutral'>    function dimBytes32(bytes32 self) internal pure returns (string memory) {</span>
 247 |     | <span class='neutral'>        return dim(vm.toString(self));</span>
 248 |     | <span class='neutral'>    }</span>
 249 |     | <span class='neutral'></span>
 250 |     | <span class='neutral'>    function italic(string memory self) internal pure returns (string memory) {</span>
 251 |     | <span class='neutral'>        return styleConcat(ITALIC, self);</span>
 252 |     | <span class='neutral'>    }</span>
 253 |     | <span class='neutral'></span>
 254 |     | <span class='neutral'>    function italic(uint256 self) internal pure returns (string memory) {</span>
 255 |     | <span class='neutral'>        return italic(vm.toString(self));</span>
 256 |     | <span class='neutral'>    }</span>
 257 |     | <span class='neutral'></span>
 258 |     | <span class='neutral'>    function italic(int256 self) internal pure returns (string memory) {</span>
 259 |     | <span class='neutral'>        return italic(vm.toString(self));</span>
 260 |     | <span class='neutral'>    }</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='neutral'>    function italic(address self) internal pure returns (string memory) {</span>
 263 |     | <span class='neutral'>        return italic(vm.toString(self));</span>
 264 |     | <span class='neutral'>    }</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='neutral'>    function italic(bool self) internal pure returns (string memory) {</span>
 267 |     | <span class='neutral'>        return italic(vm.toString(self));</span>
 268 |     | <span class='neutral'>    }</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='neutral'>    function italicBytes(bytes memory self) internal pure returns (string memory) {</span>
 271 |     | <span class='neutral'>        return italic(vm.toString(self));</span>
 272 |     | <span class='neutral'>    }</span>
 273 |     | <span class='neutral'></span>
 274 |     | <span class='neutral'>    function italicBytes32(bytes32 self) internal pure returns (string memory) {</span>
 275 |     | <span class='neutral'>        return italic(vm.toString(self));</span>
 276 |     | <span class='neutral'>    }</span>
 277 |     | <span class='neutral'></span>
 278 |     | <span class='neutral'>    function underline(string memory self) internal pure returns (string memory) {</span>
 279 |     | <span class='neutral'>        return styleConcat(UNDERLINE, self);</span>
 280 |     | <span class='neutral'>    }</span>
 281 |     | <span class='neutral'></span>
 282 |     | <span class='neutral'>    function underline(uint256 self) internal pure returns (string memory) {</span>
 283 |     | <span class='neutral'>        return underline(vm.toString(self));</span>
 284 |     | <span class='neutral'>    }</span>
 285 |     | <span class='neutral'></span>
 286 |     | <span class='neutral'>    function underline(int256 self) internal pure returns (string memory) {</span>
 287 |     | <span class='neutral'>        return underline(vm.toString(self));</span>
 288 |     | <span class='neutral'>    }</span>
 289 |     | <span class='neutral'></span>
 290 |     | <span class='neutral'>    function underline(address self) internal pure returns (string memory) {</span>
 291 |     | <span class='neutral'>        return underline(vm.toString(self));</span>
 292 |     | <span class='neutral'>    }</span>
 293 |     | <span class='neutral'></span>
 294 |     | <span class='neutral'>    function underline(bool self) internal pure returns (string memory) {</span>
 295 |     | <span class='neutral'>        return underline(vm.toString(self));</span>
 296 |     | <span class='neutral'>    }</span>
 297 |     | <span class='neutral'></span>
 298 |     | <span class='neutral'>    function underlineBytes(bytes memory self) internal pure returns (string memory) {</span>
 299 |     | <span class='neutral'>        return underline(vm.toString(self));</span>
 300 |     | <span class='neutral'>    }</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='neutral'>    function underlineBytes32(bytes32 self) internal pure returns (string memory) {</span>
 303 |     | <span class='neutral'>        return underline(vm.toString(self));</span>
 304 |     | <span class='neutral'>    }</span>
 305 |     | <span class='neutral'></span>
 306 |     | <span class='neutral'>    function inverse(string memory self) internal pure returns (string memory) {</span>
 307 |     | <span class='neutral'>        return styleConcat(INVERSE, self);</span>
 308 |     | <span class='neutral'>    }</span>
 309 |     | <span class='neutral'></span>
 310 |     | <span class='neutral'>    function inverse(uint256 self) internal pure returns (string memory) {</span>
 311 |     | <span class='neutral'>        return inverse(vm.toString(self));</span>
 312 |     | <span class='neutral'>    }</span>
 313 |     | <span class='neutral'></span>
 314 |     | <span class='neutral'>    function inverse(int256 self) internal pure returns (string memory) {</span>
 315 |     | <span class='neutral'>        return inverse(vm.toString(self));</span>
 316 |     | <span class='neutral'>    }</span>
 317 |     | <span class='neutral'></span>
 318 |     | <span class='neutral'>    function inverse(address self) internal pure returns (string memory) {</span>
 319 |     | <span class='neutral'>        return inverse(vm.toString(self));</span>
 320 |     | <span class='neutral'>    }</span>
 321 |     | <span class='neutral'></span>
 322 |     | <span class='neutral'>    function inverse(bool self) internal pure returns (string memory) {</span>
 323 |     | <span class='neutral'>        return inverse(vm.toString(self));</span>
 324 |     | <span class='neutral'>    }</span>
 325 |     | <span class='neutral'></span>
 326 |     | <span class='neutral'>    function inverseBytes(bytes memory self) internal pure returns (string memory) {</span>
 327 |     | <span class='neutral'>        return inverse(vm.toString(self));</span>
 328 |     | <span class='neutral'>    }</span>
 329 |     | <span class='neutral'></span>
 330 |     | <span class='neutral'>    function inverseBytes32(bytes32 self) internal pure returns (string memory) {</span>
 331 |     | <span class='neutral'>        return inverse(vm.toString(self));</span>
 332 |     | <span class='neutral'>    }</span>
 333 |     | <span class='neutral'>}</span>
 334 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/forge-std/src/StdUtils.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {IMulticall3} from &quot;./interfaces/IMulticall3.sol&quot;;</span>
   7 |     | <span class='neutral'>// TODO Remove import.</span>
   8 |     | <span class='neutral'>import {VmSafe} from &quot;./Vm.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>abstract contract StdUtils {</span>
  11 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////////////////</span>
  12 |     | <span class='neutral'>                                     CONSTANTS</span>
  13 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////*/</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    IMulticall3 private constant multicall = IMulticall3(0xcA11bde05977b3631167028862bE2a173976CA11);</span>
  16 |     | <span class='neutral'>    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  17 |     | <span class='neutral'>    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;</span>
  18 |     | <span class='neutral'>    uint256 private constant INT256_MIN_ABS =</span>
  19 |     | <span class='neutral'>        57896044618658097711785492504343953926634992332820282019728792003956564819968;</span>
  20 |     | <span class='neutral'>    uint256 private constant UINT256_MAX =</span>
  21 |     | <span class='neutral'>        115792089237316195423570985008687907853269984665640564039457584007913129639935;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    // Used by default when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.</span>
  24 |     | <span class='neutral'>    address private constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////////////////</span>
  27 |     | <span class='neutral'>                                 INTERNAL FUNCTIONS</span>
  28 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////*/</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {</span>
  31 |     | <span class='neutral'>        require(min &lt;= max, &quot;StdUtils bound(uint256,uint256,uint256): Max is less than min.&quot;);</span>
  32 |     | <span class='neutral'>        // If x is between min and max, return x directly. This is to ensure that dictionary values</span>
  33 |     | <span class='neutral'>        // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188</span>
  34 |     | <span class='neutral'>        if (x &gt;= min &amp;&amp; x &lt;= max) return x;</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>        uint256 size = max - min + 1;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>        // If the value is 0, 1, 2, 3, warp that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.</span>
  39 |     | <span class='neutral'>        // This helps ensure coverage of the min/max values.</span>
  40 |     | <span class='neutral'>        if (x &lt;= 3 &amp;&amp; size &gt; x) return min + x;</span>
  41 |     | <span class='neutral'>        if (x &gt;= UINT256_MAX - 3 &amp;&amp; size &gt; UINT256_MAX - x) return max - (UINT256_MAX - x);</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>        // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.</span>
  44 |     | <span class='neutral'>        if (x &gt; max) {</span>
  45 |     | <span class='neutral'>            uint256 diff = x - max;</span>
  46 |     | <span class='neutral'>            uint256 rem = diff % size;</span>
  47 |     | <span class='neutral'>            if (rem == 0) return max;</span>
  48 |     | <span class='neutral'>            result = min + rem - 1;</span>
  49 |     | <span class='neutral'>        } else if (x &lt; min) {</span>
  50 |     | <span class='neutral'>            uint256 diff = min - x;</span>
  51 |     | <span class='neutral'>            uint256 rem = diff % size;</span>
  52 |     | <span class='neutral'>            if (rem == 0) return min;</span>
  53 |     | <span class='neutral'>            result = max - rem + 1;</span>
  54 |     | <span class='neutral'>        }</span>
  55 |     | <span class='neutral'>    }</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>    function bound(uint256 x, uint256 min, uint256 max) internal view virtual returns (uint256 result) {</span>
  58 |     | <span class='neutral'>        result = _bound(x, min, max);</span>
  59 |     | <span class='neutral'>        console2_log(&quot;Bound Result&quot;, result);</span>
  60 |     | <span class='neutral'>    }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    function bound(int256 x, int256 min, int256 max) internal view virtual returns (int256 result) {</span>
  63 |     | <span class='neutral'>        require(min &lt;= max, &quot;StdUtils bound(int256,int256,int256): Max is less than min.&quot;);</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>        // Shifting all int256 values to uint256 to use _bound function. The range of two types are:</span>
  66 |     | <span class='neutral'>        // int256 : -(2**255) ~ (2**255 - 1)</span>
  67 |     | <span class='neutral'>        // uint256:     0     ~ (2**256 - 1)</span>
  68 |     | <span class='neutral'>        // So, add 2**255, INT256_MIN_ABS to the integer values.</span>
  69 |     | <span class='neutral'>        //</span>
  70 |     | <span class='neutral'>        // If the given integer value is -2**255, we cannot use `-uint256(-x)` because of the overflow.</span>
  71 |     | <span class='neutral'>        // So, use `~uint256(x) + 1` instead.</span>
  72 |     | <span class='neutral'>        uint256 _x = x &lt; 0 ? (INT256_MIN_ABS - ~uint256(x) - 1) : (uint256(x) + INT256_MIN_ABS);</span>
  73 |     | <span class='neutral'>        uint256 _min = min &lt; 0 ? (INT256_MIN_ABS - ~uint256(min) - 1) : (uint256(min) + INT256_MIN_ABS);</span>
  74 |     | <span class='neutral'>        uint256 _max = max &lt; 0 ? (INT256_MIN_ABS - ~uint256(max) - 1) : (uint256(max) + INT256_MIN_ABS);</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>        uint256 y = _bound(_x, _min, _max);</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>        // To move it back to int256 value, subtract INT256_MIN_ABS at here.</span>
  79 |     | <span class='neutral'>        result = y &lt; INT256_MIN_ABS ? int256(~(INT256_MIN_ABS - y) + 1) : int256(y - INT256_MIN_ABS);</span>
  80 |     | <span class='neutral'>        console2_log(&quot;Bound result&quot;, vm.toString(result));</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    function bytesToUint(bytes memory b) internal pure virtual returns (uint256) {</span>
  84 |     | <span class='neutral'>        require(b.length &lt;= 32, &quot;StdUtils bytesToUint(bytes): Bytes length exceeds 32.&quot;);</span>
  85 |     | <span class='neutral'>        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce</span>
  89 |     | <span class='neutral'>    /// @notice adapted from Solmate implementation (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibRLP.sol)</span>
  90 |     | <span class='neutral'>    function computeCreateAddress(address deployer, uint256 nonce) internal pure virtual returns (address) {</span>
  91 |     | <span class='neutral'>        // forgefmt: disable-start</span>
  92 |     | <span class='neutral'>        // The integer zero is treated as an empty byte string, and as a result it only has a length prefix, 0x80, computed via 0x80 + 0.</span>
  93 |     | <span class='neutral'>        // A one byte integer uses its own value as its length prefix, there is no additional &quot;0x80 + length&quot; prefix that comes before it.</span>
  94 |     | <span class='neutral'>        if (nonce == 0x00)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80))));</span>
  95 |     | <span class='neutral'>        if (nonce &lt;= 0x7f)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce))));</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>        // Nonces greater than 1 byte all follow a consistent encoding scheme, where each value is preceded by a prefix of 0x80 + length.</span>
  98 |     | <span class='neutral'>        if (nonce &lt;= 2**8 - 1)  return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployer, bytes1(0x81), uint8(nonce))));</span>
  99 |     | <span class='neutral'>        if (nonce &lt;= 2**16 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployer, bytes1(0x82), uint16(nonce))));</span>
 100 |     | <span class='neutral'>        if (nonce &lt;= 2**24 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployer, bytes1(0x83), uint24(nonce))));</span>
 101 |     | <span class='neutral'>        // forgefmt: disable-end</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>        // More details about RLP encoding can be found here: https://eth.wiki/fundamentals/rlp</span>
 104 |     | <span class='neutral'>        // 0xda = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x84 ++ nonce)</span>
 105 |     | <span class='neutral'>        // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)</span>
 106 |     | <span class='neutral'>        // 0x84 = 0x80 + 0x04 (0x04 = the bytes length of the nonce, 4 bytes, in hex)</span>
 107 |     | <span class='neutral'>        // We assume nobody can have a nonce large enough to require more than 32 bytes.</span>
 108 |     | <span class='neutral'>        return addressFromLast20Bytes(</span>
 109 |     | <span class='neutral'>            keccak256(abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce)))</span>
 110 |     | <span class='neutral'>        );</span>
 111 |     | <span class='neutral'>    }</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>    function computeCreate2Address(bytes32 salt, bytes32 initcodeHash, address deployer)</span>
 114 |     | <span class='neutral'>        internal</span>
 115 |     | <span class='neutral'>        pure</span>
 116 |     | <span class='neutral'>        virtual</span>
 117 |     | <span class='neutral'>        returns (address)</span>
 118 |     | <span class='neutral'>    {</span>
 119 |     | <span class='neutral'>        return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, initcodeHash)));</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    /// @dev returns the address of a contract created with CREATE2 using the default CREATE2 deployer</span>
 123 |     | <span class='neutral'>    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) internal pure returns (address) {</span>
 124 |     | <span class='neutral'>        return computeCreate2Address(salt, initCodeHash, CREATE2_FACTORY);</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>    /// @dev returns the hash of the init code (creation code + no args) used in CREATE2 with no constructor arguments</span>
 128 |     | <span class='neutral'>    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode</span>
 129 |     | <span class='neutral'>    function hashInitCode(bytes memory creationCode) internal pure returns (bytes32) {</span>
 130 |     | <span class='neutral'>        return hashInitCode(creationCode, &quot;&quot;);</span>
 131 |     | <span class='neutral'>    }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>    /// @dev returns the hash of the init code (creation code + ABI-encoded args) used in CREATE2</span>
 134 |     | <span class='neutral'>    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode</span>
 135 |     | <span class='neutral'>    /// @param args the ABI-encoded arguments to the constructor of C</span>
 136 |     | <span class='neutral'>    function hashInitCode(bytes memory creationCode, bytes memory args) internal pure returns (bytes32) {</span>
 137 |     | <span class='neutral'>        return keccak256(abi.encodePacked(creationCode, args));</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    // Performs a single call with Multicall3 to query the ERC-20 token balances of the given addresses.</span>
 141 |     | <span class='neutral'>    function getTokenBalances(address token, address[] memory addresses)</span>
 142 |     | <span class='neutral'>        internal</span>
 143 |     | <span class='neutral'>        virtual</span>
 144 |     | <span class='neutral'>        returns (uint256[] memory balances)</span>
 145 |     | <span class='neutral'>    {</span>
 146 |     | <span class='neutral'>        uint256 tokenCodeSize;</span>
 147 |     | <span class='neutral'>        assembly {</span>
 148 |     | <span class='neutral'>            tokenCodeSize := extcodesize(token)</span>
 149 |     | <span class='neutral'>        }</span>
 150 |     | <span class='neutral'>        require(tokenCodeSize &gt; 0, &quot;StdUtils getTokenBalances(address,address[]): Token address is not a contract.&quot;);</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>        // ABI encode the aggregate call to Multicall3.</span>
 153 |     | <span class='neutral'>        uint256 length = addresses.length;</span>
 154 |     | <span class='neutral'>        IMulticall3.Call[] memory calls = new IMulticall3.Call[](length);</span>
 155 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; length; ++i) {</span>
 156 |     | <span class='neutral'>            // 0x70a08231 = bytes4(&quot;balanceOf(address)&quot;))</span>
 157 |     | <span class='neutral'>            calls[i] = IMulticall3.Call({target: token, callData: abi.encodeWithSelector(0x70a08231, (addresses[i]))});</span>
 158 |     | <span class='neutral'>        }</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='neutral'>        // Make the aggregate call.</span>
 161 |     | <span class='neutral'>        (, bytes[] memory returnData) = multicall.aggregate(calls);</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>        // ABI decode the return data and return the balances.</span>
 164 |     | <span class='neutral'>        balances = new uint256[](length);</span>
 165 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; length; ++i) {</span>
 166 |     | <span class='neutral'>            balances[i] = abi.decode(returnData[i], (uint256));</span>
 167 |     | <span class='neutral'>        }</span>
 168 |     | <span class='neutral'>    }</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////////////////</span>
 171 |     | <span class='neutral'>                                 PRIVATE FUNCTIONS</span>
 172 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////*/</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>    function addressFromLast20Bytes(bytes32 bytesValue) private pure returns (address) {</span>
 175 |     | <span class='neutral'>        return address(uint160(uint256(bytesValue)));</span>
 176 |     | <span class='neutral'>    }</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='neutral'>    // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='neutral'>    function console2_log(string memory p0, uint256 p1) private view {</span>
 181 |     | <span class='neutral'>        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(&quot;log(string,uint256)&quot;, p0, p1));</span>
 182 |     | <span class='neutral'>        status;</span>
 183 |     | <span class='neutral'>    }</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='neutral'>    function console2_log(string memory p0, string memory p1) private view {</span>
 186 |     | <span class='neutral'>        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(&quot;log(string,string)&quot;, p0, p1));</span>
 187 |     | <span class='neutral'>        status;</span>
 188 |     | <span class='neutral'>    }</span>
 189 |     | <span class='neutral'>}</span>
 190 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/forge-std/src/Test.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>// üí¨ ABOUT</span>
  7 |     | <span class='neutral'>// Standard Library&#39;s default Test</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>// üß© MODULES</span>
 10 |     | <span class='neutral'>import {console} from &quot;./console.sol&quot;;</span>
 11 |     | <span class='neutral'>import {console2} from &quot;./console2.sol&quot;;</span>
 12 |     | <span class='neutral'>import {StdAssertions} from &quot;./StdAssertions.sol&quot;;</span>
 13 |     | <span class='neutral'>import {StdChains} from &quot;./StdChains.sol&quot;;</span>
 14 |     | <span class='neutral'>import {StdCheats} from &quot;./StdCheats.sol&quot;;</span>
 15 |     | <span class='neutral'>import {stdError} from &quot;./StdError.sol&quot;;</span>
 16 |     | <span class='neutral'>import {StdInvariant} from &quot;./StdInvariant.sol&quot;;</span>
 17 |     | <span class='neutral'>import {stdJson} from &quot;./StdJson.sol&quot;;</span>
 18 |     | <span class='neutral'>import {stdMath} from &quot;./StdMath.sol&quot;;</span>
 19 |     | <span class='neutral'>import {StdStorage, stdStorage} from &quot;./StdStorage.sol&quot;;</span>
 20 |     | <span class='neutral'>import {StdUtils} from &quot;./StdUtils.sol&quot;;</span>
 21 |     | <span class='neutral'>import {Vm} from &quot;./Vm.sol&quot;;</span>
 22 |     | <span class='neutral'>import {StdStyle} from &quot;./StdStyle.sol&quot;;</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>// üì¶ BOILERPLATE</span>
 25 |     | <span class='neutral'>import {TestBase} from &quot;./Base.sol&quot;;</span>
 26 |     | <span class='neutral'>import {DSTest} from &quot;ds-test/test.sol&quot;;</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>// ‚≠êÔ∏è TEST</span>
 29 |     | <span class='neutral'>abstract contract Test is DSTest, StdAssertions, StdChains, StdCheats, StdInvariant, StdUtils, TestBase {</span>
 30 |     | <span class='neutral'>// Note: IS_TEST() must return true.</span>
 31 |     | <span class='neutral'>// Note: Must have failure system, https://github.com/dapphub/ds-test/blob/cd98eff28324bfac652e63a239a60632a761790b/src/test.sol#L39-L76.</span>
 32 |     | <span class='neutral'>}</span>
 33 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/forge-std/src/Vm.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>// Cheatcodes are marked as view/pure/none using the following rules:</span>
   7 |     | <span class='neutral'>// 0. A call&#39;s observable behaviour includes its return value, logs, reverts and state writes,</span>
   8 |     | <span class='neutral'>// 1. If you can influence a later call&#39;s observable behaviour, you&#39;re neither `view` nor `pure (you are modifying some state be it the EVM, interpreter, filesystem, etc),</span>
   9 |     | <span class='neutral'>// 2. Otherwise if you can be influenced by an earlier call, or if reading some state, you&#39;re `view`,</span>
  10 |     | <span class='neutral'>// 3. Otherwise you&#39;re `pure`.</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>interface VmSafe {</span>
  13 |     | <span class='neutral'>    struct Log {</span>
  14 |     | <span class='neutral'>        bytes32[] topics;</span>
  15 |     | <span class='neutral'>        bytes data;</span>
  16 |     | <span class='neutral'>        address emitter;</span>
  17 |     | <span class='neutral'>    }</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    struct Rpc {</span>
  20 |     | <span class='neutral'>        string key;</span>
  21 |     | <span class='neutral'>        string url;</span>
  22 |     | <span class='neutral'>    }</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    struct FsMetadata {</span>
  25 |     | <span class='neutral'>        bool isDir;</span>
  26 |     | <span class='neutral'>        bool isSymlink;</span>
  27 |     | <span class='neutral'>        uint256 length;</span>
  28 |     | <span class='neutral'>        bool readOnly;</span>
  29 |     | <span class='neutral'>        uint256 modified;</span>
  30 |     | <span class='neutral'>        uint256 accessed;</span>
  31 |     | <span class='neutral'>        uint256 created;</span>
  32 |     | <span class='neutral'>    }</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    // Loads a storage slot from an address</span>
  35 |     | <span class='neutral'>    function load(address target, bytes32 slot) external view returns (bytes32 data);</span>
  36 |     | <span class='neutral'>    // Signs data</span>
  37 |     | <span class='neutral'>    function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);</span>
  38 |     | <span class='neutral'>    // Gets the address for a given private key</span>
  39 |     | <span class='neutral'>    function addr(uint256 privateKey) external pure returns (address keyAddr);</span>
  40 |     | <span class='neutral'>    // Gets the nonce of an account</span>
  41 |     | <span class='neutral'>    function getNonce(address account) external view returns (uint64 nonce);</span>
  42 |     | <span class='neutral'>    // Performs a foreign function call via the terminal</span>
  43 |     | <span class='neutral'>    function ffi(string[] calldata commandInput) external returns (bytes memory result);</span>
  44 |     | <span class='neutral'>    // Sets environment variables</span>
  45 |     | <span class='neutral'>    function setEnv(string calldata name, string calldata value) external;</span>
  46 |     | <span class='neutral'>    // Reads environment variables, (name) =&gt; (value)</span>
  47 |     | <span class='neutral'>    function envBool(string calldata name) external view returns (bool value);</span>
  48 |     | <span class='neutral'>    function envUint(string calldata name) external view returns (uint256 value);</span>
  49 |     | <span class='neutral'>    function envInt(string calldata name) external view returns (int256 value);</span>
  50 |     | <span class='neutral'>    function envAddress(string calldata name) external view returns (address value);</span>
  51 |     | <span class='neutral'>    function envBytes32(string calldata name) external view returns (bytes32 value);</span>
  52 |     | <span class='neutral'>    function envString(string calldata name) external view returns (string memory value);</span>
  53 |     | <span class='neutral'>    function envBytes(string calldata name) external view returns (bytes memory value);</span>
  54 |     | <span class='neutral'>    // Reads environment variables as arrays</span>
  55 |     | <span class='neutral'>    function envBool(string calldata name, string calldata delim) external view returns (bool[] memory value);</span>
  56 |     | <span class='neutral'>    function envUint(string calldata name, string calldata delim) external view returns (uint256[] memory value);</span>
  57 |     | <span class='neutral'>    function envInt(string calldata name, string calldata delim) external view returns (int256[] memory value);</span>
  58 |     | <span class='neutral'>    function envAddress(string calldata name, string calldata delim) external view returns (address[] memory value);</span>
  59 |     | <span class='neutral'>    function envBytes32(string calldata name, string calldata delim) external view returns (bytes32[] memory value);</span>
  60 |     | <span class='neutral'>    function envString(string calldata name, string calldata delim) external view returns (string[] memory value);</span>
  61 |     | <span class='neutral'>    function envBytes(string calldata name, string calldata delim) external view returns (bytes[] memory value);</span>
  62 |     | <span class='neutral'>    // Read environment variables with default value</span>
  63 |     | <span class='neutral'>    function envOr(string calldata name, bool defaultValue) external returns (bool value);</span>
  64 |     | <span class='neutral'>    function envOr(string calldata name, uint256 defaultValue) external returns (uint256 value);</span>
  65 |     | <span class='neutral'>    function envOr(string calldata name, int256 defaultValue) external returns (int256 value);</span>
  66 |     | <span class='neutral'>    function envOr(string calldata name, address defaultValue) external returns (address value);</span>
  67 |     | <span class='neutral'>    function envOr(string calldata name, bytes32 defaultValue) external returns (bytes32 value);</span>
  68 |     | <span class='neutral'>    function envOr(string calldata name, string calldata defaultValue) external returns (string memory value);</span>
  69 |     | <span class='neutral'>    function envOr(string calldata name, bytes calldata defaultValue) external returns (bytes memory value);</span>
  70 |     | <span class='neutral'>    // Read environment variables as arrays with default value</span>
  71 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)</span>
  72 |     | <span class='neutral'>        external</span>
  73 |     | <span class='neutral'>        returns (bool[] memory value);</span>
  74 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)</span>
  75 |     | <span class='neutral'>        external</span>
  76 |     | <span class='neutral'>        returns (uint256[] memory value);</span>
  77 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)</span>
  78 |     | <span class='neutral'>        external</span>
  79 |     | <span class='neutral'>        returns (int256[] memory value);</span>
  80 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)</span>
  81 |     | <span class='neutral'>        external</span>
  82 |     | <span class='neutral'>        returns (address[] memory value);</span>
  83 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)</span>
  84 |     | <span class='neutral'>        external</span>
  85 |     | <span class='neutral'>        returns (bytes32[] memory value);</span>
  86 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)</span>
  87 |     | <span class='neutral'>        external</span>
  88 |     | <span class='neutral'>        returns (string[] memory value);</span>
  89 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)</span>
  90 |     | <span class='neutral'>        external</span>
  91 |     | <span class='neutral'>        returns (bytes[] memory value);</span>
  92 |     | <span class='neutral'>    // Records all storage reads and writes</span>
  93 |     | <span class='neutral'>    function record() external;</span>
  94 |     | <span class='neutral'>    // Gets all accessed reads and write slot from a recording session, for a given address</span>
  95 |     | <span class='neutral'>    function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);</span>
  96 |     | <span class='neutral'>    // Gets the _creation_ bytecode from an artifact file. Takes in the relative path to the json file</span>
  97 |     | <span class='neutral'>    function getCode(string calldata artifactPath) external view returns (bytes memory creationBytecode);</span>
  98 |     | <span class='neutral'>    // Gets the _deployed_ bytecode from an artifact file. Takes in the relative path to the json file</span>
  99 |     | <span class='neutral'>    function getDeployedCode(string calldata artifactPath) external view returns (bytes memory runtimeBytecode);</span>
 100 |     | <span class='neutral'>    // Labels an address in call traces</span>
 101 |     | <span class='neutral'>    function label(address account, string calldata newLabel) external;</span>
 102 |     | <span class='neutral'>    // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain</span>
 103 |     | <span class='neutral'>    function broadcast() external;</span>
 104 |     | <span class='neutral'>    // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain</span>
 105 |     | <span class='neutral'>    function broadcast(address signer) external;</span>
 106 |     | <span class='neutral'>    // Has the next call (at this call depth only) create a transaction with the private key provided as the sender that can later be signed and sent onchain</span>
 107 |     | <span class='neutral'>    function broadcast(uint256 privateKey) external;</span>
 108 |     | <span class='neutral'>    // Using the address that calls the test contract, has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain</span>
 109 |     | <span class='neutral'>    function startBroadcast() external;</span>
 110 |     | <span class='neutral'>    // Has all subsequent calls (at this call depth only) create transactions with the address provided that can later be signed and sent onchain</span>
 111 |     | <span class='neutral'>    function startBroadcast(address signer) external;</span>
 112 |     | <span class='neutral'>    // Has all subsequent calls (at this call depth only) create transactions with the private key provided that can later be signed and sent onchain</span>
 113 |     | <span class='neutral'>    function startBroadcast(uint256 privateKey) external;</span>
 114 |     | <span class='neutral'>    // Stops collecting onchain transactions</span>
 115 |     | <span class='neutral'>    function stopBroadcast() external;</span>
 116 |     | <span class='neutral'>    // Reads the entire content of file to string</span>
 117 |     | <span class='neutral'>    function readFile(string calldata path) external view returns (string memory data);</span>
 118 |     | <span class='neutral'>    // Reads the entire content of file as binary. Path is relative to the project root.</span>
 119 |     | <span class='neutral'>    function readFileBinary(string calldata path) external view returns (bytes memory data);</span>
 120 |     | <span class='neutral'>    // Get the path of the current project root</span>
 121 |     | <span class='neutral'>    function projectRoot() external view returns (string memory path);</span>
 122 |     | <span class='neutral'>    // Get the metadata for a file/directory</span>
 123 |     | <span class='neutral'>    function fsMetadata(string calldata fileOrDir) external returns (FsMetadata memory metadata);</span>
 124 |     | <span class='neutral'>    // Reads next line of file to string</span>
 125 |     | <span class='neutral'>    function readLine(string calldata path) external view returns (string memory line);</span>
 126 |     | <span class='neutral'>    // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.</span>
 127 |     | <span class='neutral'>    function writeFile(string calldata path, string calldata data) external;</span>
 128 |     | <span class='neutral'>    // Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.</span>
 129 |     | <span class='neutral'>    // Path is relative to the project root.</span>
 130 |     | <span class='neutral'>    function writeFileBinary(string calldata path, bytes calldata data) external;</span>
 131 |     | <span class='neutral'>    // Writes line to file, creating a file if it does not exist.</span>
 132 |     | <span class='neutral'>    function writeLine(string calldata path, string calldata data) external;</span>
 133 |     | <span class='neutral'>    // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.</span>
 134 |     | <span class='neutral'>    function closeFile(string calldata path) external;</span>
 135 |     | <span class='neutral'>    // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:</span>
 136 |     | <span class='neutral'>    // - Path points to a directory.</span>
 137 |     | <span class='neutral'>    // - The file doesn&#39;t exist.</span>
 138 |     | <span class='neutral'>    // - The user lacks permissions to remove the file.</span>
 139 |     | <span class='neutral'>    function removeFile(string calldata path) external;</span>
 140 |     | <span class='neutral'>    // Convert values to a string</span>
 141 |     | <span class='neutral'>    function toString(address value) external pure returns (string memory stringifiedValue);</span>
 142 |     | <span class='neutral'>    function toString(bytes calldata value) external pure returns (string memory stringifiedValue);</span>
 143 |     | <span class='neutral'>    function toString(bytes32 value) external pure returns (string memory stringifiedValue);</span>
 144 |     | <span class='neutral'>    function toString(bool value) external pure returns (string memory stringifiedValue);</span>
 145 |     | <span class='neutral'>    function toString(uint256 value) external pure returns (string memory stringifiedValue);</span>
 146 |     | <span class='neutral'>    function toString(int256 value) external pure returns (string memory stringifiedValue);</span>
 147 |     | <span class='neutral'>    // Convert values from a string</span>
 148 |     | <span class='neutral'>    function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);</span>
 149 |     | <span class='neutral'>    function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);</span>
 150 |     | <span class='neutral'>    function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);</span>
 151 |     | <span class='neutral'>    function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);</span>
 152 |     | <span class='neutral'>    function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);</span>
 153 |     | <span class='neutral'>    function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);</span>
 154 |     | <span class='neutral'>    // Record all the transaction logs</span>
 155 |     | <span class='neutral'>    function recordLogs() external;</span>
 156 |     | <span class='neutral'>    // Gets all the recorded logs</span>
 157 |     | <span class='neutral'>    function getRecordedLogs() external returns (Log[] memory logs);</span>
 158 |     | <span class='neutral'>    // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44&#39;/60&#39;/0&#39;/0/{index}</span>
 159 |     | <span class='neutral'>    function deriveKey(string calldata mnemonic, uint32 index) external pure returns (uint256 privateKey);</span>
 160 |     | <span class='neutral'>    // Derive a private key from a provided mnenomic string (or mnenomic file path) at {derivationPath}{index}</span>
 161 |     | <span class='neutral'>    function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index)</span>
 162 |     | <span class='neutral'>        external</span>
 163 |     | <span class='neutral'>        pure</span>
 164 |     | <span class='neutral'>        returns (uint256 privateKey);</span>
 165 |     | <span class='neutral'>    // Adds a private key to the local forge wallet and returns the address</span>
 166 |     | <span class='neutral'>    function rememberKey(uint256 privateKey) external returns (address keyAddr);</span>
 167 |     | <span class='neutral'>    //</span>
 168 |     | <span class='neutral'>    // parseJson</span>
 169 |     | <span class='neutral'>    //</span>
 170 |     | <span class='neutral'>    // ----</span>
 171 |     | <span class='neutral'>    // In case the returned value is a JSON object, it&#39;s encoded as a ABI-encoded tuple. As JSON objects</span>
 172 |     | <span class='neutral'>    // don&#39;t have the notion of ordered, but tuples do, they JSON object is encoded with it&#39;s fields ordered in</span>
 173 |     | <span class='neutral'>    // ALPHABETICAL order. That means that in order to successfully decode the tuple, we need to define a tuple that</span>
 174 |     | <span class='neutral'>    // encodes the fields in the same order, which is alphabetical. In the case of Solidity structs, they are encoded</span>
 175 |     | <span class='neutral'>    // as tuples, with the attributes in the order in which they are defined.</span>
 176 |     | <span class='neutral'>    // For example: json = { &#39;a&#39;: 1, &#39;b&#39;: 0xa4tb......3xs}</span>
 177 |     | <span class='neutral'>    // a: uint256</span>
 178 |     | <span class='neutral'>    // b: address</span>
 179 |     | <span class='neutral'>    // To decode that json, we need to define a struct or a tuple as follows:</span>
 180 |     | <span class='neutral'>    // struct json = { uint256 a; address b; }</span>
 181 |     | <span class='neutral'>    // If we defined a json struct with the opposite order, meaning placing the address b first, it would try to</span>
 182 |     | <span class='neutral'>    // decode the tuple in that order, and thus fail.</span>
 183 |     | <span class='neutral'>    // ----</span>
 184 |     | <span class='neutral'>    // Given a string of JSON, return it as ABI-encoded</span>
 185 |     | <span class='neutral'>    function parseJson(string calldata json, string calldata key) external pure returns (bytes memory abiEncodedData);</span>
 186 |     | <span class='neutral'>    function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='neutral'>    // The following parseJson cheatcodes will do type coercion, for the type that they indicate.</span>
 189 |     | <span class='neutral'>    // For example, parseJsonUint will coerce all values to a uint256. That includes stringified numbers &#39;12&#39;</span>
 190 |     | <span class='neutral'>    // and hex numbers &#39;0xEF&#39;.</span>
 191 |     | <span class='neutral'>    // Type coercion works ONLY for discrete values or arrays. That means that the key must return a value or array, not</span>
 192 |     | <span class='neutral'>    // a JSON object.</span>
 193 |     | <span class='neutral'>    function parseJsonUint(string calldata, string calldata) external returns (uint256);</span>
 194 |     | <span class='neutral'>    function parseJsonUintArray(string calldata, string calldata) external returns (uint256[] memory);</span>
 195 |     | <span class='neutral'>    function parseJsonInt(string calldata, string calldata) external returns (int256);</span>
 196 |     | <span class='neutral'>    function parseJsonIntArray(string calldata, string calldata) external returns (int256[] memory);</span>
 197 |     | <span class='neutral'>    function parseJsonBool(string calldata, string calldata) external returns (bool);</span>
 198 |     | <span class='neutral'>    function parseJsonBoolArray(string calldata, string calldata) external returns (bool[] memory);</span>
 199 |     | <span class='neutral'>    function parseJsonAddress(string calldata, string calldata) external returns (address);</span>
 200 |     | <span class='neutral'>    function parseJsonAddressArray(string calldata, string calldata) external returns (address[] memory);</span>
 201 |     | <span class='neutral'>    function parseJsonString(string calldata, string calldata) external returns (string memory);</span>
 202 |     | <span class='neutral'>    function parseJsonStringArray(string calldata, string calldata) external returns (string[] memory);</span>
 203 |     | <span class='neutral'>    function parseJsonBytes(string calldata, string calldata) external returns (bytes memory);</span>
 204 |     | <span class='neutral'>    function parseJsonBytesArray(string calldata, string calldata) external returns (bytes[] memory);</span>
 205 |     | <span class='neutral'>    function parseJsonBytes32(string calldata, string calldata) external returns (bytes32);</span>
 206 |     | <span class='neutral'>    function parseJsonBytes32Array(string calldata, string calldata) external returns (bytes32[] memory);</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>    // Serialize a key and value to a JSON object stored in-memory that can be later written to a file</span>
 209 |     | <span class='neutral'>    // It returns the stringified version of the specific JSON file up to that moment.</span>
 210 |     | <span class='neutral'>    function serializeBool(string calldata objectKey, string calldata valueKey, bool value)</span>
 211 |     | <span class='neutral'>        external</span>
 212 |     | <span class='neutral'>        returns (string memory json);</span>
 213 |     | <span class='neutral'>    function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)</span>
 214 |     | <span class='neutral'>        external</span>
 215 |     | <span class='neutral'>        returns (string memory json);</span>
 216 |     | <span class='neutral'>    function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)</span>
 217 |     | <span class='neutral'>        external</span>
 218 |     | <span class='neutral'>        returns (string memory json);</span>
 219 |     | <span class='neutral'>    function serializeAddress(string calldata objectKey, string calldata valueKey, address value)</span>
 220 |     | <span class='neutral'>        external</span>
 221 |     | <span class='neutral'>        returns (string memory json);</span>
 222 |     | <span class='neutral'>    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)</span>
 223 |     | <span class='neutral'>        external</span>
 224 |     | <span class='neutral'>        returns (string memory json);</span>
 225 |     | <span class='neutral'>    function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)</span>
 226 |     | <span class='neutral'>        external</span>
 227 |     | <span class='neutral'>        returns (string memory json);</span>
 228 |     | <span class='neutral'>    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)</span>
 229 |     | <span class='neutral'>        external</span>
 230 |     | <span class='neutral'>        returns (string memory json);</span>
 231 |     | <span class='neutral'></span>
 232 |     | <span class='neutral'>    function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)</span>
 233 |     | <span class='neutral'>        external</span>
 234 |     | <span class='neutral'>        returns (string memory json);</span>
 235 |     | <span class='neutral'>    function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)</span>
 236 |     | <span class='neutral'>        external</span>
 237 |     | <span class='neutral'>        returns (string memory json);</span>
 238 |     | <span class='neutral'>    function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)</span>
 239 |     | <span class='neutral'>        external</span>
 240 |     | <span class='neutral'>        returns (string memory json);</span>
 241 |     | <span class='neutral'>    function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)</span>
 242 |     | <span class='neutral'>        external</span>
 243 |     | <span class='neutral'>        returns (string memory json);</span>
 244 |     | <span class='neutral'>    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)</span>
 245 |     | <span class='neutral'>        external</span>
 246 |     | <span class='neutral'>        returns (string memory json);</span>
 247 |     | <span class='neutral'>    function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)</span>
 248 |     | <span class='neutral'>        external</span>
 249 |     | <span class='neutral'>        returns (string memory json);</span>
 250 |     | <span class='neutral'>    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)</span>
 251 |     | <span class='neutral'>        external</span>
 252 |     | <span class='neutral'>        returns (string memory json);</span>
 253 |     | <span class='neutral'></span>
 254 |     | <span class='neutral'>    //</span>
 255 |     | <span class='neutral'>    // writeJson</span>
 256 |     | <span class='neutral'>    //</span>
 257 |     | <span class='neutral'>    // ----</span>
 258 |     | <span class='neutral'>    // Write a serialized JSON object to a file. If the file exists, it will be overwritten.</span>
 259 |     | <span class='neutral'>    // Let&#39;s assume we want to write the following JSON to a file:</span>
 260 |     | <span class='neutral'>    //</span>
 261 |     | <span class='neutral'>    // { &quot;boolean&quot;: true, &quot;number&quot;: 342, &quot;object&quot;: { &quot;title&quot;: &quot;finally json serialization&quot; } }</span>
 262 |     | <span class='neutral'>    //</span>
 263 |     | <span class='neutral'>    // ```</span>
 264 |     | <span class='neutral'>    //  string memory json1 = &quot;some key&quot;;</span>
 265 |     | <span class='neutral'>    //  vm.serializeBool(json1, &quot;boolean&quot;, true);</span>
 266 |     | <span class='neutral'>    //  vm.serializeBool(json1, &quot;number&quot;, uint256(342));</span>
 267 |     | <span class='neutral'>    //  json2 = &quot;some other key&quot;;</span>
 268 |     | <span class='neutral'>    //  string memory output = vm.serializeString(json2, &quot;title&quot;, &quot;finally json serialization&quot;);</span>
 269 |     | <span class='neutral'>    //  string memory finalJson = vm.serialize(json1, &quot;object&quot;, output);</span>
 270 |     | <span class='neutral'>    //  vm.writeJson(finalJson, &quot;./output/example.json&quot;);</span>
 271 |     | <span class='neutral'>    // ```</span>
 272 |     | <span class='neutral'>    // The critical insight is that every invocation of serialization will return the stringified version of the JSON</span>
 273 |     | <span class='neutral'>    // up to that point. That means we can construct arbitrary JSON objects and then use the return stringified version</span>
 274 |     | <span class='neutral'>    // to serialize them as values to another JSON object.</span>
 275 |     | <span class='neutral'>    //</span>
 276 |     | <span class='neutral'>    // json1 and json2 are simply keys used by the backend to keep track of the objects. So vm.serializeJson(json1,..)</span>
 277 |     | <span class='neutral'>    // will find the object in-memory that is keyed by &quot;some key&quot;.</span>
 278 |     | <span class='neutral'>    function writeJson(string calldata json, string calldata path) external;</span>
 279 |     | <span class='neutral'>    // Write a serialized JSON object to an **existing** JSON file, replacing a value with key = &lt;value_key&gt;</span>
 280 |     | <span class='neutral'>    // This is useful to replace a specific value of a JSON file, without having to parse the entire thing</span>
 281 |     | <span class='neutral'>    function writeJson(string calldata json, string calldata path, string calldata valueKey) external;</span>
 282 |     | <span class='neutral'>    // Returns the RPC url for the given alias</span>
 283 |     | <span class='neutral'>    function rpcUrl(string calldata rpcAlias) external view returns (string memory json);</span>
 284 |     | <span class='neutral'>    // Returns all rpc urls and their aliases `[alias, url][]`</span>
 285 |     | <span class='neutral'>    function rpcUrls() external view returns (string[2][] memory urls);</span>
 286 |     | <span class='neutral'>    // Returns all rpc urls and their aliases as structs.</span>
 287 |     | <span class='neutral'>    function rpcUrlStructs() external view returns (Rpc[] memory urls);</span>
 288 |     | <span class='neutral'>    // If the condition is false, discard this run&#39;s fuzz inputs and generate new ones.</span>
 289 |     | <span class='neutral'>    function assume(bool condition) external pure;</span>
 290 |     | <span class='neutral'>    // Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.</span>
 291 |     | <span class='neutral'>    function pauseGasMetering() external;</span>
 292 |     | <span class='neutral'>    // Resumes gas metering (i.e. gas usage is counted again). Noop if already on.</span>
 293 |     | <span class='neutral'>    function resumeGasMetering() external;</span>
 294 |     | <span class='neutral'>}</span>
 295 |     | <span class='neutral'></span>
 296 |     | <span class='neutral'>interface Vm is VmSafe {</span>
 297 |     | <span class='neutral'>    // Sets block.timestamp</span>
 298 |     | <span class='neutral'>    function warp(uint256 newTimestamp) external;</span>
 299 |     | <span class='neutral'>    // Sets block.height</span>
 300 |     | <span class='neutral'>    function roll(uint256 newHeight) external;</span>
 301 |     | <span class='neutral'>    // Sets block.basefee</span>
 302 |     | <span class='neutral'>    function fee(uint256 newBasefee) external;</span>
 303 |     | <span class='neutral'>    // Sets block.difficulty</span>
 304 |     | <span class='neutral'>    function difficulty(uint256 newDifficulty) external;</span>
 305 |     | <span class='neutral'>    // Sets block.chainid</span>
 306 |     | <span class='neutral'>    function chainId(uint256 newChainId) external;</span>
 307 |     | <span class='neutral'>    // Stores a value to an address&#39; storage slot.</span>
 308 |     | <span class='neutral'>    function store(address target, bytes32 slot, bytes32 value) external;</span>
 309 |     | <span class='neutral'>    // Sets the nonce of an account; must be higher than the current nonce of the account</span>
 310 |     | <span class='neutral'>    function setNonce(address account, uint64 newNonce) external;</span>
 311 |     | <span class='neutral'>    // Sets the *next* call&#39;s msg.sender to be the input address</span>
 312 |     | <span class='neutral'>    function prank(address msgSender) external;</span>
 313 |     | <span class='neutral'>    // Sets all subsequent calls&#39; msg.sender to be the input address until `stopPrank` is called</span>
 314 |     | <span class='neutral'>    function startPrank(address msgSender) external;</span>
 315 |     | <span class='neutral'>    // Sets the *next* call&#39;s msg.sender to be the input address, and the tx.origin to be the second input</span>
 316 |     | <span class='neutral'>    function prank(address msgSender, address txOrigin) external;</span>
 317 |     | <span class='neutral'>    // Sets all subsequent calls&#39; msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input</span>
 318 |     | <span class='neutral'>    function startPrank(address msgSender, address txOrigin) external;</span>
 319 |     | <span class='neutral'>    // Resets subsequent calls&#39; msg.sender to be `address(this)`</span>
 320 |     | <span class='neutral'>    function stopPrank() external;</span>
 321 |     | <span class='neutral'>    // Sets an address&#39; balance</span>
 322 |     | <span class='neutral'>    function deal(address account, uint256 newBalance) external;</span>
 323 |     | <span class='neutral'>    // Sets an address&#39; code</span>
 324 |     | <span class='neutral'>    function etch(address target, bytes calldata newRuntimeBytecode) external;</span>
 325 |     | <span class='neutral'>    // Expects an error on next call</span>
 326 |     | <span class='neutral'>    function expectRevert(bytes calldata revertData) external;</span>
 327 |     | <span class='neutral'>    function expectRevert(bytes4 revertData) external;</span>
 328 |     | <span class='neutral'>    function expectRevert() external;</span>
 329 |     | <span class='neutral'>    // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).</span>
 330 |     | <span class='neutral'>    // Call this function, then emit an event, then call a function. Internally after the call, we check if</span>
 331 |     | <span class='neutral'>    // logs were emitted in the expected order with the expected topics and data (as specified by the booleans)</span>
 332 |     | <span class='neutral'>    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData) external;</span>
 333 |     | <span class='neutral'>    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter)</span>
 334 |     | <span class='neutral'>        external;</span>
 335 |     | <span class='neutral'>    // Mocks a call to an address, returning specified data.</span>
 336 |     | <span class='neutral'>    // Calldata can either be strict or a partial match, e.g. if you only</span>
 337 |     | <span class='neutral'>    // pass a Solidity selector to the expected calldata, then the entire Solidity</span>
 338 |     | <span class='neutral'>    // function will be mocked.</span>
 339 |     | <span class='neutral'>    function mockCall(address callee, bytes calldata data, bytes calldata returnData) external;</span>
 340 |     | <span class='neutral'>    // Mocks a call to an address with a specific msg.value, returning specified data.</span>
 341 |     | <span class='neutral'>    // Calldata match takes precedence over msg.value in case of ambiguity.</span>
 342 |     | <span class='neutral'>    function mockCall(address callee, uint256 msgValue, bytes calldata data, bytes calldata returnData) external;</span>
 343 |     | <span class='neutral'>    // Clears all mocked calls</span>
 344 |     | <span class='neutral'>    function clearMockedCalls() external;</span>
 345 |     | <span class='neutral'>    // Expects a call to an address with the specified calldata.</span>
 346 |     | <span class='neutral'>    // Calldata can either be a strict or a partial match</span>
 347 |     | <span class='neutral'>    function expectCall(address callee, bytes calldata data) external;</span>
 348 |     | <span class='neutral'>    // Expects a call to an address with the specified msg.value and calldata</span>
 349 |     | <span class='neutral'>    function expectCall(address callee, uint256 msgValue, bytes calldata data) external;</span>
 350 |     | <span class='neutral'>    // Expect a call to an address with the specified msg.value, gas, and calldata.</span>
 351 |     | <span class='neutral'>    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data) external;</span>
 352 |     | <span class='neutral'>    // Expect a call to an address with the specified msg.value and calldata, and a *minimum* amount of gas.</span>
 353 |     | <span class='neutral'>    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data) external;</span>
 354 |     | <span class='neutral'>    // Sets block.coinbase</span>
 355 |     | <span class='neutral'>    function coinbase(address newCoinbase) external;</span>
 356 |     | <span class='neutral'>    // Snapshot the current state of the evm.</span>
 357 |     | <span class='neutral'>    // Returns the id of the snapshot that was created.</span>
 358 |     | <span class='neutral'>    // To revert a snapshot use `revertTo`</span>
 359 |     | <span class='neutral'>    function snapshot() external returns (uint256 snapshotId);</span>
 360 |     | <span class='neutral'>    // Revert the state of the EVM to a previous snapshot</span>
 361 |     | <span class='neutral'>    // Takes the snapshot id to revert to.</span>
 362 |     | <span class='neutral'>    // This deletes the snapshot and all snapshots taken after the given snapshot id.</span>
 363 |     | <span class='neutral'>    function revertTo(uint256 snapshotId) external returns (bool success);</span>
 364 |     | <span class='neutral'>    // Creates a new fork with the given endpoint and block and returns the identifier of the fork</span>
 365 |     | <span class='neutral'>    function createFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);</span>
 366 |     | <span class='neutral'>    // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork</span>
 367 |     | <span class='neutral'>    function createFork(string calldata urlOrAlias) external returns (uint256 forkId);</span>
 368 |     | <span class='neutral'>    // Creates a new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before the transaction,</span>
 369 |     | <span class='neutral'>    // and returns the identifier of the fork</span>
 370 |     | <span class='neutral'>    function createFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);</span>
 371 |     | <span class='neutral'>    // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork</span>
 372 |     | <span class='neutral'>    function createSelectFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);</span>
 373 |     | <span class='neutral'>    // Creates _and_ also selects new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before</span>
 374 |     | <span class='neutral'>    // the transaction, returns the identifier of the fork</span>
 375 |     | <span class='neutral'>    function createSelectFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);</span>
 376 |     | <span class='neutral'>    // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork</span>
 377 |     | <span class='neutral'>    function createSelectFork(string calldata urlOrAlias) external returns (uint256 forkId);</span>
 378 |     | <span class='neutral'>    // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.</span>
 379 |     | <span class='neutral'>    function selectFork(uint256 forkId) external;</span>
 380 |     | <span class='neutral'>    /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.</span>
 381 |     | <span class='neutral'>    function activeFork() external view returns (uint256 forkId);</span>
 382 |     | <span class='neutral'>    // Updates the currently active fork to given block number</span>
 383 |     | <span class='neutral'>    // This is similar to `roll` but for the currently active fork</span>
 384 |     | <span class='neutral'>    function rollFork(uint256 blockNumber) external;</span>
 385 |     | <span class='neutral'>    // Updates the currently active fork to given transaction</span>
 386 |     | <span class='neutral'>    // this will `rollFork` with the number of the block the transaction was mined in and replays all transaction mined before it in the block</span>
 387 |     | <span class='neutral'>    function rollFork(bytes32 txHash) external;</span>
 388 |     | <span class='neutral'>    // Updates the given fork to given block number</span>
 389 |     | <span class='neutral'>    function rollFork(uint256 forkId, uint256 blockNumber) external;</span>
 390 |     | <span class='neutral'>    // Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block</span>
 391 |     | <span class='neutral'>    function rollFork(uint256 forkId, bytes32 txHash) external;</span>
 392 |     | <span class='neutral'>    // Marks that the account(s) should use persistent storage across fork swaps in a multifork setup</span>
 393 |     | <span class='neutral'>    // Meaning, changes made to the state of this account will be kept when switching forks</span>
 394 |     | <span class='neutral'>    function makePersistent(address account) external;</span>
 395 |     | <span class='neutral'>    function makePersistent(address account0, address account1) external;</span>
 396 |     | <span class='neutral'>    function makePersistent(address account0, address account1, address account2) external;</span>
 397 |     | <span class='neutral'>    function makePersistent(address[] calldata accounts) external;</span>
 398 |     | <span class='neutral'>    // Revokes persistent status from the address, previously added via `makePersistent`</span>
 399 |     | <span class='neutral'>    function revokePersistent(address account) external;</span>
 400 |     | <span class='neutral'>    function revokePersistent(address[] calldata accounts) external;</span>
 401 |     | <span class='neutral'>    // Returns true if the account is marked as persistent</span>
 402 |     | <span class='neutral'>    function isPersistent(address account) external view returns (bool persistent);</span>
 403 |     | <span class='neutral'>    // In forking mode, explicitly grant the given address cheatcode access</span>
 404 |     | <span class='neutral'>    function allowCheatcodes(address account) external;</span>
 405 |     | <span class='neutral'>    // Fetches the given transaction from the active fork and executes it on the current state</span>
 406 |     | <span class='neutral'>    function transact(bytes32 txHash) external;</span>
 407 |     | <span class='neutral'>    // Fetches the given transaction from the given fork and executes it on the current state</span>
 408 |     | <span class='neutral'>    function transact(uint256 forkId, bytes32 txHash) external;</span>
 409 |     | <span class='neutral'>}</span>
 410 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/forge-std/src/console.sol</b>
<code>
    1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
    2 |     | <span class='neutral'>pragma solidity &gt;=0.4.22 &lt;0.9.0;</span>
    3 |     | <span class='unexecuted'></span>
    4 |     | <span class='neutral'>library console {</span>
    5 |     | <span class='neutral'>    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);</span>
    6 |     | <span class='neutral'></span>
    7 |     | <span class='neutral'>    function _sendLogPayload(bytes memory payload) private view {</span>
    8 |     | <span class='neutral'>        uint256 payloadLength = payload.length;</span>
    9 |     | <span class='neutral'>        address consoleAddress = CONSOLE_ADDRESS;</span>
   10 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   11 |     | <span class='neutral'>        assembly {</span>
   12 |     | <span class='neutral'>            let payloadStart := add(payload, 32)</span>
   13 |     | <span class='neutral'>            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)</span>
   14 |     | <span class='neutral'>        }</span>
   15 |     | <span class='neutral'>    }</span>
   16 |     | <span class='neutral'></span>
   17 |     | <span class='neutral'>    function log() internal view {</span>
   18 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log()&quot;));</span>
   19 |     | <span class='neutral'>    }</span>
   20 |     | <span class='neutral'></span>
   21 |     | <span class='neutral'>    function logInt(int p0) internal view {</span>
   22 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(int)&quot;, p0));</span>
   23 |     | <span class='neutral'>    }</span>
   24 |     | <span class='neutral'></span>
   25 |     | <span class='neutral'>    function logUint(uint p0) internal view {</span>
   26 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint)&quot;, p0));</span>
   27 |     | <span class='neutral'>    }</span>
   28 |     | <span class='neutral'></span>
   29 |     | <span class='neutral'>    function logString(string memory p0) internal view {</span>
   30 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
   31 |     | <span class='neutral'>    }</span>
   32 |     | <span class='neutral'></span>
   33 |     | <span class='neutral'>    function logBool(bool p0) internal view {</span>
   34 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool)&quot;, p0));</span>
   35 |     | <span class='neutral'>    }</span>
   36 |     | <span class='neutral'></span>
   37 |     | <span class='neutral'>    function logAddress(address p0) internal view {</span>
   38 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address)&quot;, p0));</span>
   39 |     | <span class='neutral'>    }</span>
   40 |     | <span class='neutral'></span>
   41 |     | <span class='neutral'>    function logBytes(bytes memory p0) internal view {</span>
   42 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes)&quot;, p0));</span>
   43 |     | <span class='neutral'>    }</span>
   44 |     | <span class='neutral'></span>
   45 |     | <span class='neutral'>    function logBytes1(bytes1 p0) internal view {</span>
   46 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes1)&quot;, p0));</span>
   47 |     | <span class='neutral'>    }</span>
   48 |     | <span class='neutral'></span>
   49 |     | <span class='neutral'>    function logBytes2(bytes2 p0) internal view {</span>
   50 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes2)&quot;, p0));</span>
   51 |     | <span class='neutral'>    }</span>
   52 |     | <span class='neutral'></span>
   53 |     | <span class='neutral'>    function logBytes3(bytes3 p0) internal view {</span>
   54 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes3)&quot;, p0));</span>
   55 |     | <span class='neutral'>    }</span>
   56 |     | <span class='neutral'></span>
   57 |     | <span class='neutral'>    function logBytes4(bytes4 p0) internal view {</span>
   58 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes4)&quot;, p0));</span>
   59 |     | <span class='neutral'>    }</span>
   60 |     | <span class='neutral'></span>
   61 |     | <span class='neutral'>    function logBytes5(bytes5 p0) internal view {</span>
   62 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes5)&quot;, p0));</span>
   63 |     | <span class='neutral'>    }</span>
   64 |     | <span class='neutral'></span>
   65 |     | <span class='neutral'>    function logBytes6(bytes6 p0) internal view {</span>
   66 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes6)&quot;, p0));</span>
   67 |     | <span class='neutral'>    }</span>
   68 |     | <span class='neutral'></span>
   69 |     | <span class='neutral'>    function logBytes7(bytes7 p0) internal view {</span>
   70 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes7)&quot;, p0));</span>
   71 |     | <span class='neutral'>    }</span>
   72 |     | <span class='neutral'></span>
   73 |     | <span class='neutral'>    function logBytes8(bytes8 p0) internal view {</span>
   74 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes8)&quot;, p0));</span>
   75 |     | <span class='neutral'>    }</span>
   76 |     | <span class='neutral'></span>
   77 |     | <span class='neutral'>    function logBytes9(bytes9 p0) internal view {</span>
   78 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes9)&quot;, p0));</span>
   79 |     | <span class='neutral'>    }</span>
   80 |     | <span class='neutral'></span>
   81 |     | <span class='neutral'>    function logBytes10(bytes10 p0) internal view {</span>
   82 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes10)&quot;, p0));</span>
   83 |     | <span class='neutral'>    }</span>
   84 |     | <span class='neutral'></span>
   85 |     | <span class='neutral'>    function logBytes11(bytes11 p0) internal view {</span>
   86 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes11)&quot;, p0));</span>
   87 |     | <span class='neutral'>    }</span>
   88 |     | <span class='neutral'></span>
   89 |     | <span class='neutral'>    function logBytes12(bytes12 p0) internal view {</span>
   90 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes12)&quot;, p0));</span>
   91 |     | <span class='neutral'>    }</span>
   92 |     | <span class='neutral'></span>
   93 |     | <span class='neutral'>    function logBytes13(bytes13 p0) internal view {</span>
   94 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes13)&quot;, p0));</span>
   95 |     | <span class='neutral'>    }</span>
   96 |     | <span class='neutral'></span>
   97 |     | <span class='neutral'>    function logBytes14(bytes14 p0) internal view {</span>
   98 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes14)&quot;, p0));</span>
   99 |     | <span class='neutral'>    }</span>
  100 |     | <span class='neutral'></span>
  101 |     | <span class='neutral'>    function logBytes15(bytes15 p0) internal view {</span>
  102 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes15)&quot;, p0));</span>
  103 |     | <span class='neutral'>    }</span>
  104 |     | <span class='neutral'></span>
  105 |     | <span class='neutral'>    function logBytes16(bytes16 p0) internal view {</span>
  106 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes16)&quot;, p0));</span>
  107 |     | <span class='neutral'>    }</span>
  108 |     | <span class='neutral'></span>
  109 |     | <span class='neutral'>    function logBytes17(bytes17 p0) internal view {</span>
  110 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes17)&quot;, p0));</span>
  111 |     | <span class='neutral'>    }</span>
  112 |     | <span class='neutral'></span>
  113 |     | <span class='neutral'>    function logBytes18(bytes18 p0) internal view {</span>
  114 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes18)&quot;, p0));</span>
  115 |     | <span class='neutral'>    }</span>
  116 |     | <span class='neutral'></span>
  117 |     | <span class='neutral'>    function logBytes19(bytes19 p0) internal view {</span>
  118 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes19)&quot;, p0));</span>
  119 |     | <span class='neutral'>    }</span>
  120 |     | <span class='neutral'></span>
  121 |     | <span class='neutral'>    function logBytes20(bytes20 p0) internal view {</span>
  122 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes20)&quot;, p0));</span>
  123 |     | <span class='neutral'>    }</span>
  124 |     | <span class='neutral'></span>
  125 |     | <span class='neutral'>    function logBytes21(bytes21 p0) internal view {</span>
  126 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes21)&quot;, p0));</span>
  127 |     | <span class='neutral'>    }</span>
  128 |     | <span class='neutral'></span>
  129 |     | <span class='neutral'>    function logBytes22(bytes22 p0) internal view {</span>
  130 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes22)&quot;, p0));</span>
  131 |     | <span class='neutral'>    }</span>
  132 |     | <span class='neutral'></span>
  133 |     | <span class='neutral'>    function logBytes23(bytes23 p0) internal view {</span>
  134 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes23)&quot;, p0));</span>
  135 |     | <span class='neutral'>    }</span>
  136 |     | <span class='neutral'></span>
  137 |     | <span class='neutral'>    function logBytes24(bytes24 p0) internal view {</span>
  138 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes24)&quot;, p0));</span>
  139 |     | <span class='neutral'>    }</span>
  140 |     | <span class='neutral'></span>
  141 |     | <span class='neutral'>    function logBytes25(bytes25 p0) internal view {</span>
  142 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes25)&quot;, p0));</span>
  143 |     | <span class='neutral'>    }</span>
  144 |     | <span class='neutral'></span>
  145 |     | <span class='neutral'>    function logBytes26(bytes26 p0) internal view {</span>
  146 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes26)&quot;, p0));</span>
  147 |     | <span class='neutral'>    }</span>
  148 |     | <span class='neutral'></span>
  149 |     | <span class='neutral'>    function logBytes27(bytes27 p0) internal view {</span>
  150 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes27)&quot;, p0));</span>
  151 |     | <span class='neutral'>    }</span>
  152 |     | <span class='neutral'></span>
  153 |     | <span class='neutral'>    function logBytes28(bytes28 p0) internal view {</span>
  154 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes28)&quot;, p0));</span>
  155 |     | <span class='neutral'>    }</span>
  156 |     | <span class='neutral'></span>
  157 |     | <span class='neutral'>    function logBytes29(bytes29 p0) internal view {</span>
  158 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes29)&quot;, p0));</span>
  159 |     | <span class='neutral'>    }</span>
  160 |     | <span class='neutral'></span>
  161 |     | <span class='neutral'>    function logBytes30(bytes30 p0) internal view {</span>
  162 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes30)&quot;, p0));</span>
  163 |     | <span class='neutral'>    }</span>
  164 |     | <span class='neutral'></span>
  165 |     | <span class='neutral'>    function logBytes31(bytes31 p0) internal view {</span>
  166 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes31)&quot;, p0));</span>
  167 |     | <span class='neutral'>    }</span>
  168 |     | <span class='neutral'></span>
  169 |     | <span class='neutral'>    function logBytes32(bytes32 p0) internal view {</span>
  170 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes32)&quot;, p0));</span>
  171 |     | <span class='neutral'>    }</span>
  172 |     | <span class='neutral'></span>
  173 |     | <span class='neutral'>    function log(uint p0) internal view {</span>
  174 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint)&quot;, p0));</span>
  175 |     | <span class='neutral'>    }</span>
  176 |     | <span class='neutral'></span>
  177 |     | <span class='neutral'>    function log(string memory p0) internal view {</span>
  178 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
  179 |     | <span class='neutral'>    }</span>
  180 |     | <span class='neutral'></span>
  181 |     | <span class='neutral'>    function log(bool p0) internal view {</span>
  182 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool)&quot;, p0));</span>
  183 |     | <span class='neutral'>    }</span>
  184 |     | <span class='neutral'></span>
  185 |     | <span class='neutral'>    function log(address p0) internal view {</span>
  186 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address)&quot;, p0));</span>
  187 |     | <span class='neutral'>    }</span>
  188 |     | <span class='neutral'></span>
  189 |     | <span class='neutral'>    function log(uint p0, uint p1) internal view {</span>
  190 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint)&quot;, p0, p1));</span>
  191 |     | <span class='neutral'>    }</span>
  192 |     | <span class='neutral'></span>
  193 |     | <span class='neutral'>    function log(uint p0, string memory p1) internal view {</span>
  194 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string)&quot;, p0, p1));</span>
  195 |     | <span class='neutral'>    }</span>
  196 |     | <span class='neutral'></span>
  197 |     | <span class='neutral'>    function log(uint p0, bool p1) internal view {</span>
  198 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool)&quot;, p0, p1));</span>
  199 |     | <span class='neutral'>    }</span>
  200 |     | <span class='neutral'></span>
  201 |     | <span class='neutral'>    function log(uint p0, address p1) internal view {</span>
  202 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address)&quot;, p0, p1));</span>
  203 |     | <span class='neutral'>    }</span>
  204 |     | <span class='neutral'></span>
  205 |     | <span class='neutral'>    function log(string memory p0, uint p1) internal view {</span>
  206 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint)&quot;, p0, p1));</span>
  207 |     | <span class='neutral'>    }</span>
  208 |     | <span class='neutral'></span>
  209 |     | <span class='neutral'>    function log(string memory p0, string memory p1) internal view {</span>
  210 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string)&quot;, p0, p1));</span>
  211 |     | <span class='neutral'>    }</span>
  212 |     | <span class='neutral'></span>
  213 |     | <span class='neutral'>    function log(string memory p0, bool p1) internal view {</span>
  214 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool)&quot;, p0, p1));</span>
  215 |     | <span class='neutral'>    }</span>
  216 |     | <span class='neutral'></span>
  217 |     | <span class='neutral'>    function log(string memory p0, address p1) internal view {</span>
  218 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address)&quot;, p0, p1));</span>
  219 |     | <span class='neutral'>    }</span>
  220 |     | <span class='neutral'></span>
  221 |     | <span class='neutral'>    function log(bool p0, uint p1) internal view {</span>
  222 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint)&quot;, p0, p1));</span>
  223 |     | <span class='neutral'>    }</span>
  224 |     | <span class='neutral'></span>
  225 |     | <span class='neutral'>    function log(bool p0, string memory p1) internal view {</span>
  226 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string)&quot;, p0, p1));</span>
  227 |     | <span class='neutral'>    }</span>
  228 |     | <span class='neutral'></span>
  229 |     | <span class='neutral'>    function log(bool p0, bool p1) internal view {</span>
  230 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool)&quot;, p0, p1));</span>
  231 |     | <span class='neutral'>    }</span>
  232 |     | <span class='neutral'></span>
  233 |     | <span class='neutral'>    function log(bool p0, address p1) internal view {</span>
  234 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address)&quot;, p0, p1));</span>
  235 |     | <span class='neutral'>    }</span>
  236 |     | <span class='neutral'></span>
  237 |     | <span class='neutral'>    function log(address p0, uint p1) internal view {</span>
  238 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint)&quot;, p0, p1));</span>
  239 |     | <span class='neutral'>    }</span>
  240 |     | <span class='neutral'></span>
  241 |     | <span class='neutral'>    function log(address p0, string memory p1) internal view {</span>
  242 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string)&quot;, p0, p1));</span>
  243 |     | <span class='neutral'>    }</span>
  244 |     | <span class='neutral'></span>
  245 |     | <span class='neutral'>    function log(address p0, bool p1) internal view {</span>
  246 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool)&quot;, p0, p1));</span>
  247 |     | <span class='neutral'>    }</span>
  248 |     | <span class='neutral'></span>
  249 |     | <span class='neutral'>    function log(address p0, address p1) internal view {</span>
  250 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address)&quot;, p0, p1));</span>
  251 |     | <span class='neutral'>    }</span>
  252 |     | <span class='neutral'></span>
  253 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2) internal view {</span>
  254 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint)&quot;, p0, p1, p2));</span>
  255 |     | <span class='neutral'>    }</span>
  256 |     | <span class='neutral'></span>
  257 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2) internal view {</span>
  258 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string)&quot;, p0, p1, p2));</span>
  259 |     | <span class='neutral'>    }</span>
  260 |     | <span class='neutral'></span>
  261 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2) internal view {</span>
  262 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool)&quot;, p0, p1, p2));</span>
  263 |     | <span class='neutral'>    }</span>
  264 |     | <span class='neutral'></span>
  265 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2) internal view {</span>
  266 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address)&quot;, p0, p1, p2));</span>
  267 |     | <span class='neutral'>    }</span>
  268 |     | <span class='neutral'></span>
  269 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2) internal view {</span>
  270 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint)&quot;, p0, p1, p2));</span>
  271 |     | <span class='neutral'>    }</span>
  272 |     | <span class='neutral'></span>
  273 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2) internal view {</span>
  274 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string)&quot;, p0, p1, p2));</span>
  275 |     | <span class='neutral'>    }</span>
  276 |     | <span class='neutral'></span>
  277 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2) internal view {</span>
  278 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool)&quot;, p0, p1, p2));</span>
  279 |     | <span class='neutral'>    }</span>
  280 |     | <span class='neutral'></span>
  281 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2) internal view {</span>
  282 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address)&quot;, p0, p1, p2));</span>
  283 |     | <span class='neutral'>    }</span>
  284 |     | <span class='neutral'></span>
  285 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2) internal view {</span>
  286 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint)&quot;, p0, p1, p2));</span>
  287 |     | <span class='neutral'>    }</span>
  288 |     | <span class='neutral'></span>
  289 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2) internal view {</span>
  290 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string)&quot;, p0, p1, p2));</span>
  291 |     | <span class='neutral'>    }</span>
  292 |     | <span class='neutral'></span>
  293 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2) internal view {</span>
  294 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool)&quot;, p0, p1, p2));</span>
  295 |     | <span class='neutral'>    }</span>
  296 |     | <span class='neutral'></span>
  297 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2) internal view {</span>
  298 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address)&quot;, p0, p1, p2));</span>
  299 |     | <span class='neutral'>    }</span>
  300 |     | <span class='neutral'></span>
  301 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2) internal view {</span>
  302 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint)&quot;, p0, p1, p2));</span>
  303 |     | <span class='neutral'>    }</span>
  304 |     | <span class='neutral'></span>
  305 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2) internal view {</span>
  306 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string)&quot;, p0, p1, p2));</span>
  307 |     | <span class='neutral'>    }</span>
  308 |     | <span class='neutral'></span>
  309 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2) internal view {</span>
  310 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool)&quot;, p0, p1, p2));</span>
  311 |     | <span class='neutral'>    }</span>
  312 |     | <span class='neutral'></span>
  313 |     | <span class='neutral'>    function log(uint p0, address p1, address p2) internal view {</span>
  314 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address)&quot;, p0, p1, p2));</span>
  315 |     | <span class='neutral'>    }</span>
  316 |     | <span class='neutral'></span>
  317 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2) internal view {</span>
  318 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint)&quot;, p0, p1, p2));</span>
  319 |     | <span class='neutral'>    }</span>
  320 |     | <span class='neutral'></span>
  321 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2) internal view {</span>
  322 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string)&quot;, p0, p1, p2));</span>
  323 |     | <span class='neutral'>    }</span>
  324 |     | <span class='neutral'></span>
  325 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2) internal view {</span>
  326 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool)&quot;, p0, p1, p2));</span>
  327 |     | <span class='neutral'>    }</span>
  328 |     | <span class='neutral'></span>
  329 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2) internal view {</span>
  330 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address)&quot;, p0, p1, p2));</span>
  331 |     | <span class='neutral'>    }</span>
  332 |     | <span class='neutral'></span>
  333 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2) internal view {</span>
  334 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint)&quot;, p0, p1, p2));</span>
  335 |     | <span class='neutral'>    }</span>
  336 |     | <span class='neutral'></span>
  337 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2) internal view {</span>
  338 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string)&quot;, p0, p1, p2));</span>
  339 |     | <span class='neutral'>    }</span>
  340 |     | <span class='neutral'></span>
  341 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2) internal view {</span>
  342 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool)&quot;, p0, p1, p2));</span>
  343 |     | <span class='neutral'>    }</span>
  344 |     | <span class='neutral'></span>
  345 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2) internal view {</span>
  346 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address)&quot;, p0, p1, p2));</span>
  347 |     | <span class='neutral'>    }</span>
  348 |     | <span class='neutral'></span>
  349 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2) internal view {</span>
  350 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint)&quot;, p0, p1, p2));</span>
  351 |     | <span class='neutral'>    }</span>
  352 |     | <span class='neutral'></span>
  353 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2) internal view {</span>
  354 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string)&quot;, p0, p1, p2));</span>
  355 |     | <span class='neutral'>    }</span>
  356 |     | <span class='neutral'></span>
  357 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2) internal view {</span>
  358 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool)&quot;, p0, p1, p2));</span>
  359 |     | <span class='neutral'>    }</span>
  360 |     | <span class='neutral'></span>
  361 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2) internal view {</span>
  362 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address)&quot;, p0, p1, p2));</span>
  363 |     | <span class='neutral'>    }</span>
  364 |     | <span class='neutral'></span>
  365 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2) internal view {</span>
  366 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint)&quot;, p0, p1, p2));</span>
  367 |     | <span class='neutral'>    }</span>
  368 |     | <span class='neutral'></span>
  369 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2) internal view {</span>
  370 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string)&quot;, p0, p1, p2));</span>
  371 |     | <span class='neutral'>    }</span>
  372 |     | <span class='neutral'></span>
  373 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2) internal view {</span>
  374 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool)&quot;, p0, p1, p2));</span>
  375 |     | <span class='neutral'>    }</span>
  376 |     | <span class='neutral'></span>
  377 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2) internal view {</span>
  378 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address)&quot;, p0, p1, p2));</span>
  379 |     | <span class='neutral'>    }</span>
  380 |     | <span class='neutral'></span>
  381 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2) internal view {</span>
  382 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint)&quot;, p0, p1, p2));</span>
  383 |     | <span class='neutral'>    }</span>
  384 |     | <span class='neutral'></span>
  385 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2) internal view {</span>
  386 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string)&quot;, p0, p1, p2));</span>
  387 |     | <span class='neutral'>    }</span>
  388 |     | <span class='neutral'></span>
  389 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2) internal view {</span>
  390 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool)&quot;, p0, p1, p2));</span>
  391 |     | <span class='neutral'>    }</span>
  392 |     | <span class='neutral'></span>
  393 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2) internal view {</span>
  394 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address)&quot;, p0, p1, p2));</span>
  395 |     | <span class='neutral'>    }</span>
  396 |     | <span class='neutral'></span>
  397 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2) internal view {</span>
  398 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint)&quot;, p0, p1, p2));</span>
  399 |     | <span class='neutral'>    }</span>
  400 |     | <span class='neutral'></span>
  401 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2) internal view {</span>
  402 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string)&quot;, p0, p1, p2));</span>
  403 |     | <span class='neutral'>    }</span>
  404 |     | <span class='neutral'></span>
  405 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2) internal view {</span>
  406 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool)&quot;, p0, p1, p2));</span>
  407 |     | <span class='neutral'>    }</span>
  408 |     | <span class='neutral'></span>
  409 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2) internal view {</span>
  410 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address)&quot;, p0, p1, p2));</span>
  411 |     | <span class='neutral'>    }</span>
  412 |     | <span class='neutral'></span>
  413 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2) internal view {</span>
  414 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint)&quot;, p0, p1, p2));</span>
  415 |     | <span class='neutral'>    }</span>
  416 |     | <span class='neutral'></span>
  417 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2) internal view {</span>
  418 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string)&quot;, p0, p1, p2));</span>
  419 |     | <span class='neutral'>    }</span>
  420 |     | <span class='neutral'></span>
  421 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2) internal view {</span>
  422 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool)&quot;, p0, p1, p2));</span>
  423 |     | <span class='neutral'>    }</span>
  424 |     | <span class='neutral'></span>
  425 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2) internal view {</span>
  426 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address)&quot;, p0, p1, p2));</span>
  427 |     | <span class='neutral'>    }</span>
  428 |     | <span class='neutral'></span>
  429 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2) internal view {</span>
  430 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint)&quot;, p0, p1, p2));</span>
  431 |     | <span class='neutral'>    }</span>
  432 |     | <span class='neutral'></span>
  433 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2) internal view {</span>
  434 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string)&quot;, p0, p1, p2));</span>
  435 |     | <span class='neutral'>    }</span>
  436 |     | <span class='neutral'></span>
  437 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2) internal view {</span>
  438 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool)&quot;, p0, p1, p2));</span>
  439 |     | <span class='neutral'>    }</span>
  440 |     | <span class='neutral'></span>
  441 |     | <span class='neutral'>    function log(bool p0, address p1, address p2) internal view {</span>
  442 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address)&quot;, p0, p1, p2));</span>
  443 |     | <span class='neutral'>    }</span>
  444 |     | <span class='neutral'></span>
  445 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2) internal view {</span>
  446 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint)&quot;, p0, p1, p2));</span>
  447 |     | <span class='neutral'>    }</span>
  448 |     | <span class='neutral'></span>
  449 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2) internal view {</span>
  450 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string)&quot;, p0, p1, p2));</span>
  451 |     | <span class='neutral'>    }</span>
  452 |     | <span class='neutral'></span>
  453 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2) internal view {</span>
  454 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool)&quot;, p0, p1, p2));</span>
  455 |     | <span class='neutral'>    }</span>
  456 |     | <span class='neutral'></span>
  457 |     | <span class='neutral'>    function log(address p0, uint p1, address p2) internal view {</span>
  458 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address)&quot;, p0, p1, p2));</span>
  459 |     | <span class='neutral'>    }</span>
  460 |     | <span class='neutral'></span>
  461 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2) internal view {</span>
  462 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint)&quot;, p0, p1, p2));</span>
  463 |     | <span class='neutral'>    }</span>
  464 |     | <span class='neutral'></span>
  465 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2) internal view {</span>
  466 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string)&quot;, p0, p1, p2));</span>
  467 |     | <span class='neutral'>    }</span>
  468 |     | <span class='neutral'></span>
  469 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2) internal view {</span>
  470 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool)&quot;, p0, p1, p2));</span>
  471 |     | <span class='neutral'>    }</span>
  472 |     | <span class='neutral'></span>
  473 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2) internal view {</span>
  474 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address)&quot;, p0, p1, p2));</span>
  475 |     | <span class='neutral'>    }</span>
  476 |     | <span class='neutral'></span>
  477 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2) internal view {</span>
  478 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint)&quot;, p0, p1, p2));</span>
  479 |     | <span class='neutral'>    }</span>
  480 |     | <span class='neutral'></span>
  481 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2) internal view {</span>
  482 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string)&quot;, p0, p1, p2));</span>
  483 |     | <span class='neutral'>    }</span>
  484 |     | <span class='neutral'></span>
  485 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2) internal view {</span>
  486 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool)&quot;, p0, p1, p2));</span>
  487 |     | <span class='neutral'>    }</span>
  488 |     | <span class='neutral'></span>
  489 |     | <span class='neutral'>    function log(address p0, bool p1, address p2) internal view {</span>
  490 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address)&quot;, p0, p1, p2));</span>
  491 |     | <span class='neutral'>    }</span>
  492 |     | <span class='neutral'></span>
  493 |     | <span class='neutral'>    function log(address p0, address p1, uint p2) internal view {</span>
  494 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint)&quot;, p0, p1, p2));</span>
  495 |     | <span class='neutral'>    }</span>
  496 |     | <span class='neutral'></span>
  497 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2) internal view {</span>
  498 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string)&quot;, p0, p1, p2));</span>
  499 |     | <span class='neutral'>    }</span>
  500 |     | <span class='neutral'></span>
  501 |     | <span class='neutral'>    function log(address p0, address p1, bool p2) internal view {</span>
  502 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool)&quot;, p0, p1, p2));</span>
  503 |     | <span class='neutral'>    }</span>
  504 |     | <span class='neutral'></span>
  505 |     | <span class='neutral'>    function log(address p0, address p1, address p2) internal view {</span>
  506 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address)&quot;, p0, p1, p2));</span>
  507 |     | <span class='neutral'>    }</span>
  508 |     | <span class='neutral'></span>
  509 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2, uint p3) internal view {</span>
  510 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint,uint)&quot;, p0, p1, p2, p3));</span>
  511 |     | <span class='neutral'>    }</span>
  512 |     | <span class='neutral'></span>
  513 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2, string memory p3) internal view {</span>
  514 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint,string)&quot;, p0, p1, p2, p3));</span>
  515 |     | <span class='neutral'>    }</span>
  516 |     | <span class='neutral'></span>
  517 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2, bool p3) internal view {</span>
  518 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint,bool)&quot;, p0, p1, p2, p3));</span>
  519 |     | <span class='neutral'>    }</span>
  520 |     | <span class='neutral'></span>
  521 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2, address p3) internal view {</span>
  522 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint,address)&quot;, p0, p1, p2, p3));</span>
  523 |     | <span class='neutral'>    }</span>
  524 |     | <span class='neutral'></span>
  525 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2, uint p3) internal view {</span>
  526 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string,uint)&quot;, p0, p1, p2, p3));</span>
  527 |     | <span class='neutral'>    }</span>
  528 |     | <span class='neutral'></span>
  529 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {</span>
  530 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string,string)&quot;, p0, p1, p2, p3));</span>
  531 |     | <span class='neutral'>    }</span>
  532 |     | <span class='neutral'></span>
  533 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2, bool p3) internal view {</span>
  534 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string,bool)&quot;, p0, p1, p2, p3));</span>
  535 |     | <span class='neutral'>    }</span>
  536 |     | <span class='neutral'></span>
  537 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2, address p3) internal view {</span>
  538 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string,address)&quot;, p0, p1, p2, p3));</span>
  539 |     | <span class='neutral'>    }</span>
  540 |     | <span class='neutral'></span>
  541 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2, uint p3) internal view {</span>
  542 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool,uint)&quot;, p0, p1, p2, p3));</span>
  543 |     | <span class='neutral'>    }</span>
  544 |     | <span class='neutral'></span>
  545 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2, string memory p3) internal view {</span>
  546 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool,string)&quot;, p0, p1, p2, p3));</span>
  547 |     | <span class='neutral'>    }</span>
  548 |     | <span class='neutral'></span>
  549 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2, bool p3) internal view {</span>
  550 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool,bool)&quot;, p0, p1, p2, p3));</span>
  551 |     | <span class='neutral'>    }</span>
  552 |     | <span class='neutral'></span>
  553 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2, address p3) internal view {</span>
  554 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool,address)&quot;, p0, p1, p2, p3));</span>
  555 |     | <span class='neutral'>    }</span>
  556 |     | <span class='neutral'></span>
  557 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2, uint p3) internal view {</span>
  558 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address,uint)&quot;, p0, p1, p2, p3));</span>
  559 |     | <span class='neutral'>    }</span>
  560 |     | <span class='neutral'></span>
  561 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2, string memory p3) internal view {</span>
  562 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address,string)&quot;, p0, p1, p2, p3));</span>
  563 |     | <span class='neutral'>    }</span>
  564 |     | <span class='neutral'></span>
  565 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2, bool p3) internal view {</span>
  566 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address,bool)&quot;, p0, p1, p2, p3));</span>
  567 |     | <span class='neutral'>    }</span>
  568 |     | <span class='neutral'></span>
  569 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2, address p3) internal view {</span>
  570 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address,address)&quot;, p0, p1, p2, p3));</span>
  571 |     | <span class='neutral'>    }</span>
  572 |     | <span class='neutral'></span>
  573 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2, uint p3) internal view {</span>
  574 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint,uint)&quot;, p0, p1, p2, p3));</span>
  575 |     | <span class='neutral'>    }</span>
  576 |     | <span class='neutral'></span>
  577 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {</span>
  578 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint,string)&quot;, p0, p1, p2, p3));</span>
  579 |     | <span class='neutral'>    }</span>
  580 |     | <span class='neutral'></span>
  581 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2, bool p3) internal view {</span>
  582 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint,bool)&quot;, p0, p1, p2, p3));</span>
  583 |     | <span class='neutral'>    }</span>
  584 |     | <span class='neutral'></span>
  585 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2, address p3) internal view {</span>
  586 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint,address)&quot;, p0, p1, p2, p3));</span>
  587 |     | <span class='neutral'>    }</span>
  588 |     | <span class='neutral'></span>
  589 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {</span>
  590 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string,uint)&quot;, p0, p1, p2, p3));</span>
  591 |     | <span class='neutral'>    }</span>
  592 |     | <span class='neutral'></span>
  593 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {</span>
  594 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string,string)&quot;, p0, p1, p2, p3));</span>
  595 |     | <span class='neutral'>    }</span>
  596 |     | <span class='neutral'></span>
  597 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {</span>
  598 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string,bool)&quot;, p0, p1, p2, p3));</span>
  599 |     | <span class='neutral'>    }</span>
  600 |     | <span class='neutral'></span>
  601 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2, address p3) internal view {</span>
  602 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string,address)&quot;, p0, p1, p2, p3));</span>
  603 |     | <span class='neutral'>    }</span>
  604 |     | <span class='neutral'></span>
  605 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2, uint p3) internal view {</span>
  606 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool,uint)&quot;, p0, p1, p2, p3));</span>
  607 |     | <span class='neutral'>    }</span>
  608 |     | <span class='neutral'></span>
  609 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {</span>
  610 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool,string)&quot;, p0, p1, p2, p3));</span>
  611 |     | <span class='neutral'>    }</span>
  612 |     | <span class='neutral'></span>
  613 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2, bool p3) internal view {</span>
  614 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
  615 |     | <span class='neutral'>    }</span>
  616 |     | <span class='neutral'></span>
  617 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2, address p3) internal view {</span>
  618 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool,address)&quot;, p0, p1, p2, p3));</span>
  619 |     | <span class='neutral'>    }</span>
  620 |     | <span class='neutral'></span>
  621 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2, uint p3) internal view {</span>
  622 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address,uint)&quot;, p0, p1, p2, p3));</span>
  623 |     | <span class='neutral'>    }</span>
  624 |     | <span class='neutral'></span>
  625 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2, string memory p3) internal view {</span>
  626 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address,string)&quot;, p0, p1, p2, p3));</span>
  627 |     | <span class='neutral'>    }</span>
  628 |     | <span class='neutral'></span>
  629 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2, bool p3) internal view {</span>
  630 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address,bool)&quot;, p0, p1, p2, p3));</span>
  631 |     | <span class='neutral'>    }</span>
  632 |     | <span class='neutral'></span>
  633 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2, address p3) internal view {</span>
  634 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address,address)&quot;, p0, p1, p2, p3));</span>
  635 |     | <span class='neutral'>    }</span>
  636 |     | <span class='neutral'></span>
  637 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2, uint p3) internal view {</span>
  638 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint,uint)&quot;, p0, p1, p2, p3));</span>
  639 |     | <span class='neutral'>    }</span>
  640 |     | <span class='neutral'></span>
  641 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2, string memory p3) internal view {</span>
  642 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint,string)&quot;, p0, p1, p2, p3));</span>
  643 |     | <span class='neutral'>    }</span>
  644 |     | <span class='neutral'></span>
  645 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2, bool p3) internal view {</span>
  646 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint,bool)&quot;, p0, p1, p2, p3));</span>
  647 |     | <span class='neutral'>    }</span>
  648 |     | <span class='neutral'></span>
  649 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2, address p3) internal view {</span>
  650 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint,address)&quot;, p0, p1, p2, p3));</span>
  651 |     | <span class='neutral'>    }</span>
  652 |     | <span class='neutral'></span>
  653 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2, uint p3) internal view {</span>
  654 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string,uint)&quot;, p0, p1, p2, p3));</span>
  655 |     | <span class='neutral'>    }</span>
  656 |     | <span class='neutral'></span>
  657 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {</span>
  658 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string,string)&quot;, p0, p1, p2, p3));</span>
  659 |     | <span class='neutral'>    }</span>
  660 |     | <span class='neutral'></span>
  661 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2, bool p3) internal view {</span>
  662 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
  663 |     | <span class='neutral'>    }</span>
  664 |     | <span class='neutral'></span>
  665 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2, address p3) internal view {</span>
  666 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string,address)&quot;, p0, p1, p2, p3));</span>
  667 |     | <span class='neutral'>    }</span>
  668 |     | <span class='neutral'></span>
  669 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2, uint p3) internal view {</span>
  670 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool,uint)&quot;, p0, p1, p2, p3));</span>
  671 |     | <span class='neutral'>    }</span>
  672 |     | <span class='neutral'></span>
  673 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2, string memory p3) internal view {</span>
  674 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
  675 |     | <span class='neutral'>    }</span>
  676 |     | <span class='neutral'></span>
  677 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2, bool p3) internal view {</span>
  678 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
  679 |     | <span class='neutral'>    }</span>
  680 |     | <span class='neutral'></span>
  681 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2, address p3) internal view {</span>
  682 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
  683 |     | <span class='neutral'>    }</span>
  684 |     | <span class='neutral'></span>
  685 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2, uint p3) internal view {</span>
  686 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address,uint)&quot;, p0, p1, p2, p3));</span>
  687 |     | <span class='neutral'>    }</span>
  688 |     | <span class='neutral'></span>
  689 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2, string memory p3) internal view {</span>
  690 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address,string)&quot;, p0, p1, p2, p3));</span>
  691 |     | <span class='neutral'>    }</span>
  692 |     | <span class='neutral'></span>
  693 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2, bool p3) internal view {</span>
  694 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
  695 |     | <span class='neutral'>    }</span>
  696 |     | <span class='neutral'></span>
  697 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2, address p3) internal view {</span>
  698 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address,address)&quot;, p0, p1, p2, p3));</span>
  699 |     | <span class='neutral'>    }</span>
  700 |     | <span class='neutral'></span>
  701 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2, uint p3) internal view {</span>
  702 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint,uint)&quot;, p0, p1, p2, p3));</span>
  703 |     | <span class='neutral'>    }</span>
  704 |     | <span class='neutral'></span>
  705 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2, string memory p3) internal view {</span>
  706 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint,string)&quot;, p0, p1, p2, p3));</span>
  707 |     | <span class='neutral'>    }</span>
  708 |     | <span class='neutral'></span>
  709 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2, bool p3) internal view {</span>
  710 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint,bool)&quot;, p0, p1, p2, p3));</span>
  711 |     | <span class='neutral'>    }</span>
  712 |     | <span class='neutral'></span>
  713 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2, address p3) internal view {</span>
  714 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint,address)&quot;, p0, p1, p2, p3));</span>
  715 |     | <span class='neutral'>    }</span>
  716 |     | <span class='neutral'></span>
  717 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2, uint p3) internal view {</span>
  718 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string,uint)&quot;, p0, p1, p2, p3));</span>
  719 |     | <span class='neutral'>    }</span>
  720 |     | <span class='neutral'></span>
  721 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2, string memory p3) internal view {</span>
  722 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string,string)&quot;, p0, p1, p2, p3));</span>
  723 |     | <span class='neutral'>    }</span>
  724 |     | <span class='neutral'></span>
  725 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2, bool p3) internal view {</span>
  726 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string,bool)&quot;, p0, p1, p2, p3));</span>
  727 |     | <span class='neutral'>    }</span>
  728 |     | <span class='neutral'></span>
  729 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2, address p3) internal view {</span>
  730 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string,address)&quot;, p0, p1, p2, p3));</span>
  731 |     | <span class='neutral'>    }</span>
  732 |     | <span class='neutral'></span>
  733 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2, uint p3) internal view {</span>
  734 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool,uint)&quot;, p0, p1, p2, p3));</span>
  735 |     | <span class='neutral'>    }</span>
  736 |     | <span class='neutral'></span>
  737 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2, string memory p3) internal view {</span>
  738 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool,string)&quot;, p0, p1, p2, p3));</span>
  739 |     | <span class='neutral'>    }</span>
  740 |     | <span class='neutral'></span>
  741 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2, bool p3) internal view {</span>
  742 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
  743 |     | <span class='neutral'>    }</span>
  744 |     | <span class='neutral'></span>
  745 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2, address p3) internal view {</span>
  746 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool,address)&quot;, p0, p1, p2, p3));</span>
  747 |     | <span class='neutral'>    }</span>
  748 |     | <span class='neutral'></span>
  749 |     | <span class='neutral'>    function log(uint p0, address p1, address p2, uint p3) internal view {</span>
  750 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address,uint)&quot;, p0, p1, p2, p3));</span>
  751 |     | <span class='neutral'>    }</span>
  752 |     | <span class='neutral'></span>
  753 |     | <span class='neutral'>    function log(uint p0, address p1, address p2, string memory p3) internal view {</span>
  754 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address,string)&quot;, p0, p1, p2, p3));</span>
  755 |     | <span class='neutral'>    }</span>
  756 |     | <span class='neutral'></span>
  757 |     | <span class='neutral'>    function log(uint p0, address p1, address p2, bool p3) internal view {</span>
  758 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address,bool)&quot;, p0, p1, p2, p3));</span>
  759 |     | <span class='neutral'>    }</span>
  760 |     | <span class='neutral'></span>
  761 |     | <span class='neutral'>    function log(uint p0, address p1, address p2, address p3) internal view {</span>
  762 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address,address)&quot;, p0, p1, p2, p3));</span>
  763 |     | <span class='neutral'>    }</span>
  764 |     | <span class='neutral'></span>
  765 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2, uint p3) internal view {</span>
  766 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint,uint)&quot;, p0, p1, p2, p3));</span>
  767 |     | <span class='neutral'>    }</span>
  768 |     | <span class='neutral'></span>
  769 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {</span>
  770 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint,string)&quot;, p0, p1, p2, p3));</span>
  771 |     | <span class='neutral'>    }</span>
  772 |     | <span class='neutral'></span>
  773 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2, bool p3) internal view {</span>
  774 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint,bool)&quot;, p0, p1, p2, p3));</span>
  775 |     | <span class='neutral'>    }</span>
  776 |     | <span class='neutral'></span>
  777 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2, address p3) internal view {</span>
  778 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint,address)&quot;, p0, p1, p2, p3));</span>
  779 |     | <span class='neutral'>    }</span>
  780 |     | <span class='neutral'></span>
  781 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {</span>
  782 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string,uint)&quot;, p0, p1, p2, p3));</span>
  783 |     | <span class='neutral'>    }</span>
  784 |     | <span class='neutral'></span>
  785 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {</span>
  786 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string,string)&quot;, p0, p1, p2, p3));</span>
  787 |     | <span class='neutral'>    }</span>
  788 |     | <span class='neutral'></span>
  789 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {</span>
  790 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string,bool)&quot;, p0, p1, p2, p3));</span>
  791 |     | <span class='neutral'>    }</span>
  792 |     | <span class='neutral'></span>
  793 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2, address p3) internal view {</span>
  794 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string,address)&quot;, p0, p1, p2, p3));</span>
  795 |     | <span class='neutral'>    }</span>
  796 |     | <span class='neutral'></span>
  797 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2, uint p3) internal view {</span>
  798 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool,uint)&quot;, p0, p1, p2, p3));</span>
  799 |     | <span class='neutral'>    }</span>
  800 |     | <span class='neutral'></span>
  801 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {</span>
  802 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool,string)&quot;, p0, p1, p2, p3));</span>
  803 |     | <span class='neutral'>    }</span>
  804 |     | <span class='neutral'></span>
  805 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2, bool p3) internal view {</span>
  806 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool,bool)&quot;, p0, p1, p2, p3));</span>
  807 |     | <span class='neutral'>    }</span>
  808 |     | <span class='neutral'></span>
  809 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2, address p3) internal view {</span>
  810 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool,address)&quot;, p0, p1, p2, p3));</span>
  811 |     | <span class='neutral'>    }</span>
  812 |     | <span class='neutral'></span>
  813 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2, uint p3) internal view {</span>
  814 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address,uint)&quot;, p0, p1, p2, p3));</span>
  815 |     | <span class='neutral'>    }</span>
  816 |     | <span class='neutral'></span>
  817 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2, string memory p3) internal view {</span>
  818 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address,string)&quot;, p0, p1, p2, p3));</span>
  819 |     | <span class='neutral'>    }</span>
  820 |     | <span class='neutral'></span>
  821 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2, bool p3) internal view {</span>
  822 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address,bool)&quot;, p0, p1, p2, p3));</span>
  823 |     | <span class='neutral'>    }</span>
  824 |     | <span class='neutral'></span>
  825 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2, address p3) internal view {</span>
  826 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address,address)&quot;, p0, p1, p2, p3));</span>
  827 |     | <span class='neutral'>    }</span>
  828 |     | <span class='neutral'></span>
  829 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {</span>
  830 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint,uint)&quot;, p0, p1, p2, p3));</span>
  831 |     | <span class='neutral'>    }</span>
  832 |     | <span class='neutral'></span>
  833 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {</span>
  834 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint,string)&quot;, p0, p1, p2, p3));</span>
  835 |     | <span class='neutral'>    }</span>
  836 |     | <span class='neutral'></span>
  837 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {</span>
  838 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint,bool)&quot;, p0, p1, p2, p3));</span>
  839 |     | <span class='neutral'>    }</span>
  840 |     | <span class='neutral'></span>
  841 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2, address p3) internal view {</span>
  842 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint,address)&quot;, p0, p1, p2, p3));</span>
  843 |     | <span class='neutral'>    }</span>
  844 |     | <span class='neutral'></span>
  845 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {</span>
  846 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,uint)&quot;, p0, p1, p2, p3));</span>
  847 |     | <span class='neutral'>    }</span>
  848 |     | <span class='neutral'></span>
  849 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {</span>
  850 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,string)&quot;, p0, p1, p2, p3));</span>
  851 |     | <span class='neutral'>    }</span>
  852 |     | <span class='neutral'></span>
  853 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {</span>
  854 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,bool)&quot;, p0, p1, p2, p3));</span>
  855 |     | <span class='neutral'>    }</span>
  856 |     | <span class='neutral'></span>
  857 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {</span>
  858 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,address)&quot;, p0, p1, p2, p3));</span>
  859 |     | <span class='neutral'>    }</span>
  860 |     | <span class='neutral'></span>
  861 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {</span>
  862 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,uint)&quot;, p0, p1, p2, p3));</span>
  863 |     | <span class='neutral'>    }</span>
  864 |     | <span class='neutral'></span>
  865 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {</span>
  866 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,string)&quot;, p0, p1, p2, p3));</span>
  867 |     | <span class='neutral'>    }</span>
  868 |     | <span class='neutral'></span>
  869 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {</span>
  870 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
  871 |     | <span class='neutral'>    }</span>
  872 |     | <span class='neutral'></span>
  873 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, address p3) internal view {</span>
  874 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,address)&quot;, p0, p1, p2, p3));</span>
  875 |     | <span class='neutral'>    }</span>
  876 |     | <span class='neutral'></span>
  877 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, uint p3) internal view {</span>
  878 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,uint)&quot;, p0, p1, p2, p3));</span>
  879 |     | <span class='neutral'>    }</span>
  880 |     | <span class='neutral'></span>
  881 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {</span>
  882 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,string)&quot;, p0, p1, p2, p3));</span>
  883 |     | <span class='neutral'>    }</span>
  884 |     | <span class='neutral'></span>
  885 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, bool p3) internal view {</span>
  886 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,bool)&quot;, p0, p1, p2, p3));</span>
  887 |     | <span class='neutral'>    }</span>
  888 |     | <span class='neutral'></span>
  889 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, address p3) internal view {</span>
  890 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,address)&quot;, p0, p1, p2, p3));</span>
  891 |     | <span class='neutral'>    }</span>
  892 |     | <span class='neutral'></span>
  893 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2, uint p3) internal view {</span>
  894 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint,uint)&quot;, p0, p1, p2, p3));</span>
  895 |     | <span class='neutral'>    }</span>
  896 |     | <span class='neutral'></span>
  897 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {</span>
  898 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint,string)&quot;, p0, p1, p2, p3));</span>
  899 |     | <span class='neutral'>    }</span>
  900 |     | <span class='neutral'></span>
  901 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2, bool p3) internal view {</span>
  902 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint,bool)&quot;, p0, p1, p2, p3));</span>
  903 |     | <span class='neutral'>    }</span>
  904 |     | <span class='neutral'></span>
  905 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2, address p3) internal view {</span>
  906 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint,address)&quot;, p0, p1, p2, p3));</span>
  907 |     | <span class='neutral'>    }</span>
  908 |     | <span class='neutral'></span>
  909 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {</span>
  910 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,uint)&quot;, p0, p1, p2, p3));</span>
  911 |     | <span class='neutral'>    }</span>
  912 |     | <span class='neutral'></span>
  913 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {</span>
  914 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,string)&quot;, p0, p1, p2, p3));</span>
  915 |     | <span class='neutral'>    }</span>
  916 |     | <span class='neutral'></span>
  917 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {</span>
  918 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
  919 |     | <span class='neutral'>    }</span>
  920 |     | <span class='neutral'></span>
  921 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, address p3) internal view {</span>
  922 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,address)&quot;, p0, p1, p2, p3));</span>
  923 |     | <span class='neutral'>    }</span>
  924 |     | <span class='neutral'></span>
  925 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, uint p3) internal view {</span>
  926 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,uint)&quot;, p0, p1, p2, p3));</span>
  927 |     | <span class='neutral'>    }</span>
  928 |     | <span class='neutral'></span>
  929 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {</span>
  930 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
  931 |     | <span class='neutral'>    }</span>
  932 |     | <span class='neutral'></span>
  933 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, bool p3) internal view {</span>
  934 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
  935 |     | <span class='neutral'>    }</span>
  936 |     | <span class='neutral'></span>
  937 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, address p3) internal view {</span>
  938 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
  939 |     | <span class='neutral'>    }</span>
  940 |     | <span class='neutral'></span>
  941 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, uint p3) internal view {</span>
  942 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,uint)&quot;, p0, p1, p2, p3));</span>
  943 |     | <span class='neutral'>    }</span>
  944 |     | <span class='neutral'></span>
  945 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, string memory p3) internal view {</span>
  946 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,string)&quot;, p0, p1, p2, p3));</span>
  947 |     | <span class='neutral'>    }</span>
  948 |     | <span class='neutral'></span>
  949 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, bool p3) internal view {</span>
  950 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
  951 |     | <span class='neutral'>    }</span>
  952 |     | <span class='neutral'></span>
  953 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, address p3) internal view {</span>
  954 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,address)&quot;, p0, p1, p2, p3));</span>
  955 |     | <span class='neutral'>    }</span>
  956 |     | <span class='neutral'></span>
  957 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2, uint p3) internal view {</span>
  958 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint,uint)&quot;, p0, p1, p2, p3));</span>
  959 |     | <span class='neutral'>    }</span>
  960 |     | <span class='neutral'></span>
  961 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2, string memory p3) internal view {</span>
  962 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint,string)&quot;, p0, p1, p2, p3));</span>
  963 |     | <span class='neutral'>    }</span>
  964 |     | <span class='neutral'></span>
  965 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2, bool p3) internal view {</span>
  966 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint,bool)&quot;, p0, p1, p2, p3));</span>
  967 |     | <span class='neutral'>    }</span>
  968 |     | <span class='neutral'></span>
  969 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2, address p3) internal view {</span>
  970 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint,address)&quot;, p0, p1, p2, p3));</span>
  971 |     | <span class='neutral'>    }</span>
  972 |     | <span class='neutral'></span>
  973 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, uint p3) internal view {</span>
  974 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,uint)&quot;, p0, p1, p2, p3));</span>
  975 |     | <span class='neutral'>    }</span>
  976 |     | <span class='neutral'></span>
  977 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {</span>
  978 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,string)&quot;, p0, p1, p2, p3));</span>
  979 |     | <span class='neutral'>    }</span>
  980 |     | <span class='neutral'></span>
  981 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, bool p3) internal view {</span>
  982 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,bool)&quot;, p0, p1, p2, p3));</span>
  983 |     | <span class='neutral'>    }</span>
  984 |     | <span class='neutral'></span>
  985 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, address p3) internal view {</span>
  986 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,address)&quot;, p0, p1, p2, p3));</span>
  987 |     | <span class='neutral'>    }</span>
  988 |     | <span class='neutral'></span>
  989 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, uint p3) internal view {</span>
  990 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,uint)&quot;, p0, p1, p2, p3));</span>
  991 |     | <span class='neutral'>    }</span>
  992 |     | <span class='neutral'></span>
  993 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, string memory p3) internal view {</span>
  994 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,string)&quot;, p0, p1, p2, p3));</span>
  995 |     | <span class='neutral'>    }</span>
  996 |     | <span class='neutral'></span>
  997 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, bool p3) internal view {</span>
  998 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
  999 |     | <span class='neutral'>    }</span>
 1000 |     | <span class='neutral'></span>
 1001 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, address p3) internal view {</span>
 1002 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1003 |     | <span class='neutral'>    }</span>
 1004 |     | <span class='neutral'></span>
 1005 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, uint p3) internal view {</span>
 1006 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,uint)&quot;, p0, p1, p2, p3));</span>
 1007 |     | <span class='neutral'>    }</span>
 1008 |     | <span class='neutral'></span>
 1009 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, string memory p3) internal view {</span>
 1010 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1011 |     | <span class='neutral'>    }</span>
 1012 |     | <span class='neutral'></span>
 1013 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, bool p3) internal view {</span>
 1014 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1015 |     | <span class='neutral'>    }</span>
 1016 |     | <span class='neutral'></span>
 1017 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, address p3) internal view {</span>
 1018 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1019 |     | <span class='neutral'>    }</span>
 1020 |     | <span class='neutral'></span>
 1021 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2, uint p3) internal view {</span>
 1022 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1023 |     | <span class='neutral'>    }</span>
 1024 |     | <span class='neutral'></span>
 1025 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2, string memory p3) internal view {</span>
 1026 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint,string)&quot;, p0, p1, p2, p3));</span>
 1027 |     | <span class='neutral'>    }</span>
 1028 |     | <span class='neutral'></span>
 1029 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2, bool p3) internal view {</span>
 1030 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1031 |     | <span class='neutral'>    }</span>
 1032 |     | <span class='neutral'></span>
 1033 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2, address p3) internal view {</span>
 1034 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint,address)&quot;, p0, p1, p2, p3));</span>
 1035 |     | <span class='neutral'>    }</span>
 1036 |     | <span class='neutral'></span>
 1037 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2, uint p3) internal view {</span>
 1038 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string,uint)&quot;, p0, p1, p2, p3));</span>
 1039 |     | <span class='neutral'>    }</span>
 1040 |     | <span class='neutral'></span>
 1041 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {</span>
 1042 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string,string)&quot;, p0, p1, p2, p3));</span>
 1043 |     | <span class='neutral'>    }</span>
 1044 |     | <span class='neutral'></span>
 1045 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2, bool p3) internal view {</span>
 1046 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string,bool)&quot;, p0, p1, p2, p3));</span>
 1047 |     | <span class='neutral'>    }</span>
 1048 |     | <span class='neutral'></span>
 1049 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2, address p3) internal view {</span>
 1050 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string,address)&quot;, p0, p1, p2, p3));</span>
 1051 |     | <span class='neutral'>    }</span>
 1052 |     | <span class='neutral'></span>
 1053 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2, uint p3) internal view {</span>
 1054 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1055 |     | <span class='neutral'>    }</span>
 1056 |     | <span class='neutral'></span>
 1057 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2, string memory p3) internal view {</span>
 1058 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool,string)&quot;, p0, p1, p2, p3));</span>
 1059 |     | <span class='neutral'>    }</span>
 1060 |     | <span class='neutral'></span>
 1061 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2, bool p3) internal view {</span>
 1062 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1063 |     | <span class='neutral'>    }</span>
 1064 |     | <span class='neutral'></span>
 1065 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2, address p3) internal view {</span>
 1066 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool,address)&quot;, p0, p1, p2, p3));</span>
 1067 |     | <span class='neutral'>    }</span>
 1068 |     | <span class='neutral'></span>
 1069 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2, uint p3) internal view {</span>
 1070 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address,uint)&quot;, p0, p1, p2, p3));</span>
 1071 |     | <span class='neutral'>    }</span>
 1072 |     | <span class='neutral'></span>
 1073 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2, string memory p3) internal view {</span>
 1074 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address,string)&quot;, p0, p1, p2, p3));</span>
 1075 |     | <span class='neutral'>    }</span>
 1076 |     | <span class='neutral'></span>
 1077 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2, bool p3) internal view {</span>
 1078 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address,bool)&quot;, p0, p1, p2, p3));</span>
 1079 |     | <span class='neutral'>    }</span>
 1080 |     | <span class='neutral'></span>
 1081 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2, address p3) internal view {</span>
 1082 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address,address)&quot;, p0, p1, p2, p3));</span>
 1083 |     | <span class='neutral'>    }</span>
 1084 |     | <span class='neutral'></span>
 1085 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2, uint p3) internal view {</span>
 1086 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1087 |     | <span class='neutral'>    }</span>
 1088 |     | <span class='neutral'></span>
 1089 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {</span>
 1090 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint,string)&quot;, p0, p1, p2, p3));</span>
 1091 |     | <span class='neutral'>    }</span>
 1092 |     | <span class='neutral'></span>
 1093 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2, bool p3) internal view {</span>
 1094 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1095 |     | <span class='neutral'>    }</span>
 1096 |     | <span class='neutral'></span>
 1097 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2, address p3) internal view {</span>
 1098 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint,address)&quot;, p0, p1, p2, p3));</span>
 1099 |     | <span class='neutral'>    }</span>
 1100 |     | <span class='neutral'></span>
 1101 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {</span>
 1102 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,uint)&quot;, p0, p1, p2, p3));</span>
 1103 |     | <span class='neutral'>    }</span>
 1104 |     | <span class='neutral'></span>
 1105 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {</span>
 1106 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,string)&quot;, p0, p1, p2, p3));</span>
 1107 |     | <span class='neutral'>    }</span>
 1108 |     | <span class='neutral'></span>
 1109 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {</span>
 1110 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,bool)&quot;, p0, p1, p2, p3));</span>
 1111 |     | <span class='neutral'>    }</span>
 1112 |     | <span class='neutral'></span>
 1113 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, address p3) internal view {</span>
 1114 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,address)&quot;, p0, p1, p2, p3));</span>
 1115 |     | <span class='neutral'>    }</span>
 1116 |     | <span class='neutral'></span>
 1117 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, uint p3) internal view {</span>
 1118 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1119 |     | <span class='neutral'>    }</span>
 1120 |     | <span class='neutral'></span>
 1121 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {</span>
 1122 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,string)&quot;, p0, p1, p2, p3));</span>
 1123 |     | <span class='neutral'>    }</span>
 1124 |     | <span class='neutral'></span>
 1125 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, bool p3) internal view {</span>
 1126 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1127 |     | <span class='neutral'>    }</span>
 1128 |     | <span class='neutral'></span>
 1129 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, address p3) internal view {</span>
 1130 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,address)&quot;, p0, p1, p2, p3));</span>
 1131 |     | <span class='neutral'>    }</span>
 1132 |     | <span class='neutral'></span>
 1133 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, uint p3) internal view {</span>
 1134 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,uint)&quot;, p0, p1, p2, p3));</span>
 1135 |     | <span class='neutral'>    }</span>
 1136 |     | <span class='neutral'></span>
 1137 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, string memory p3) internal view {</span>
 1138 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,string)&quot;, p0, p1, p2, p3));</span>
 1139 |     | <span class='neutral'>    }</span>
 1140 |     | <span class='neutral'></span>
 1141 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, bool p3) internal view {</span>
 1142 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,bool)&quot;, p0, p1, p2, p3));</span>
 1143 |     | <span class='neutral'>    }</span>
 1144 |     | <span class='neutral'></span>
 1145 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, address p3) internal view {</span>
 1146 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,address)&quot;, p0, p1, p2, p3));</span>
 1147 |     | <span class='neutral'>    }</span>
 1148 |     | <span class='neutral'></span>
 1149 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2, uint p3) internal view {</span>
 1150 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1151 |     | <span class='neutral'>    }</span>
 1152 |     | <span class='neutral'></span>
 1153 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2, string memory p3) internal view {</span>
 1154 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint,string)&quot;, p0, p1, p2, p3));</span>
 1155 |     | <span class='neutral'>    }</span>
 1156 |     | <span class='neutral'></span>
 1157 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2, bool p3) internal view {</span>
 1158 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1159 |     | <span class='neutral'>    }</span>
 1160 |     | <span class='neutral'></span>
 1161 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2, address p3) internal view {</span>
 1162 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint,address)&quot;, p0, p1, p2, p3));</span>
 1163 |     | <span class='neutral'>    }</span>
 1164 |     | <span class='neutral'></span>
 1165 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, uint p3) internal view {</span>
 1166 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,uint)&quot;, p0, p1, p2, p3));</span>
 1167 |     | <span class='neutral'>    }</span>
 1168 |     | <span class='neutral'></span>
 1169 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {</span>
 1170 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,string)&quot;, p0, p1, p2, p3));</span>
 1171 |     | <span class='neutral'>    }</span>
 1172 |     | <span class='neutral'></span>
 1173 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, bool p3) internal view {</span>
 1174 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
 1175 |     | <span class='neutral'>    }</span>
 1176 |     | <span class='neutral'></span>
 1177 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, address p3) internal view {</span>
 1178 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,address)&quot;, p0, p1, p2, p3));</span>
 1179 |     | <span class='neutral'>    }</span>
 1180 |     | <span class='neutral'></span>
 1181 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, uint p3) internal view {</span>
 1182 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1183 |     | <span class='neutral'>    }</span>
 1184 |     | <span class='neutral'></span>
 1185 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, string memory p3) internal view {</span>
 1186 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
 1187 |     | <span class='neutral'>    }</span>
 1188 |     | <span class='neutral'></span>
 1189 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, bool p3) internal view {</span>
 1190 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1191 |     | <span class='neutral'>    }</span>
 1192 |     | <span class='neutral'></span>
 1193 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, address p3) internal view {</span>
 1194 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
 1195 |     | <span class='neutral'>    }</span>
 1196 |     | <span class='neutral'></span>
 1197 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, uint p3) internal view {</span>
 1198 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,uint)&quot;, p0, p1, p2, p3));</span>
 1199 |     | <span class='neutral'>    }</span>
 1200 |     | <span class='neutral'></span>
 1201 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, string memory p3) internal view {</span>
 1202 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,string)&quot;, p0, p1, p2, p3));</span>
 1203 |     | <span class='neutral'>    }</span>
 1204 |     | <span class='neutral'></span>
 1205 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, bool p3) internal view {</span>
 1206 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
 1207 |     | <span class='neutral'>    }</span>
 1208 |     | <span class='neutral'></span>
 1209 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, address p3) internal view {</span>
 1210 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,address)&quot;, p0, p1, p2, p3));</span>
 1211 |     | <span class='neutral'>    }</span>
 1212 |     | <span class='neutral'></span>
 1213 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2, uint p3) internal view {</span>
 1214 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1215 |     | <span class='neutral'>    }</span>
 1216 |     | <span class='neutral'></span>
 1217 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2, string memory p3) internal view {</span>
 1218 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint,string)&quot;, p0, p1, p2, p3));</span>
 1219 |     | <span class='neutral'>    }</span>
 1220 |     | <span class='neutral'></span>
 1221 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2, bool p3) internal view {</span>
 1222 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1223 |     | <span class='neutral'>    }</span>
 1224 |     | <span class='neutral'></span>
 1225 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2, address p3) internal view {</span>
 1226 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint,address)&quot;, p0, p1, p2, p3));</span>
 1227 |     | <span class='neutral'>    }</span>
 1228 |     | <span class='neutral'></span>
 1229 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, uint p3) internal view {</span>
 1230 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,uint)&quot;, p0, p1, p2, p3));</span>
 1231 |     | <span class='neutral'>    }</span>
 1232 |     | <span class='neutral'></span>
 1233 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, string memory p3) internal view {</span>
 1234 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,string)&quot;, p0, p1, p2, p3));</span>
 1235 |     | <span class='neutral'>    }</span>
 1236 |     | <span class='neutral'></span>
 1237 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, bool p3) internal view {</span>
 1238 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1239 |     | <span class='neutral'>    }</span>
 1240 |     | <span class='neutral'></span>
 1241 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, address p3) internal view {</span>
 1242 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1243 |     | <span class='neutral'>    }</span>
 1244 |     | <span class='neutral'></span>
 1245 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, uint p3) internal view {</span>
 1246 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1247 |     | <span class='neutral'>    }</span>
 1248 |     | <span class='neutral'></span>
 1249 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, string memory p3) internal view {</span>
 1250 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1251 |     | <span class='neutral'>    }</span>
 1252 |     | <span class='neutral'></span>
 1253 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, bool p3) internal view {</span>
 1254 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1255 |     | <span class='neutral'>    }</span>
 1256 |     | <span class='neutral'></span>
 1257 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, address p3) internal view {</span>
 1258 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1259 |     | <span class='neutral'>    }</span>
 1260 |     | <span class='neutral'></span>
 1261 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, uint p3) internal view {</span>
 1262 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,uint)&quot;, p0, p1, p2, p3));</span>
 1263 |     | <span class='neutral'>    }</span>
 1264 |     | <span class='neutral'></span>
 1265 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, string memory p3) internal view {</span>
 1266 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1267 |     | <span class='neutral'>    }</span>
 1268 |     | <span class='neutral'></span>
 1269 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, bool p3) internal view {</span>
 1270 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1271 |     | <span class='neutral'>    }</span>
 1272 |     | <span class='neutral'></span>
 1273 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, address p3) internal view {</span>
 1274 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1275 |     | <span class='neutral'>    }</span>
 1276 |     | <span class='neutral'></span>
 1277 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2, uint p3) internal view {</span>
 1278 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1279 |     | <span class='neutral'>    }</span>
 1280 |     | <span class='neutral'></span>
 1281 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2, string memory p3) internal view {</span>
 1282 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint,string)&quot;, p0, p1, p2, p3));</span>
 1283 |     | <span class='neutral'>    }</span>
 1284 |     | <span class='neutral'></span>
 1285 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2, bool p3) internal view {</span>
 1286 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1287 |     | <span class='neutral'>    }</span>
 1288 |     | <span class='neutral'></span>
 1289 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2, address p3) internal view {</span>
 1290 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint,address)&quot;, p0, p1, p2, p3));</span>
 1291 |     | <span class='neutral'>    }</span>
 1292 |     | <span class='neutral'></span>
 1293 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2, uint p3) internal view {</span>
 1294 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string,uint)&quot;, p0, p1, p2, p3));</span>
 1295 |     | <span class='neutral'>    }</span>
 1296 |     | <span class='neutral'></span>
 1297 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2, string memory p3) internal view {</span>
 1298 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string,string)&quot;, p0, p1, p2, p3));</span>
 1299 |     | <span class='neutral'>    }</span>
 1300 |     | <span class='neutral'></span>
 1301 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2, bool p3) internal view {</span>
 1302 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string,bool)&quot;, p0, p1, p2, p3));</span>
 1303 |     | <span class='neutral'>    }</span>
 1304 |     | <span class='neutral'></span>
 1305 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2, address p3) internal view {</span>
 1306 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string,address)&quot;, p0, p1, p2, p3));</span>
 1307 |     | <span class='neutral'>    }</span>
 1308 |     | <span class='neutral'></span>
 1309 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2, uint p3) internal view {</span>
 1310 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1311 |     | <span class='neutral'>    }</span>
 1312 |     | <span class='neutral'></span>
 1313 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2, string memory p3) internal view {</span>
 1314 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool,string)&quot;, p0, p1, p2, p3));</span>
 1315 |     | <span class='neutral'>    }</span>
 1316 |     | <span class='neutral'></span>
 1317 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2, bool p3) internal view {</span>
 1318 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1319 |     | <span class='neutral'>    }</span>
 1320 |     | <span class='neutral'></span>
 1321 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2, address p3) internal view {</span>
 1322 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool,address)&quot;, p0, p1, p2, p3));</span>
 1323 |     | <span class='neutral'>    }</span>
 1324 |     | <span class='neutral'></span>
 1325 |     | <span class='neutral'>    function log(address p0, uint p1, address p2, uint p3) internal view {</span>
 1326 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address,uint)&quot;, p0, p1, p2, p3));</span>
 1327 |     | <span class='neutral'>    }</span>
 1328 |     | <span class='neutral'></span>
 1329 |     | <span class='neutral'>    function log(address p0, uint p1, address p2, string memory p3) internal view {</span>
 1330 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address,string)&quot;, p0, p1, p2, p3));</span>
 1331 |     | <span class='neutral'>    }</span>
 1332 |     | <span class='neutral'></span>
 1333 |     | <span class='neutral'>    function log(address p0, uint p1, address p2, bool p3) internal view {</span>
 1334 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address,bool)&quot;, p0, p1, p2, p3));</span>
 1335 |     | <span class='neutral'>    }</span>
 1336 |     | <span class='neutral'></span>
 1337 |     | <span class='neutral'>    function log(address p0, uint p1, address p2, address p3) internal view {</span>
 1338 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address,address)&quot;, p0, p1, p2, p3));</span>
 1339 |     | <span class='neutral'>    }</span>
 1340 |     | <span class='neutral'></span>
 1341 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2, uint p3) internal view {</span>
 1342 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1343 |     | <span class='neutral'>    }</span>
 1344 |     | <span class='neutral'></span>
 1345 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2, string memory p3) internal view {</span>
 1346 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint,string)&quot;, p0, p1, p2, p3));</span>
 1347 |     | <span class='neutral'>    }</span>
 1348 |     | <span class='neutral'></span>
 1349 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2, bool p3) internal view {</span>
 1350 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1351 |     | <span class='neutral'>    }</span>
 1352 |     | <span class='neutral'></span>
 1353 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2, address p3) internal view {</span>
 1354 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint,address)&quot;, p0, p1, p2, p3));</span>
 1355 |     | <span class='neutral'>    }</span>
 1356 |     | <span class='neutral'></span>
 1357 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, uint p3) internal view {</span>
 1358 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,uint)&quot;, p0, p1, p2, p3));</span>
 1359 |     | <span class='neutral'>    }</span>
 1360 |     | <span class='neutral'></span>
 1361 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {</span>
 1362 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,string)&quot;, p0, p1, p2, p3));</span>
 1363 |     | <span class='neutral'>    }</span>
 1364 |     | <span class='neutral'></span>
 1365 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, bool p3) internal view {</span>
 1366 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,bool)&quot;, p0, p1, p2, p3));</span>
 1367 |     | <span class='neutral'>    }</span>
 1368 |     | <span class='neutral'></span>
 1369 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, address p3) internal view {</span>
 1370 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,address)&quot;, p0, p1, p2, p3));</span>
 1371 |     | <span class='neutral'>    }</span>
 1372 |     | <span class='neutral'></span>
 1373 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, uint p3) internal view {</span>
 1374 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1375 |     | <span class='neutral'>    }</span>
 1376 |     | <span class='neutral'></span>
 1377 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, string memory p3) internal view {</span>
 1378 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,string)&quot;, p0, p1, p2, p3));</span>
 1379 |     | <span class='neutral'>    }</span>
 1380 |     | <span class='neutral'></span>
 1381 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, bool p3) internal view {</span>
 1382 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1383 |     | <span class='neutral'>    }</span>
 1384 |     | <span class='neutral'></span>
 1385 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, address p3) internal view {</span>
 1386 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,address)&quot;, p0, p1, p2, p3));</span>
 1387 |     | <span class='neutral'>    }</span>
 1388 |     | <span class='neutral'></span>
 1389 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, uint p3) internal view {</span>
 1390 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,uint)&quot;, p0, p1, p2, p3));</span>
 1391 |     | <span class='neutral'>    }</span>
 1392 |     | <span class='neutral'></span>
 1393 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, string memory p3) internal view {</span>
 1394 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,string)&quot;, p0, p1, p2, p3));</span>
 1395 |     | <span class='neutral'>    }</span>
 1396 |     | <span class='neutral'></span>
 1397 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, bool p3) internal view {</span>
 1398 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,bool)&quot;, p0, p1, p2, p3));</span>
 1399 |     | <span class='neutral'>    }</span>
 1400 |     | <span class='neutral'></span>
 1401 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, address p3) internal view {</span>
 1402 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,address)&quot;, p0, p1, p2, p3));</span>
 1403 |     | <span class='neutral'>    }</span>
 1404 |     | <span class='neutral'></span>
 1405 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2, uint p3) internal view {</span>
 1406 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1407 |     | <span class='neutral'>    }</span>
 1408 |     | <span class='neutral'></span>
 1409 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2, string memory p3) internal view {</span>
 1410 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint,string)&quot;, p0, p1, p2, p3));</span>
 1411 |     | <span class='neutral'>    }</span>
 1412 |     | <span class='neutral'></span>
 1413 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2, bool p3) internal view {</span>
 1414 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1415 |     | <span class='neutral'>    }</span>
 1416 |     | <span class='neutral'></span>
 1417 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2, address p3) internal view {</span>
 1418 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint,address)&quot;, p0, p1, p2, p3));</span>
 1419 |     | <span class='neutral'>    }</span>
 1420 |     | <span class='neutral'></span>
 1421 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, uint p3) internal view {</span>
 1422 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,uint)&quot;, p0, p1, p2, p3));</span>
 1423 |     | <span class='neutral'>    }</span>
 1424 |     | <span class='neutral'></span>
 1425 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, string memory p3) internal view {</span>
 1426 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,string)&quot;, p0, p1, p2, p3));</span>
 1427 |     | <span class='neutral'>    }</span>
 1428 |     | <span class='neutral'></span>
 1429 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, bool p3) internal view {</span>
 1430 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
 1431 |     | <span class='neutral'>    }</span>
 1432 |     | <span class='neutral'></span>
 1433 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, address p3) internal view {</span>
 1434 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,address)&quot;, p0, p1, p2, p3));</span>
 1435 |     | <span class='neutral'>    }</span>
 1436 |     | <span class='neutral'></span>
 1437 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, uint p3) internal view {</span>
 1438 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1439 |     | <span class='neutral'>    }</span>
 1440 |     | <span class='neutral'></span>
 1441 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, string memory p3) internal view {</span>
 1442 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
 1443 |     | <span class='neutral'>    }</span>
 1444 |     | <span class='neutral'></span>
 1445 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, bool p3) internal view {</span>
 1446 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1447 |     | <span class='neutral'>    }</span>
 1448 |     | <span class='neutral'></span>
 1449 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, address p3) internal view {</span>
 1450 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
 1451 |     | <span class='neutral'>    }</span>
 1452 |     | <span class='neutral'></span>
 1453 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, uint p3) internal view {</span>
 1454 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,uint)&quot;, p0, p1, p2, p3));</span>
 1455 |     | <span class='neutral'>    }</span>
 1456 |     | <span class='neutral'></span>
 1457 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, string memory p3) internal view {</span>
 1458 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,string)&quot;, p0, p1, p2, p3));</span>
 1459 |     | <span class='neutral'>    }</span>
 1460 |     | <span class='neutral'></span>
 1461 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, bool p3) internal view {</span>
 1462 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
 1463 |     | <span class='neutral'>    }</span>
 1464 |     | <span class='neutral'></span>
 1465 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, address p3) internal view {</span>
 1466 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,address)&quot;, p0, p1, p2, p3));</span>
 1467 |     | <span class='neutral'>    }</span>
 1468 |     | <span class='neutral'></span>
 1469 |     | <span class='neutral'>    function log(address p0, address p1, uint p2, uint p3) internal view {</span>
 1470 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1471 |     | <span class='neutral'>    }</span>
 1472 |     | <span class='neutral'></span>
 1473 |     | <span class='neutral'>    function log(address p0, address p1, uint p2, string memory p3) internal view {</span>
 1474 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint,string)&quot;, p0, p1, p2, p3));</span>
 1475 |     | <span class='neutral'>    }</span>
 1476 |     | <span class='neutral'></span>
 1477 |     | <span class='neutral'>    function log(address p0, address p1, uint p2, bool p3) internal view {</span>
 1478 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1479 |     | <span class='neutral'>    }</span>
 1480 |     | <span class='neutral'></span>
 1481 |     | <span class='neutral'>    function log(address p0, address p1, uint p2, address p3) internal view {</span>
 1482 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint,address)&quot;, p0, p1, p2, p3));</span>
 1483 |     | <span class='neutral'>    }</span>
 1484 |     | <span class='neutral'></span>
 1485 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, uint p3) internal view {</span>
 1486 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,uint)&quot;, p0, p1, p2, p3));</span>
 1487 |     | <span class='neutral'>    }</span>
 1488 |     | <span class='neutral'></span>
 1489 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, string memory p3) internal view {</span>
 1490 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,string)&quot;, p0, p1, p2, p3));</span>
 1491 |     | <span class='neutral'>    }</span>
 1492 |     | <span class='neutral'></span>
 1493 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, bool p3) internal view {</span>
 1494 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1495 |     | <span class='neutral'>    }</span>
 1496 |     | <span class='neutral'></span>
 1497 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, address p3) internal view {</span>
 1498 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1499 |     | <span class='neutral'>    }</span>
 1500 |     | <span class='neutral'></span>
 1501 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, uint p3) internal view {</span>
 1502 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1503 |     | <span class='neutral'>    }</span>
 1504 |     | <span class='neutral'></span>
 1505 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, string memory p3) internal view {</span>
 1506 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1507 |     | <span class='neutral'>    }</span>
 1508 |     | <span class='neutral'></span>
 1509 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, bool p3) internal view {</span>
 1510 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1511 |     | <span class='neutral'>    }</span>
 1512 |     | <span class='neutral'></span>
 1513 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, address p3) internal view {</span>
 1514 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1515 |     | <span class='neutral'>    }</span>
 1516 |     | <span class='neutral'></span>
 1517 |     | <span class='neutral'>    function log(address p0, address p1, address p2, uint p3) internal view {</span>
 1518 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,uint)&quot;, p0, p1, p2, p3));</span>
 1519 |     | <span class='neutral'>    }</span>
 1520 |     | <span class='neutral'></span>
 1521 |     | <span class='neutral'>    function log(address p0, address p1, address p2, string memory p3) internal view {</span>
 1522 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1523 |     | <span class='neutral'>    }</span>
 1524 |     | <span class='neutral'></span>
 1525 |     | <span class='neutral'>    function log(address p0, address p1, address p2, bool p3) internal view {</span>
 1526 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1527 |     | <span class='neutral'>    }</span>
 1528 |     | <span class='neutral'></span>
 1529 |     | <span class='neutral'>    function log(address p0, address p1, address p2, address p3) internal view {</span>
 1530 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1531 |     | <span class='neutral'>    }</span>
 1532 |     | <span class='neutral'></span>
 1533 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/forge-std/src/console2.sol</b>
<code>
    1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
    2 |     | <span class='neutral'>pragma solidity &gt;=0.4.22 &lt;0.9.0;</span>
    3 |     | <span class='neutral'></span>
    4 |     | <span class='neutral'>/// @dev The original console.sol uses `int` and `uint` for computing function selectors, but it should</span>
    5 |     | <span class='neutral'>/// use `int256` and `uint256`. This modified version fixes that. This version is recommended</span>
    6 |     | <span class='neutral'>/// over `console.sol` if you don&#39;t need compatibility with Hardhat as the logs will show up in</span>
    7 |     | <span class='neutral'>/// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.</span>
    8 |     | <span class='unexecuted'>/// Reference: https://github.com/NomicFoundation/hardhat/issues/2178</span>
    9 |     | <span class='neutral'>library console2 {</span>
   10 |     | <span class='neutral'>    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);</span>
   11 |     | <span class='neutral'></span>
   12 |     | <span class='neutral'>    function _sendLogPayload(bytes memory payload) private view {</span>
   13 |     | <span class='neutral'>        uint256 payloadLength = payload.length;</span>
   14 |     | <span class='neutral'>        address consoleAddress = CONSOLE_ADDRESS;</span>
   15 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   16 |     | <span class='neutral'>        assembly {</span>
   17 |     | <span class='neutral'>            let payloadStart := add(payload, 32)</span>
   18 |     | <span class='neutral'>            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)</span>
   19 |     | <span class='neutral'>        }</span>
   20 |     | <span class='neutral'>    }</span>
   21 |     | <span class='neutral'></span>
   22 |     | <span class='neutral'>    function log() internal view {</span>
   23 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log()&quot;));</span>
   24 |     | <span class='neutral'>    }</span>
   25 |     | <span class='neutral'></span>
   26 |     | <span class='neutral'>    function logInt(int256 p0) internal view {</span>
   27 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(int256)&quot;, p0));</span>
   28 |     | <span class='neutral'>    }</span>
   29 |     | <span class='neutral'></span>
   30 |     | <span class='neutral'>    function logUint(uint256 p0) internal view {</span>
   31 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256)&quot;, p0));</span>
   32 |     | <span class='neutral'>    }</span>
   33 |     | <span class='neutral'></span>
   34 |     | <span class='neutral'>    function logString(string memory p0) internal view {</span>
   35 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
   36 |     | <span class='neutral'>    }</span>
   37 |     | <span class='neutral'></span>
   38 |     | <span class='neutral'>    function logBool(bool p0) internal view {</span>
   39 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool)&quot;, p0));</span>
   40 |     | <span class='neutral'>    }</span>
   41 |     | <span class='neutral'></span>
   42 |     | <span class='neutral'>    function logAddress(address p0) internal view {</span>
   43 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address)&quot;, p0));</span>
   44 |     | <span class='neutral'>    }</span>
   45 |     | <span class='neutral'></span>
   46 |     | <span class='neutral'>    function logBytes(bytes memory p0) internal view {</span>
   47 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes)&quot;, p0));</span>
   48 |     | <span class='neutral'>    }</span>
   49 |     | <span class='neutral'></span>
   50 |     | <span class='neutral'>    function logBytes1(bytes1 p0) internal view {</span>
   51 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes1)&quot;, p0));</span>
   52 |     | <span class='neutral'>    }</span>
   53 |     | <span class='neutral'></span>
   54 |     | <span class='neutral'>    function logBytes2(bytes2 p0) internal view {</span>
   55 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes2)&quot;, p0));</span>
   56 |     | <span class='neutral'>    }</span>
   57 |     | <span class='neutral'></span>
   58 |     | <span class='neutral'>    function logBytes3(bytes3 p0) internal view {</span>
   59 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes3)&quot;, p0));</span>
   60 |     | <span class='neutral'>    }</span>
   61 |     | <span class='neutral'></span>
   62 |     | <span class='neutral'>    function logBytes4(bytes4 p0) internal view {</span>
   63 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes4)&quot;, p0));</span>
   64 |     | <span class='neutral'>    }</span>
   65 |     | <span class='neutral'></span>
   66 |     | <span class='neutral'>    function logBytes5(bytes5 p0) internal view {</span>
   67 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes5)&quot;, p0));</span>
   68 |     | <span class='neutral'>    }</span>
   69 |     | <span class='neutral'></span>
   70 |     | <span class='neutral'>    function logBytes6(bytes6 p0) internal view {</span>
   71 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes6)&quot;, p0));</span>
   72 |     | <span class='neutral'>    }</span>
   73 |     | <span class='neutral'></span>
   74 |     | <span class='neutral'>    function logBytes7(bytes7 p0) internal view {</span>
   75 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes7)&quot;, p0));</span>
   76 |     | <span class='neutral'>    }</span>
   77 |     | <span class='neutral'></span>
   78 |     | <span class='neutral'>    function logBytes8(bytes8 p0) internal view {</span>
   79 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes8)&quot;, p0));</span>
   80 |     | <span class='neutral'>    }</span>
   81 |     | <span class='neutral'></span>
   82 |     | <span class='neutral'>    function logBytes9(bytes9 p0) internal view {</span>
   83 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes9)&quot;, p0));</span>
   84 |     | <span class='neutral'>    }</span>
   85 |     | <span class='neutral'></span>
   86 |     | <span class='neutral'>    function logBytes10(bytes10 p0) internal view {</span>
   87 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes10)&quot;, p0));</span>
   88 |     | <span class='neutral'>    }</span>
   89 |     | <span class='neutral'></span>
   90 |     | <span class='neutral'>    function logBytes11(bytes11 p0) internal view {</span>
   91 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes11)&quot;, p0));</span>
   92 |     | <span class='neutral'>    }</span>
   93 |     | <span class='neutral'></span>
   94 |     | <span class='neutral'>    function logBytes12(bytes12 p0) internal view {</span>
   95 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes12)&quot;, p0));</span>
   96 |     | <span class='neutral'>    }</span>
   97 |     | <span class='neutral'></span>
   98 |     | <span class='neutral'>    function logBytes13(bytes13 p0) internal view {</span>
   99 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes13)&quot;, p0));</span>
  100 |     | <span class='neutral'>    }</span>
  101 |     | <span class='neutral'></span>
  102 |     | <span class='neutral'>    function logBytes14(bytes14 p0) internal view {</span>
  103 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes14)&quot;, p0));</span>
  104 |     | <span class='neutral'>    }</span>
  105 |     | <span class='neutral'></span>
  106 |     | <span class='neutral'>    function logBytes15(bytes15 p0) internal view {</span>
  107 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes15)&quot;, p0));</span>
  108 |     | <span class='neutral'>    }</span>
  109 |     | <span class='neutral'></span>
  110 |     | <span class='neutral'>    function logBytes16(bytes16 p0) internal view {</span>
  111 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes16)&quot;, p0));</span>
  112 |     | <span class='neutral'>    }</span>
  113 |     | <span class='neutral'></span>
  114 |     | <span class='neutral'>    function logBytes17(bytes17 p0) internal view {</span>
  115 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes17)&quot;, p0));</span>
  116 |     | <span class='neutral'>    }</span>
  117 |     | <span class='neutral'></span>
  118 |     | <span class='neutral'>    function logBytes18(bytes18 p0) internal view {</span>
  119 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes18)&quot;, p0));</span>
  120 |     | <span class='neutral'>    }</span>
  121 |     | <span class='neutral'></span>
  122 |     | <span class='neutral'>    function logBytes19(bytes19 p0) internal view {</span>
  123 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes19)&quot;, p0));</span>
  124 |     | <span class='neutral'>    }</span>
  125 |     | <span class='neutral'></span>
  126 |     | <span class='neutral'>    function logBytes20(bytes20 p0) internal view {</span>
  127 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes20)&quot;, p0));</span>
  128 |     | <span class='neutral'>    }</span>
  129 |     | <span class='neutral'></span>
  130 |     | <span class='neutral'>    function logBytes21(bytes21 p0) internal view {</span>
  131 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes21)&quot;, p0));</span>
  132 |     | <span class='neutral'>    }</span>
  133 |     | <span class='neutral'></span>
  134 |     | <span class='neutral'>    function logBytes22(bytes22 p0) internal view {</span>
  135 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes22)&quot;, p0));</span>
  136 |     | <span class='neutral'>    }</span>
  137 |     | <span class='neutral'></span>
  138 |     | <span class='neutral'>    function logBytes23(bytes23 p0) internal view {</span>
  139 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes23)&quot;, p0));</span>
  140 |     | <span class='neutral'>    }</span>
  141 |     | <span class='neutral'></span>
  142 |     | <span class='neutral'>    function logBytes24(bytes24 p0) internal view {</span>
  143 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes24)&quot;, p0));</span>
  144 |     | <span class='neutral'>    }</span>
  145 |     | <span class='neutral'></span>
  146 |     | <span class='neutral'>    function logBytes25(bytes25 p0) internal view {</span>
  147 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes25)&quot;, p0));</span>
  148 |     | <span class='neutral'>    }</span>
  149 |     | <span class='neutral'></span>
  150 |     | <span class='neutral'>    function logBytes26(bytes26 p0) internal view {</span>
  151 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes26)&quot;, p0));</span>
  152 |     | <span class='neutral'>    }</span>
  153 |     | <span class='neutral'></span>
  154 |     | <span class='neutral'>    function logBytes27(bytes27 p0) internal view {</span>
  155 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes27)&quot;, p0));</span>
  156 |     | <span class='neutral'>    }</span>
  157 |     | <span class='neutral'></span>
  158 |     | <span class='neutral'>    function logBytes28(bytes28 p0) internal view {</span>
  159 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes28)&quot;, p0));</span>
  160 |     | <span class='neutral'>    }</span>
  161 |     | <span class='neutral'></span>
  162 |     | <span class='neutral'>    function logBytes29(bytes29 p0) internal view {</span>
  163 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes29)&quot;, p0));</span>
  164 |     | <span class='neutral'>    }</span>
  165 |     | <span class='neutral'></span>
  166 |     | <span class='neutral'>    function logBytes30(bytes30 p0) internal view {</span>
  167 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes30)&quot;, p0));</span>
  168 |     | <span class='neutral'>    }</span>
  169 |     | <span class='neutral'></span>
  170 |     | <span class='neutral'>    function logBytes31(bytes31 p0) internal view {</span>
  171 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes31)&quot;, p0));</span>
  172 |     | <span class='neutral'>    }</span>
  173 |     | <span class='neutral'></span>
  174 |     | <span class='neutral'>    function logBytes32(bytes32 p0) internal view {</span>
  175 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes32)&quot;, p0));</span>
  176 |     | <span class='neutral'>    }</span>
  177 |     | <span class='neutral'></span>
  178 |     | <span class='neutral'>    function log(uint256 p0) internal view {</span>
  179 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256)&quot;, p0));</span>
  180 |     | <span class='neutral'>    }</span>
  181 |     | <span class='neutral'></span>
  182 |     | <span class='neutral'>    function log(int256 p0) internal view {</span>
  183 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(int256)&quot;, p0));</span>
  184 |     | <span class='neutral'>    }</span>
  185 |     | <span class='neutral'></span>
  186 |     | <span class='neutral'>    function log(string memory p0) internal view {</span>
  187 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
  188 |     | <span class='neutral'>    }</span>
  189 |     | <span class='neutral'></span>
  190 |     | <span class='neutral'>    function log(bool p0) internal view {</span>
  191 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool)&quot;, p0));</span>
  192 |     | <span class='neutral'>    }</span>
  193 |     | <span class='neutral'></span>
  194 |     | <span class='neutral'>    function log(address p0) internal view {</span>
  195 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address)&quot;, p0));</span>
  196 |     | <span class='neutral'>    }</span>
  197 |     | <span class='neutral'></span>
  198 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1) internal view {</span>
  199 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256)&quot;, p0, p1));</span>
  200 |     | <span class='neutral'>    }</span>
  201 |     | <span class='neutral'></span>
  202 |     | <span class='neutral'>    function log(uint256 p0, string memory p1) internal view {</span>
  203 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string)&quot;, p0, p1));</span>
  204 |     | <span class='neutral'>    }</span>
  205 |     | <span class='neutral'></span>
  206 |     | <span class='neutral'>    function log(uint256 p0, bool p1) internal view {</span>
  207 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool)&quot;, p0, p1));</span>
  208 |     | <span class='neutral'>    }</span>
  209 |     | <span class='neutral'></span>
  210 |     | <span class='neutral'>    function log(uint256 p0, address p1) internal view {</span>
  211 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address)&quot;, p0, p1));</span>
  212 |     | <span class='neutral'>    }</span>
  213 |     | <span class='neutral'></span>
  214 |     | <span class='neutral'>    function log(string memory p0, uint256 p1) internal view {</span>
  215 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256)&quot;, p0, p1));</span>
  216 |     | <span class='neutral'>    }</span>
  217 |     | <span class='neutral'></span>
  218 |     | <span class='neutral'>    function log(string memory p0, int256 p1) internal view {</span>
  219 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,int256)&quot;, p0, p1));</span>
  220 |     | <span class='neutral'>    }</span>
  221 |     | <span class='neutral'></span>
  222 |     | <span class='neutral'>    function log(string memory p0, string memory p1) internal view {</span>
  223 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string)&quot;, p0, p1));</span>
  224 |     | <span class='neutral'>    }</span>
  225 |     | <span class='neutral'></span>
  226 |     | <span class='neutral'>    function log(string memory p0, bool p1) internal view {</span>
  227 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool)&quot;, p0, p1));</span>
  228 |     | <span class='neutral'>    }</span>
  229 |     | <span class='neutral'></span>
  230 |     | <span class='neutral'>    function log(string memory p0, address p1) internal view {</span>
  231 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address)&quot;, p0, p1));</span>
  232 |     | <span class='neutral'>    }</span>
  233 |     | <span class='neutral'></span>
  234 |     | <span class='neutral'>    function log(bool p0, uint256 p1) internal view {</span>
  235 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256)&quot;, p0, p1));</span>
  236 |     | <span class='neutral'>    }</span>
  237 |     | <span class='neutral'></span>
  238 |     | <span class='neutral'>    function log(bool p0, string memory p1) internal view {</span>
  239 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string)&quot;, p0, p1));</span>
  240 |     | <span class='neutral'>    }</span>
  241 |     | <span class='neutral'></span>
  242 |     | <span class='neutral'>    function log(bool p0, bool p1) internal view {</span>
  243 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool)&quot;, p0, p1));</span>
  244 |     | <span class='neutral'>    }</span>
  245 |     | <span class='neutral'></span>
  246 |     | <span class='neutral'>    function log(bool p0, address p1) internal view {</span>
  247 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address)&quot;, p0, p1));</span>
  248 |     | <span class='neutral'>    }</span>
  249 |     | <span class='neutral'></span>
  250 |     | <span class='neutral'>    function log(address p0, uint256 p1) internal view {</span>
  251 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256)&quot;, p0, p1));</span>
  252 |     | <span class='neutral'>    }</span>
  253 |     | <span class='neutral'></span>
  254 |     | <span class='neutral'>    function log(address p0, string memory p1) internal view {</span>
  255 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string)&quot;, p0, p1));</span>
  256 |     | <span class='neutral'>    }</span>
  257 |     | <span class='neutral'></span>
  258 |     | <span class='neutral'>    function log(address p0, bool p1) internal view {</span>
  259 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool)&quot;, p0, p1));</span>
  260 |     | <span class='neutral'>    }</span>
  261 |     | <span class='neutral'></span>
  262 |     | <span class='neutral'>    function log(address p0, address p1) internal view {</span>
  263 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address)&quot;, p0, p1));</span>
  264 |     | <span class='neutral'>    }</span>
  265 |     | <span class='neutral'></span>
  266 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2) internal view {</span>
  267 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256)&quot;, p0, p1, p2));</span>
  268 |     | <span class='neutral'>    }</span>
  269 |     | <span class='neutral'></span>
  270 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2) internal view {</span>
  271 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string)&quot;, p0, p1, p2));</span>
  272 |     | <span class='neutral'>    }</span>
  273 |     | <span class='neutral'></span>
  274 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2) internal view {</span>
  275 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool)&quot;, p0, p1, p2));</span>
  276 |     | <span class='neutral'>    }</span>
  277 |     | <span class='neutral'></span>
  278 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2) internal view {</span>
  279 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address)&quot;, p0, p1, p2));</span>
  280 |     | <span class='neutral'>    }</span>
  281 |     | <span class='neutral'></span>
  282 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2) internal view {</span>
  283 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256)&quot;, p0, p1, p2));</span>
  284 |     | <span class='neutral'>    }</span>
  285 |     | <span class='neutral'></span>
  286 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2) internal view {</span>
  287 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string)&quot;, p0, p1, p2));</span>
  288 |     | <span class='neutral'>    }</span>
  289 |     | <span class='neutral'></span>
  290 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2) internal view {</span>
  291 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool)&quot;, p0, p1, p2));</span>
  292 |     | <span class='neutral'>    }</span>
  293 |     | <span class='neutral'></span>
  294 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2) internal view {</span>
  295 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address)&quot;, p0, p1, p2));</span>
  296 |     | <span class='neutral'>    }</span>
  297 |     | <span class='neutral'></span>
  298 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2) internal view {</span>
  299 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256)&quot;, p0, p1, p2));</span>
  300 |     | <span class='neutral'>    }</span>
  301 |     | <span class='neutral'></span>
  302 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2) internal view {</span>
  303 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string)&quot;, p0, p1, p2));</span>
  304 |     | <span class='neutral'>    }</span>
  305 |     | <span class='neutral'></span>
  306 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2) internal view {</span>
  307 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool)&quot;, p0, p1, p2));</span>
  308 |     | <span class='neutral'>    }</span>
  309 |     | <span class='neutral'></span>
  310 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2) internal view {</span>
  311 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address)&quot;, p0, p1, p2));</span>
  312 |     | <span class='neutral'>    }</span>
  313 |     | <span class='neutral'></span>
  314 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2) internal view {</span>
  315 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256)&quot;, p0, p1, p2));</span>
  316 |     | <span class='neutral'>    }</span>
  317 |     | <span class='neutral'></span>
  318 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2) internal view {</span>
  319 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string)&quot;, p0, p1, p2));</span>
  320 |     | <span class='neutral'>    }</span>
  321 |     | <span class='neutral'></span>
  322 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2) internal view {</span>
  323 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool)&quot;, p0, p1, p2));</span>
  324 |     | <span class='neutral'>    }</span>
  325 |     | <span class='neutral'></span>
  326 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2) internal view {</span>
  327 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address)&quot;, p0, p1, p2));</span>
  328 |     | <span class='neutral'>    }</span>
  329 |     | <span class='neutral'></span>
  330 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2) internal view {</span>
  331 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256)&quot;, p0, p1, p2));</span>
  332 |     | <span class='neutral'>    }</span>
  333 |     | <span class='neutral'></span>
  334 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2) internal view {</span>
  335 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string)&quot;, p0, p1, p2));</span>
  336 |     | <span class='neutral'>    }</span>
  337 |     | <span class='neutral'></span>
  338 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2) internal view {</span>
  339 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool)&quot;, p0, p1, p2));</span>
  340 |     | <span class='neutral'>    }</span>
  341 |     | <span class='neutral'></span>
  342 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2) internal view {</span>
  343 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address)&quot;, p0, p1, p2));</span>
  344 |     | <span class='neutral'>    }</span>
  345 |     | <span class='neutral'></span>
  346 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2) internal view {</span>
  347 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256)&quot;, p0, p1, p2));</span>
  348 |     | <span class='neutral'>    }</span>
  349 |     | <span class='neutral'></span>
  350 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2) internal view {</span>
  351 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string)&quot;, p0, p1, p2));</span>
  352 |     | <span class='neutral'>    }</span>
  353 |     | <span class='neutral'></span>
  354 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2) internal view {</span>
  355 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool)&quot;, p0, p1, p2));</span>
  356 |     | <span class='neutral'>    }</span>
  357 |     | <span class='neutral'></span>
  358 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2) internal view {</span>
  359 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address)&quot;, p0, p1, p2));</span>
  360 |     | <span class='neutral'>    }</span>
  361 |     | <span class='neutral'></span>
  362 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2) internal view {</span>
  363 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256)&quot;, p0, p1, p2));</span>
  364 |     | <span class='neutral'>    }</span>
  365 |     | <span class='neutral'></span>
  366 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2) internal view {</span>
  367 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string)&quot;, p0, p1, p2));</span>
  368 |     | <span class='neutral'>    }</span>
  369 |     | <span class='neutral'></span>
  370 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2) internal view {</span>
  371 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool)&quot;, p0, p1, p2));</span>
  372 |     | <span class='neutral'>    }</span>
  373 |     | <span class='neutral'></span>
  374 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2) internal view {</span>
  375 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address)&quot;, p0, p1, p2));</span>
  376 |     | <span class='neutral'>    }</span>
  377 |     | <span class='neutral'></span>
  378 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2) internal view {</span>
  379 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256)&quot;, p0, p1, p2));</span>
  380 |     | <span class='neutral'>    }</span>
  381 |     | <span class='neutral'></span>
  382 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2) internal view {</span>
  383 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string)&quot;, p0, p1, p2));</span>
  384 |     | <span class='neutral'>    }</span>
  385 |     | <span class='neutral'></span>
  386 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2) internal view {</span>
  387 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool)&quot;, p0, p1, p2));</span>
  388 |     | <span class='neutral'>    }</span>
  389 |     | <span class='neutral'></span>
  390 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2) internal view {</span>
  391 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address)&quot;, p0, p1, p2));</span>
  392 |     | <span class='neutral'>    }</span>
  393 |     | <span class='neutral'></span>
  394 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2) internal view {</span>
  395 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256)&quot;, p0, p1, p2));</span>
  396 |     | <span class='neutral'>    }</span>
  397 |     | <span class='neutral'></span>
  398 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2) internal view {</span>
  399 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string)&quot;, p0, p1, p2));</span>
  400 |     | <span class='neutral'>    }</span>
  401 |     | <span class='neutral'></span>
  402 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2) internal view {</span>
  403 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool)&quot;, p0, p1, p2));</span>
  404 |     | <span class='neutral'>    }</span>
  405 |     | <span class='neutral'></span>
  406 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2) internal view {</span>
  407 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address)&quot;, p0, p1, p2));</span>
  408 |     | <span class='neutral'>    }</span>
  409 |     | <span class='neutral'></span>
  410 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2) internal view {</span>
  411 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256)&quot;, p0, p1, p2));</span>
  412 |     | <span class='neutral'>    }</span>
  413 |     | <span class='neutral'></span>
  414 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2) internal view {</span>
  415 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string)&quot;, p0, p1, p2));</span>
  416 |     | <span class='neutral'>    }</span>
  417 |     | <span class='neutral'></span>
  418 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2) internal view {</span>
  419 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool)&quot;, p0, p1, p2));</span>
  420 |     | <span class='neutral'>    }</span>
  421 |     | <span class='neutral'></span>
  422 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2) internal view {</span>
  423 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address)&quot;, p0, p1, p2));</span>
  424 |     | <span class='neutral'>    }</span>
  425 |     | <span class='neutral'></span>
  426 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2) internal view {</span>
  427 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256)&quot;, p0, p1, p2));</span>
  428 |     | <span class='neutral'>    }</span>
  429 |     | <span class='neutral'></span>
  430 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2) internal view {</span>
  431 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string)&quot;, p0, p1, p2));</span>
  432 |     | <span class='neutral'>    }</span>
  433 |     | <span class='neutral'></span>
  434 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2) internal view {</span>
  435 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool)&quot;, p0, p1, p2));</span>
  436 |     | <span class='neutral'>    }</span>
  437 |     | <span class='neutral'></span>
  438 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2) internal view {</span>
  439 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address)&quot;, p0, p1, p2));</span>
  440 |     | <span class='neutral'>    }</span>
  441 |     | <span class='neutral'></span>
  442 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2) internal view {</span>
  443 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256)&quot;, p0, p1, p2));</span>
  444 |     | <span class='neutral'>    }</span>
  445 |     | <span class='neutral'></span>
  446 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2) internal view {</span>
  447 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string)&quot;, p0, p1, p2));</span>
  448 |     | <span class='neutral'>    }</span>
  449 |     | <span class='neutral'></span>
  450 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2) internal view {</span>
  451 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool)&quot;, p0, p1, p2));</span>
  452 |     | <span class='neutral'>    }</span>
  453 |     | <span class='neutral'></span>
  454 |     | <span class='neutral'>    function log(bool p0, address p1, address p2) internal view {</span>
  455 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address)&quot;, p0, p1, p2));</span>
  456 |     | <span class='neutral'>    }</span>
  457 |     | <span class='neutral'></span>
  458 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2) internal view {</span>
  459 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256)&quot;, p0, p1, p2));</span>
  460 |     | <span class='neutral'>    }</span>
  461 |     | <span class='neutral'></span>
  462 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2) internal view {</span>
  463 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string)&quot;, p0, p1, p2));</span>
  464 |     | <span class='neutral'>    }</span>
  465 |     | <span class='neutral'></span>
  466 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2) internal view {</span>
  467 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool)&quot;, p0, p1, p2));</span>
  468 |     | <span class='neutral'>    }</span>
  469 |     | <span class='neutral'></span>
  470 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2) internal view {</span>
  471 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address)&quot;, p0, p1, p2));</span>
  472 |     | <span class='neutral'>    }</span>
  473 |     | <span class='neutral'></span>
  474 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2) internal view {</span>
  475 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256)&quot;, p0, p1, p2));</span>
  476 |     | <span class='neutral'>    }</span>
  477 |     | <span class='neutral'></span>
  478 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2) internal view {</span>
  479 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string)&quot;, p0, p1, p2));</span>
  480 |     | <span class='neutral'>    }</span>
  481 |     | <span class='neutral'></span>
  482 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2) internal view {</span>
  483 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool)&quot;, p0, p1, p2));</span>
  484 |     | <span class='neutral'>    }</span>
  485 |     | <span class='neutral'></span>
  486 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2) internal view {</span>
  487 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address)&quot;, p0, p1, p2));</span>
  488 |     | <span class='neutral'>    }</span>
  489 |     | <span class='neutral'></span>
  490 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2) internal view {</span>
  491 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256)&quot;, p0, p1, p2));</span>
  492 |     | <span class='neutral'>    }</span>
  493 |     | <span class='neutral'></span>
  494 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2) internal view {</span>
  495 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string)&quot;, p0, p1, p2));</span>
  496 |     | <span class='neutral'>    }</span>
  497 |     | <span class='neutral'></span>
  498 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2) internal view {</span>
  499 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool)&quot;, p0, p1, p2));</span>
  500 |     | <span class='neutral'>    }</span>
  501 |     | <span class='neutral'></span>
  502 |     | <span class='neutral'>    function log(address p0, bool p1, address p2) internal view {</span>
  503 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address)&quot;, p0, p1, p2));</span>
  504 |     | <span class='neutral'>    }</span>
  505 |     | <span class='neutral'></span>
  506 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2) internal view {</span>
  507 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256)&quot;, p0, p1, p2));</span>
  508 |     | <span class='neutral'>    }</span>
  509 |     | <span class='neutral'></span>
  510 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2) internal view {</span>
  511 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string)&quot;, p0, p1, p2));</span>
  512 |     | <span class='neutral'>    }</span>
  513 |     | <span class='neutral'></span>
  514 |     | <span class='neutral'>    function log(address p0, address p1, bool p2) internal view {</span>
  515 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool)&quot;, p0, p1, p2));</span>
  516 |     | <span class='neutral'>    }</span>
  517 |     | <span class='neutral'></span>
  518 |     | <span class='neutral'>    function log(address p0, address p1, address p2) internal view {</span>
  519 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address)&quot;, p0, p1, p2));</span>
  520 |     | <span class='neutral'>    }</span>
  521 |     | <span class='neutral'></span>
  522 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {</span>
  523 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  524 |     | <span class='neutral'>    }</span>
  525 |     | <span class='neutral'></span>
  526 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {</span>
  527 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256,string)&quot;, p0, p1, p2, p3));</span>
  528 |     | <span class='neutral'>    }</span>
  529 |     | <span class='neutral'></span>
  530 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {</span>
  531 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  532 |     | <span class='neutral'>    }</span>
  533 |     | <span class='neutral'></span>
  534 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {</span>
  535 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256,address)&quot;, p0, p1, p2, p3));</span>
  536 |     | <span class='neutral'>    }</span>
  537 |     | <span class='neutral'></span>
  538 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {</span>
  539 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string,uint256)&quot;, p0, p1, p2, p3));</span>
  540 |     | <span class='neutral'>    }</span>
  541 |     | <span class='neutral'></span>
  542 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {</span>
  543 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string,string)&quot;, p0, p1, p2, p3));</span>
  544 |     | <span class='neutral'>    }</span>
  545 |     | <span class='neutral'></span>
  546 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {</span>
  547 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string,bool)&quot;, p0, p1, p2, p3));</span>
  548 |     | <span class='neutral'>    }</span>
  549 |     | <span class='neutral'></span>
  550 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {</span>
  551 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string,address)&quot;, p0, p1, p2, p3));</span>
  552 |     | <span class='neutral'>    }</span>
  553 |     | <span class='neutral'></span>
  554 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {</span>
  555 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  556 |     | <span class='neutral'>    }</span>
  557 |     | <span class='neutral'></span>
  558 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {</span>
  559 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool,string)&quot;, p0, p1, p2, p3));</span>
  560 |     | <span class='neutral'>    }</span>
  561 |     | <span class='neutral'></span>
  562 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {</span>
  563 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool,bool)&quot;, p0, p1, p2, p3));</span>
  564 |     | <span class='neutral'>    }</span>
  565 |     | <span class='neutral'></span>
  566 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, address p3) internal view {</span>
  567 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool,address)&quot;, p0, p1, p2, p3));</span>
  568 |     | <span class='neutral'>    }</span>
  569 |     | <span class='neutral'></span>
  570 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {</span>
  571 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address,uint256)&quot;, p0, p1, p2, p3));</span>
  572 |     | <span class='neutral'>    }</span>
  573 |     | <span class='neutral'></span>
  574 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {</span>
  575 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address,string)&quot;, p0, p1, p2, p3));</span>
  576 |     | <span class='neutral'>    }</span>
  577 |     | <span class='neutral'></span>
  578 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, bool p3) internal view {</span>
  579 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address,bool)&quot;, p0, p1, p2, p3));</span>
  580 |     | <span class='neutral'>    }</span>
  581 |     | <span class='neutral'></span>
  582 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, address p3) internal view {</span>
  583 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address,address)&quot;, p0, p1, p2, p3));</span>
  584 |     | <span class='neutral'>    }</span>
  585 |     | <span class='neutral'></span>
  586 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {</span>
  587 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  588 |     | <span class='neutral'>    }</span>
  589 |     | <span class='neutral'></span>
  590 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {</span>
  591 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256,string)&quot;, p0, p1, p2, p3));</span>
  592 |     | <span class='neutral'>    }</span>
  593 |     | <span class='neutral'></span>
  594 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {</span>
  595 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  596 |     | <span class='neutral'>    }</span>
  597 |     | <span class='neutral'></span>
  598 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {</span>
  599 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256,address)&quot;, p0, p1, p2, p3));</span>
  600 |     | <span class='neutral'>    }</span>
  601 |     | <span class='neutral'></span>
  602 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {</span>
  603 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string,uint256)&quot;, p0, p1, p2, p3));</span>
  604 |     | <span class='neutral'>    }</span>
  605 |     | <span class='neutral'></span>
  606 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {</span>
  607 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string,string)&quot;, p0, p1, p2, p3));</span>
  608 |     | <span class='neutral'>    }</span>
  609 |     | <span class='neutral'></span>
  610 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {</span>
  611 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string,bool)&quot;, p0, p1, p2, p3));</span>
  612 |     | <span class='neutral'>    }</span>
  613 |     | <span class='neutral'></span>
  614 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2, address p3) internal view {</span>
  615 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string,address)&quot;, p0, p1, p2, p3));</span>
  616 |     | <span class='neutral'>    }</span>
  617 |     | <span class='neutral'></span>
  618 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {</span>
  619 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  620 |     | <span class='neutral'>    }</span>
  621 |     | <span class='neutral'></span>
  622 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {</span>
  623 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool,string)&quot;, p0, p1, p2, p3));</span>
  624 |     | <span class='neutral'>    }</span>
  625 |     | <span class='neutral'></span>
  626 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2, bool p3) internal view {</span>
  627 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
  628 |     | <span class='neutral'>    }</span>
  629 |     | <span class='neutral'></span>
  630 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2, address p3) internal view {</span>
  631 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool,address)&quot;, p0, p1, p2, p3));</span>
  632 |     | <span class='neutral'>    }</span>
  633 |     | <span class='neutral'></span>
  634 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {</span>
  635 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address,uint256)&quot;, p0, p1, p2, p3));</span>
  636 |     | <span class='neutral'>    }</span>
  637 |     | <span class='neutral'></span>
  638 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2, string memory p3) internal view {</span>
  639 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address,string)&quot;, p0, p1, p2, p3));</span>
  640 |     | <span class='neutral'>    }</span>
  641 |     | <span class='neutral'></span>
  642 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2, bool p3) internal view {</span>
  643 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address,bool)&quot;, p0, p1, p2, p3));</span>
  644 |     | <span class='neutral'>    }</span>
  645 |     | <span class='neutral'></span>
  646 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2, address p3) internal view {</span>
  647 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address,address)&quot;, p0, p1, p2, p3));</span>
  648 |     | <span class='neutral'>    }</span>
  649 |     | <span class='neutral'></span>
  650 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {</span>
  651 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  652 |     | <span class='neutral'>    }</span>
  653 |     | <span class='neutral'></span>
  654 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {</span>
  655 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256,string)&quot;, p0, p1, p2, p3));</span>
  656 |     | <span class='neutral'>    }</span>
  657 |     | <span class='neutral'></span>
  658 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {</span>
  659 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  660 |     | <span class='neutral'>    }</span>
  661 |     | <span class='neutral'></span>
  662 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, address p3) internal view {</span>
  663 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256,address)&quot;, p0, p1, p2, p3));</span>
  664 |     | <span class='neutral'>    }</span>
  665 |     | <span class='neutral'></span>
  666 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {</span>
  667 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string,uint256)&quot;, p0, p1, p2, p3));</span>
  668 |     | <span class='neutral'>    }</span>
  669 |     | <span class='neutral'></span>
  670 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {</span>
  671 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string,string)&quot;, p0, p1, p2, p3));</span>
  672 |     | <span class='neutral'>    }</span>
  673 |     | <span class='neutral'></span>
  674 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2, bool p3) internal view {</span>
  675 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
  676 |     | <span class='neutral'>    }</span>
  677 |     | <span class='neutral'></span>
  678 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2, address p3) internal view {</span>
  679 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string,address)&quot;, p0, p1, p2, p3));</span>
  680 |     | <span class='neutral'>    }</span>
  681 |     | <span class='neutral'></span>
  682 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {</span>
  683 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  684 |     | <span class='neutral'>    }</span>
  685 |     | <span class='neutral'></span>
  686 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, string memory p3) internal view {</span>
  687 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
  688 |     | <span class='neutral'>    }</span>
  689 |     | <span class='neutral'></span>
  690 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, bool p3) internal view {</span>
  691 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
  692 |     | <span class='neutral'>    }</span>
  693 |     | <span class='neutral'></span>
  694 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, address p3) internal view {</span>
  695 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
  696 |     | <span class='neutral'>    }</span>
  697 |     | <span class='neutral'></span>
  698 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, uint256 p3) internal view {</span>
  699 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address,uint256)&quot;, p0, p1, p2, p3));</span>
  700 |     | <span class='neutral'>    }</span>
  701 |     | <span class='neutral'></span>
  702 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, string memory p3) internal view {</span>
  703 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address,string)&quot;, p0, p1, p2, p3));</span>
  704 |     | <span class='neutral'>    }</span>
  705 |     | <span class='neutral'></span>
  706 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, bool p3) internal view {</span>
  707 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
  708 |     | <span class='neutral'>    }</span>
  709 |     | <span class='neutral'></span>
  710 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, address p3) internal view {</span>
  711 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address,address)&quot;, p0, p1, p2, p3));</span>
  712 |     | <span class='neutral'>    }</span>
  713 |     | <span class='neutral'></span>
  714 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {</span>
  715 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  716 |     | <span class='neutral'>    }</span>
  717 |     | <span class='neutral'></span>
  718 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {</span>
  719 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256,string)&quot;, p0, p1, p2, p3));</span>
  720 |     | <span class='neutral'>    }</span>
  721 |     | <span class='neutral'></span>
  722 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, bool p3) internal view {</span>
  723 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  724 |     | <span class='neutral'>    }</span>
  725 |     | <span class='neutral'></span>
  726 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, address p3) internal view {</span>
  727 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256,address)&quot;, p0, p1, p2, p3));</span>
  728 |     | <span class='neutral'>    }</span>
  729 |     | <span class='neutral'></span>
  730 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {</span>
  731 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string,uint256)&quot;, p0, p1, p2, p3));</span>
  732 |     | <span class='neutral'>    }</span>
  733 |     | <span class='neutral'></span>
  734 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2, string memory p3) internal view {</span>
  735 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string,string)&quot;, p0, p1, p2, p3));</span>
  736 |     | <span class='neutral'>    }</span>
  737 |     | <span class='neutral'></span>
  738 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2, bool p3) internal view {</span>
  739 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string,bool)&quot;, p0, p1, p2, p3));</span>
  740 |     | <span class='neutral'>    }</span>
  741 |     | <span class='neutral'></span>
  742 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2, address p3) internal view {</span>
  743 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string,address)&quot;, p0, p1, p2, p3));</span>
  744 |     | <span class='neutral'>    }</span>
  745 |     | <span class='neutral'></span>
  746 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, uint256 p3) internal view {</span>
  747 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  748 |     | <span class='neutral'>    }</span>
  749 |     | <span class='neutral'></span>
  750 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, string memory p3) internal view {</span>
  751 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool,string)&quot;, p0, p1, p2, p3));</span>
  752 |     | <span class='neutral'>    }</span>
  753 |     | <span class='neutral'></span>
  754 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, bool p3) internal view {</span>
  755 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
  756 |     | <span class='neutral'>    }</span>
  757 |     | <span class='neutral'></span>
  758 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, address p3) internal view {</span>
  759 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool,address)&quot;, p0, p1, p2, p3));</span>
  760 |     | <span class='neutral'>    }</span>
  761 |     | <span class='neutral'></span>
  762 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, uint256 p3) internal view {</span>
  763 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address,uint256)&quot;, p0, p1, p2, p3));</span>
  764 |     | <span class='neutral'>    }</span>
  765 |     | <span class='neutral'></span>
  766 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, string memory p3) internal view {</span>
  767 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address,string)&quot;, p0, p1, p2, p3));</span>
  768 |     | <span class='neutral'>    }</span>
  769 |     | <span class='neutral'></span>
  770 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, bool p3) internal view {</span>
  771 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address,bool)&quot;, p0, p1, p2, p3));</span>
  772 |     | <span class='neutral'>    }</span>
  773 |     | <span class='neutral'></span>
  774 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, address p3) internal view {</span>
  775 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address,address)&quot;, p0, p1, p2, p3));</span>
  776 |     | <span class='neutral'>    }</span>
  777 |     | <span class='neutral'></span>
  778 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {</span>
  779 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  780 |     | <span class='neutral'>    }</span>
  781 |     | <span class='neutral'></span>
  782 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {</span>
  783 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256,string)&quot;, p0, p1, p2, p3));</span>
  784 |     | <span class='neutral'>    }</span>
  785 |     | <span class='neutral'></span>
  786 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {</span>
  787 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  788 |     | <span class='neutral'>    }</span>
  789 |     | <span class='neutral'></span>
  790 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {</span>
  791 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256,address)&quot;, p0, p1, p2, p3));</span>
  792 |     | <span class='neutral'>    }</span>
  793 |     | <span class='neutral'></span>
  794 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {</span>
  795 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string,uint256)&quot;, p0, p1, p2, p3));</span>
  796 |     | <span class='neutral'>    }</span>
  797 |     | <span class='neutral'></span>
  798 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {</span>
  799 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string,string)&quot;, p0, p1, p2, p3));</span>
  800 |     | <span class='neutral'>    }</span>
  801 |     | <span class='neutral'></span>
  802 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {</span>
  803 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string,bool)&quot;, p0, p1, p2, p3));</span>
  804 |     | <span class='neutral'>    }</span>
  805 |     | <span class='neutral'></span>
  806 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2, address p3) internal view {</span>
  807 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string,address)&quot;, p0, p1, p2, p3));</span>
  808 |     | <span class='neutral'>    }</span>
  809 |     | <span class='neutral'></span>
  810 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {</span>
  811 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  812 |     | <span class='neutral'>    }</span>
  813 |     | <span class='neutral'></span>
  814 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {</span>
  815 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool,string)&quot;, p0, p1, p2, p3));</span>
  816 |     | <span class='neutral'>    }</span>
  817 |     | <span class='neutral'></span>
  818 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2, bool p3) internal view {</span>
  819 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool,bool)&quot;, p0, p1, p2, p3));</span>
  820 |     | <span class='neutral'>    }</span>
  821 |     | <span class='neutral'></span>
  822 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2, address p3) internal view {</span>
  823 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool,address)&quot;, p0, p1, p2, p3));</span>
  824 |     | <span class='neutral'>    }</span>
  825 |     | <span class='neutral'></span>
  826 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {</span>
  827 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address,uint256)&quot;, p0, p1, p2, p3));</span>
  828 |     | <span class='neutral'>    }</span>
  829 |     | <span class='neutral'></span>
  830 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2, string memory p3) internal view {</span>
  831 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address,string)&quot;, p0, p1, p2, p3));</span>
  832 |     | <span class='neutral'>    }</span>
  833 |     | <span class='neutral'></span>
  834 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2, bool p3) internal view {</span>
  835 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address,bool)&quot;, p0, p1, p2, p3));</span>
  836 |     | <span class='neutral'>    }</span>
  837 |     | <span class='neutral'></span>
  838 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2, address p3) internal view {</span>
  839 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address,address)&quot;, p0, p1, p2, p3));</span>
  840 |     | <span class='neutral'>    }</span>
  841 |     | <span class='neutral'></span>
  842 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {</span>
  843 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  844 |     | <span class='neutral'>    }</span>
  845 |     | <span class='neutral'></span>
  846 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {</span>
  847 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256,string)&quot;, p0, p1, p2, p3));</span>
  848 |     | <span class='neutral'>    }</span>
  849 |     | <span class='neutral'></span>
  850 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {</span>
  851 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  852 |     | <span class='neutral'>    }</span>
  853 |     | <span class='neutral'></span>
  854 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2, address p3) internal view {</span>
  855 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256,address)&quot;, p0, p1, p2, p3));</span>
  856 |     | <span class='neutral'>    }</span>
  857 |     | <span class='neutral'></span>
  858 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {</span>
  859 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,uint256)&quot;, p0, p1, p2, p3));</span>
  860 |     | <span class='neutral'>    }</span>
  861 |     | <span class='neutral'></span>
  862 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {</span>
  863 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,string)&quot;, p0, p1, p2, p3));</span>
  864 |     | <span class='neutral'>    }</span>
  865 |     | <span class='neutral'></span>
  866 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {</span>
  867 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,bool)&quot;, p0, p1, p2, p3));</span>
  868 |     | <span class='neutral'>    }</span>
  869 |     | <span class='neutral'></span>
  870 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {</span>
  871 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,address)&quot;, p0, p1, p2, p3));</span>
  872 |     | <span class='neutral'>    }</span>
  873 |     | <span class='neutral'></span>
  874 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {</span>
  875 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  876 |     | <span class='neutral'>    }</span>
  877 |     | <span class='neutral'></span>
  878 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {</span>
  879 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,string)&quot;, p0, p1, p2, p3));</span>
  880 |     | <span class='neutral'>    }</span>
  881 |     | <span class='neutral'></span>
  882 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {</span>
  883 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
  884 |     | <span class='neutral'>    }</span>
  885 |     | <span class='neutral'></span>
  886 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, address p3) internal view {</span>
  887 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,address)&quot;, p0, p1, p2, p3));</span>
  888 |     | <span class='neutral'>    }</span>
  889 |     | <span class='neutral'></span>
  890 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, uint256 p3) internal view {</span>
  891 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,uint256)&quot;, p0, p1, p2, p3));</span>
  892 |     | <span class='neutral'>    }</span>
  893 |     | <span class='neutral'></span>
  894 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {</span>
  895 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,string)&quot;, p0, p1, p2, p3));</span>
  896 |     | <span class='neutral'>    }</span>
  897 |     | <span class='neutral'></span>
  898 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, bool p3) internal view {</span>
  899 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,bool)&quot;, p0, p1, p2, p3));</span>
  900 |     | <span class='neutral'>    }</span>
  901 |     | <span class='neutral'></span>
  902 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, address p3) internal view {</span>
  903 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,address)&quot;, p0, p1, p2, p3));</span>
  904 |     | <span class='neutral'>    }</span>
  905 |     | <span class='neutral'></span>
  906 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {</span>
  907 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  908 |     | <span class='neutral'>    }</span>
  909 |     | <span class='neutral'></span>
  910 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {</span>
  911 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256,string)&quot;, p0, p1, p2, p3));</span>
  912 |     | <span class='neutral'>    }</span>
  913 |     | <span class='neutral'></span>
  914 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2, bool p3) internal view {</span>
  915 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  916 |     | <span class='neutral'>    }</span>
  917 |     | <span class='neutral'></span>
  918 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2, address p3) internal view {</span>
  919 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256,address)&quot;, p0, p1, p2, p3));</span>
  920 |     | <span class='neutral'>    }</span>
  921 |     | <span class='neutral'></span>
  922 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {</span>
  923 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,uint256)&quot;, p0, p1, p2, p3));</span>
  924 |     | <span class='neutral'>    }</span>
  925 |     | <span class='neutral'></span>
  926 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {</span>
  927 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,string)&quot;, p0, p1, p2, p3));</span>
  928 |     | <span class='neutral'>    }</span>
  929 |     | <span class='neutral'></span>
  930 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {</span>
  931 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
  932 |     | <span class='neutral'>    }</span>
  933 |     | <span class='neutral'></span>
  934 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, address p3) internal view {</span>
  935 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,address)&quot;, p0, p1, p2, p3));</span>
  936 |     | <span class='neutral'>    }</span>
  937 |     | <span class='neutral'></span>
  938 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, uint256 p3) internal view {</span>
  939 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  940 |     | <span class='neutral'>    }</span>
  941 |     | <span class='neutral'></span>
  942 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {</span>
  943 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
  944 |     | <span class='neutral'>    }</span>
  945 |     | <span class='neutral'></span>
  946 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, bool p3) internal view {</span>
  947 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
  948 |     | <span class='neutral'>    }</span>
  949 |     | <span class='neutral'></span>
  950 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, address p3) internal view {</span>
  951 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
  952 |     | <span class='neutral'>    }</span>
  953 |     | <span class='neutral'></span>
  954 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, uint256 p3) internal view {</span>
  955 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,uint256)&quot;, p0, p1, p2, p3));</span>
  956 |     | <span class='neutral'>    }</span>
  957 |     | <span class='neutral'></span>
  958 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, string memory p3) internal view {</span>
  959 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,string)&quot;, p0, p1, p2, p3));</span>
  960 |     | <span class='neutral'>    }</span>
  961 |     | <span class='neutral'></span>
  962 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, bool p3) internal view {</span>
  963 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
  964 |     | <span class='neutral'>    }</span>
  965 |     | <span class='neutral'></span>
  966 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, address p3) internal view {</span>
  967 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,address)&quot;, p0, p1, p2, p3));</span>
  968 |     | <span class='neutral'>    }</span>
  969 |     | <span class='neutral'></span>
  970 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {</span>
  971 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  972 |     | <span class='neutral'>    }</span>
  973 |     | <span class='neutral'></span>
  974 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2, string memory p3) internal view {</span>
  975 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256,string)&quot;, p0, p1, p2, p3));</span>
  976 |     | <span class='neutral'>    }</span>
  977 |     | <span class='neutral'></span>
  978 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2, bool p3) internal view {</span>
  979 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  980 |     | <span class='neutral'>    }</span>
  981 |     | <span class='neutral'></span>
  982 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2, address p3) internal view {</span>
  983 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256,address)&quot;, p0, p1, p2, p3));</span>
  984 |     | <span class='neutral'>    }</span>
  985 |     | <span class='neutral'></span>
  986 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, uint256 p3) internal view {</span>
  987 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,uint256)&quot;, p0, p1, p2, p3));</span>
  988 |     | <span class='neutral'>    }</span>
  989 |     | <span class='neutral'></span>
  990 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {</span>
  991 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,string)&quot;, p0, p1, p2, p3));</span>
  992 |     | <span class='neutral'>    }</span>
  993 |     | <span class='neutral'></span>
  994 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, bool p3) internal view {</span>
  995 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,bool)&quot;, p0, p1, p2, p3));</span>
  996 |     | <span class='neutral'>    }</span>
  997 |     | <span class='neutral'></span>
  998 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, address p3) internal view {</span>
  999 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1000 |     | <span class='neutral'>    }</span>
 1001 |     | <span class='neutral'></span>
 1002 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, uint256 p3) internal view {</span>
 1003 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1004 |     | <span class='neutral'>    }</span>
 1005 |     | <span class='neutral'></span>
 1006 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, string memory p3) internal view {</span>
 1007 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1008 |     | <span class='neutral'>    }</span>
 1009 |     | <span class='neutral'></span>
 1010 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, bool p3) internal view {</span>
 1011 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1012 |     | <span class='neutral'>    }</span>
 1013 |     | <span class='neutral'></span>
 1014 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, address p3) internal view {</span>
 1015 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1016 |     | <span class='neutral'>    }</span>
 1017 |     | <span class='neutral'></span>
 1018 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, uint256 p3) internal view {</span>
 1019 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1020 |     | <span class='neutral'>    }</span>
 1021 |     | <span class='neutral'></span>
 1022 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, string memory p3) internal view {</span>
 1023 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1024 |     | <span class='neutral'>    }</span>
 1025 |     | <span class='neutral'></span>
 1026 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, bool p3) internal view {</span>
 1027 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1028 |     | <span class='neutral'>    }</span>
 1029 |     | <span class='neutral'></span>
 1030 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, address p3) internal view {</span>
 1031 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1032 |     | <span class='neutral'>    }</span>
 1033 |     | <span class='neutral'></span>
 1034 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {</span>
 1035 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1036 |     | <span class='neutral'>    }</span>
 1037 |     | <span class='neutral'></span>
 1038 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {</span>
 1039 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1040 |     | <span class='neutral'>    }</span>
 1041 |     | <span class='neutral'></span>
 1042 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {</span>
 1043 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1044 |     | <span class='neutral'>    }</span>
 1045 |     | <span class='neutral'></span>
 1046 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, address p3) internal view {</span>
 1047 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1048 |     | <span class='neutral'>    }</span>
 1049 |     | <span class='neutral'></span>
 1050 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {</span>
 1051 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1052 |     | <span class='neutral'>    }</span>
 1053 |     | <span class='neutral'></span>
 1054 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {</span>
 1055 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string,string)&quot;, p0, p1, p2, p3));</span>
 1056 |     | <span class='neutral'>    }</span>
 1057 |     | <span class='neutral'></span>
 1058 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2, bool p3) internal view {</span>
 1059 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string,bool)&quot;, p0, p1, p2, p3));</span>
 1060 |     | <span class='neutral'>    }</span>
 1061 |     | <span class='neutral'></span>
 1062 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2, address p3) internal view {</span>
 1063 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string,address)&quot;, p0, p1, p2, p3));</span>
 1064 |     | <span class='neutral'>    }</span>
 1065 |     | <span class='neutral'></span>
 1066 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {</span>
 1067 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1068 |     | <span class='neutral'>    }</span>
 1069 |     | <span class='neutral'></span>
 1070 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, string memory p3) internal view {</span>
 1071 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool,string)&quot;, p0, p1, p2, p3));</span>
 1072 |     | <span class='neutral'>    }</span>
 1073 |     | <span class='neutral'></span>
 1074 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, bool p3) internal view {</span>
 1075 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1076 |     | <span class='neutral'>    }</span>
 1077 |     | <span class='neutral'></span>
 1078 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, address p3) internal view {</span>
 1079 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool,address)&quot;, p0, p1, p2, p3));</span>
 1080 |     | <span class='neutral'>    }</span>
 1081 |     | <span class='neutral'></span>
 1082 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, uint256 p3) internal view {</span>
 1083 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1084 |     | <span class='neutral'>    }</span>
 1085 |     | <span class='neutral'></span>
 1086 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, string memory p3) internal view {</span>
 1087 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address,string)&quot;, p0, p1, p2, p3));</span>
 1088 |     | <span class='neutral'>    }</span>
 1089 |     | <span class='neutral'></span>
 1090 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, bool p3) internal view {</span>
 1091 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address,bool)&quot;, p0, p1, p2, p3));</span>
 1092 |     | <span class='neutral'>    }</span>
 1093 |     | <span class='neutral'></span>
 1094 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, address p3) internal view {</span>
 1095 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address,address)&quot;, p0, p1, p2, p3));</span>
 1096 |     | <span class='neutral'>    }</span>
 1097 |     | <span class='neutral'></span>
 1098 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {</span>
 1099 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1100 |     | <span class='neutral'>    }</span>
 1101 |     | <span class='neutral'></span>
 1102 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {</span>
 1103 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1104 |     | <span class='neutral'>    }</span>
 1105 |     | <span class='neutral'></span>
 1106 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2, bool p3) internal view {</span>
 1107 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1108 |     | <span class='neutral'>    }</span>
 1109 |     | <span class='neutral'></span>
 1110 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2, address p3) internal view {</span>
 1111 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1112 |     | <span class='neutral'>    }</span>
 1113 |     | <span class='neutral'></span>
 1114 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {</span>
 1115 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1116 |     | <span class='neutral'>    }</span>
 1117 |     | <span class='neutral'></span>
 1118 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {</span>
 1119 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,string)&quot;, p0, p1, p2, p3));</span>
 1120 |     | <span class='neutral'>    }</span>
 1121 |     | <span class='neutral'></span>
 1122 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {</span>
 1123 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,bool)&quot;, p0, p1, p2, p3));</span>
 1124 |     | <span class='neutral'>    }</span>
 1125 |     | <span class='neutral'></span>
 1126 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, address p3) internal view {</span>
 1127 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,address)&quot;, p0, p1, p2, p3));</span>
 1128 |     | <span class='neutral'>    }</span>
 1129 |     | <span class='neutral'></span>
 1130 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, uint256 p3) internal view {</span>
 1131 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1132 |     | <span class='neutral'>    }</span>
 1133 |     | <span class='neutral'></span>
 1134 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {</span>
 1135 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,string)&quot;, p0, p1, p2, p3));</span>
 1136 |     | <span class='neutral'>    }</span>
 1137 |     | <span class='neutral'></span>
 1138 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, bool p3) internal view {</span>
 1139 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1140 |     | <span class='neutral'>    }</span>
 1141 |     | <span class='neutral'></span>
 1142 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, address p3) internal view {</span>
 1143 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,address)&quot;, p0, p1, p2, p3));</span>
 1144 |     | <span class='neutral'>    }</span>
 1145 |     | <span class='neutral'></span>
 1146 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, uint256 p3) internal view {</span>
 1147 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1148 |     | <span class='neutral'>    }</span>
 1149 |     | <span class='neutral'></span>
 1150 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, string memory p3) internal view {</span>
 1151 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,string)&quot;, p0, p1, p2, p3));</span>
 1152 |     | <span class='neutral'>    }</span>
 1153 |     | <span class='neutral'></span>
 1154 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, bool p3) internal view {</span>
 1155 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,bool)&quot;, p0, p1, p2, p3));</span>
 1156 |     | <span class='neutral'>    }</span>
 1157 |     | <span class='neutral'></span>
 1158 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, address p3) internal view {</span>
 1159 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,address)&quot;, p0, p1, p2, p3));</span>
 1160 |     | <span class='neutral'>    }</span>
 1161 |     | <span class='neutral'></span>
 1162 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {</span>
 1163 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1164 |     | <span class='neutral'>    }</span>
 1165 |     | <span class='neutral'></span>
 1166 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, string memory p3) internal view {</span>
 1167 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1168 |     | <span class='neutral'>    }</span>
 1169 |     | <span class='neutral'></span>
 1170 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, bool p3) internal view {</span>
 1171 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1172 |     | <span class='neutral'>    }</span>
 1173 |     | <span class='neutral'></span>
 1174 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, address p3) internal view {</span>
 1175 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1176 |     | <span class='neutral'>    }</span>
 1177 |     | <span class='neutral'></span>
 1178 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, uint256 p3) internal view {</span>
 1179 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1180 |     | <span class='neutral'>    }</span>
 1181 |     | <span class='neutral'></span>
 1182 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {</span>
 1183 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,string)&quot;, p0, p1, p2, p3));</span>
 1184 |     | <span class='neutral'>    }</span>
 1185 |     | <span class='neutral'></span>
 1186 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, bool p3) internal view {</span>
 1187 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
 1188 |     | <span class='neutral'>    }</span>
 1189 |     | <span class='neutral'></span>
 1190 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, address p3) internal view {</span>
 1191 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,address)&quot;, p0, p1, p2, p3));</span>
 1192 |     | <span class='neutral'>    }</span>
 1193 |     | <span class='neutral'></span>
 1194 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, uint256 p3) internal view {</span>
 1195 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1196 |     | <span class='neutral'>    }</span>
 1197 |     | <span class='neutral'></span>
 1198 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, string memory p3) internal view {</span>
 1199 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
 1200 |     | <span class='neutral'>    }</span>
 1201 |     | <span class='neutral'></span>
 1202 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, bool p3) internal view {</span>
 1203 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1204 |     | <span class='neutral'>    }</span>
 1205 |     | <span class='neutral'></span>
 1206 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, address p3) internal view {</span>
 1207 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
 1208 |     | <span class='neutral'>    }</span>
 1209 |     | <span class='neutral'></span>
 1210 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, uint256 p3) internal view {</span>
 1211 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1212 |     | <span class='neutral'>    }</span>
 1213 |     | <span class='neutral'></span>
 1214 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, string memory p3) internal view {</span>
 1215 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,string)&quot;, p0, p1, p2, p3));</span>
 1216 |     | <span class='neutral'>    }</span>
 1217 |     | <span class='neutral'></span>
 1218 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, bool p3) internal view {</span>
 1219 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
 1220 |     | <span class='neutral'>    }</span>
 1221 |     | <span class='neutral'></span>
 1222 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, address p3) internal view {</span>
 1223 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,address)&quot;, p0, p1, p2, p3));</span>
 1224 |     | <span class='neutral'>    }</span>
 1225 |     | <span class='neutral'></span>
 1226 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, uint256 p3) internal view {</span>
 1227 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1228 |     | <span class='neutral'>    }</span>
 1229 |     | <span class='neutral'></span>
 1230 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, string memory p3) internal view {</span>
 1231 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1232 |     | <span class='neutral'>    }</span>
 1233 |     | <span class='neutral'></span>
 1234 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, bool p3) internal view {</span>
 1235 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1236 |     | <span class='neutral'>    }</span>
 1237 |     | <span class='neutral'></span>
 1238 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, address p3) internal view {</span>
 1239 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1240 |     | <span class='neutral'>    }</span>
 1241 |     | <span class='neutral'></span>
 1242 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, uint256 p3) internal view {</span>
 1243 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1244 |     | <span class='neutral'>    }</span>
 1245 |     | <span class='neutral'></span>
 1246 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, string memory p3) internal view {</span>
 1247 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,string)&quot;, p0, p1, p2, p3));</span>
 1248 |     | <span class='neutral'>    }</span>
 1249 |     | <span class='neutral'></span>
 1250 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, bool p3) internal view {</span>
 1251 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1252 |     | <span class='neutral'>    }</span>
 1253 |     | <span class='neutral'></span>
 1254 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, address p3) internal view {</span>
 1255 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1256 |     | <span class='neutral'>    }</span>
 1257 |     | <span class='neutral'></span>
 1258 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, uint256 p3) internal view {</span>
 1259 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1260 |     | <span class='neutral'>    }</span>
 1261 |     | <span class='neutral'></span>
 1262 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, string memory p3) internal view {</span>
 1263 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1264 |     | <span class='neutral'>    }</span>
 1265 |     | <span class='neutral'></span>
 1266 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, bool p3) internal view {</span>
 1267 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1268 |     | <span class='neutral'>    }</span>
 1269 |     | <span class='neutral'></span>
 1270 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, address p3) internal view {</span>
 1271 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1272 |     | <span class='neutral'>    }</span>
 1273 |     | <span class='neutral'></span>
 1274 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, uint256 p3) internal view {</span>
 1275 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1276 |     | <span class='neutral'>    }</span>
 1277 |     | <span class='neutral'></span>
 1278 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, string memory p3) internal view {</span>
 1279 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1280 |     | <span class='neutral'>    }</span>
 1281 |     | <span class='neutral'></span>
 1282 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, bool p3) internal view {</span>
 1283 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1284 |     | <span class='neutral'>    }</span>
 1285 |     | <span class='neutral'></span>
 1286 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, address p3) internal view {</span>
 1287 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1288 |     | <span class='neutral'>    }</span>
 1289 |     | <span class='neutral'></span>
 1290 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {</span>
 1291 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1292 |     | <span class='neutral'>    }</span>
 1293 |     | <span class='neutral'></span>
 1294 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {</span>
 1295 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1296 |     | <span class='neutral'>    }</span>
 1297 |     | <span class='neutral'></span>
 1298 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, bool p3) internal view {</span>
 1299 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1300 |     | <span class='neutral'>    }</span>
 1301 |     | <span class='neutral'></span>
 1302 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, address p3) internal view {</span>
 1303 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1304 |     | <span class='neutral'>    }</span>
 1305 |     | <span class='neutral'></span>
 1306 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {</span>
 1307 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1308 |     | <span class='neutral'>    }</span>
 1309 |     | <span class='neutral'></span>
 1310 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2, string memory p3) internal view {</span>
 1311 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string,string)&quot;, p0, p1, p2, p3));</span>
 1312 |     | <span class='neutral'>    }</span>
 1313 |     | <span class='neutral'></span>
 1314 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2, bool p3) internal view {</span>
 1315 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string,bool)&quot;, p0, p1, p2, p3));</span>
 1316 |     | <span class='neutral'>    }</span>
 1317 |     | <span class='neutral'></span>
 1318 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2, address p3) internal view {</span>
 1319 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string,address)&quot;, p0, p1, p2, p3));</span>
 1320 |     | <span class='neutral'>    }</span>
 1321 |     | <span class='neutral'></span>
 1322 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, uint256 p3) internal view {</span>
 1323 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1324 |     | <span class='neutral'>    }</span>
 1325 |     | <span class='neutral'></span>
 1326 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, string memory p3) internal view {</span>
 1327 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool,string)&quot;, p0, p1, p2, p3));</span>
 1328 |     | <span class='neutral'>    }</span>
 1329 |     | <span class='neutral'></span>
 1330 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, bool p3) internal view {</span>
 1331 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1332 |     | <span class='neutral'>    }</span>
 1333 |     | <span class='neutral'></span>
 1334 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, address p3) internal view {</span>
 1335 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool,address)&quot;, p0, p1, p2, p3));</span>
 1336 |     | <span class='neutral'>    }</span>
 1337 |     | <span class='neutral'></span>
 1338 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, uint256 p3) internal view {</span>
 1339 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1340 |     | <span class='neutral'>    }</span>
 1341 |     | <span class='neutral'></span>
 1342 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, string memory p3) internal view {</span>
 1343 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address,string)&quot;, p0, p1, p2, p3));</span>
 1344 |     | <span class='neutral'>    }</span>
 1345 |     | <span class='neutral'></span>
 1346 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, bool p3) internal view {</span>
 1347 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address,bool)&quot;, p0, p1, p2, p3));</span>
 1348 |     | <span class='neutral'>    }</span>
 1349 |     | <span class='neutral'></span>
 1350 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, address p3) internal view {</span>
 1351 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address,address)&quot;, p0, p1, p2, p3));</span>
 1352 |     | <span class='neutral'>    }</span>
 1353 |     | <span class='neutral'></span>
 1354 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {</span>
 1355 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1356 |     | <span class='neutral'>    }</span>
 1357 |     | <span class='neutral'></span>
 1358 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2, string memory p3) internal view {</span>
 1359 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1360 |     | <span class='neutral'>    }</span>
 1361 |     | <span class='neutral'></span>
 1362 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2, bool p3) internal view {</span>
 1363 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1364 |     | <span class='neutral'>    }</span>
 1365 |     | <span class='neutral'></span>
 1366 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2, address p3) internal view {</span>
 1367 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1368 |     | <span class='neutral'>    }</span>
 1369 |     | <span class='neutral'></span>
 1370 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, uint256 p3) internal view {</span>
 1371 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1372 |     | <span class='neutral'>    }</span>
 1373 |     | <span class='neutral'></span>
 1374 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {</span>
 1375 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,string)&quot;, p0, p1, p2, p3));</span>
 1376 |     | <span class='neutral'>    }</span>
 1377 |     | <span class='neutral'></span>
 1378 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, bool p3) internal view {</span>
 1379 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,bool)&quot;, p0, p1, p2, p3));</span>
 1380 |     | <span class='neutral'>    }</span>
 1381 |     | <span class='neutral'></span>
 1382 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, address p3) internal view {</span>
 1383 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,address)&quot;, p0, p1, p2, p3));</span>
 1384 |     | <span class='neutral'>    }</span>
 1385 |     | <span class='neutral'></span>
 1386 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, uint256 p3) internal view {</span>
 1387 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1388 |     | <span class='neutral'>    }</span>
 1389 |     | <span class='neutral'></span>
 1390 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, string memory p3) internal view {</span>
 1391 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,string)&quot;, p0, p1, p2, p3));</span>
 1392 |     | <span class='neutral'>    }</span>
 1393 |     | <span class='neutral'></span>
 1394 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, bool p3) internal view {</span>
 1395 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1396 |     | <span class='neutral'>    }</span>
 1397 |     | <span class='neutral'></span>
 1398 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, address p3) internal view {</span>
 1399 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,address)&quot;, p0, p1, p2, p3));</span>
 1400 |     | <span class='neutral'>    }</span>
 1401 |     | <span class='neutral'></span>
 1402 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, uint256 p3) internal view {</span>
 1403 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1404 |     | <span class='neutral'>    }</span>
 1405 |     | <span class='neutral'></span>
 1406 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, string memory p3) internal view {</span>
 1407 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,string)&quot;, p0, p1, p2, p3));</span>
 1408 |     | <span class='neutral'>    }</span>
 1409 |     | <span class='neutral'></span>
 1410 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, bool p3) internal view {</span>
 1411 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,bool)&quot;, p0, p1, p2, p3));</span>
 1412 |     | <span class='neutral'>    }</span>
 1413 |     | <span class='neutral'></span>
 1414 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, address p3) internal view {</span>
 1415 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,address)&quot;, p0, p1, p2, p3));</span>
 1416 |     | <span class='neutral'>    }</span>
 1417 |     | <span class='neutral'></span>
 1418 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, uint256 p3) internal view {</span>
 1419 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1420 |     | <span class='neutral'>    }</span>
 1421 |     | <span class='neutral'></span>
 1422 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, string memory p3) internal view {</span>
 1423 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1424 |     | <span class='neutral'>    }</span>
 1425 |     | <span class='neutral'></span>
 1426 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, bool p3) internal view {</span>
 1427 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1428 |     | <span class='neutral'>    }</span>
 1429 |     | <span class='neutral'></span>
 1430 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, address p3) internal view {</span>
 1431 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1432 |     | <span class='neutral'>    }</span>
 1433 |     | <span class='neutral'></span>
 1434 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, uint256 p3) internal view {</span>
 1435 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1436 |     | <span class='neutral'>    }</span>
 1437 |     | <span class='neutral'></span>
 1438 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, string memory p3) internal view {</span>
 1439 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,string)&quot;, p0, p1, p2, p3));</span>
 1440 |     | <span class='neutral'>    }</span>
 1441 |     | <span class='neutral'></span>
 1442 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, bool p3) internal view {</span>
 1443 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
 1444 |     | <span class='neutral'>    }</span>
 1445 |     | <span class='neutral'></span>
 1446 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, address p3) internal view {</span>
 1447 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,address)&quot;, p0, p1, p2, p3));</span>
 1448 |     | <span class='neutral'>    }</span>
 1449 |     | <span class='neutral'></span>
 1450 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, uint256 p3) internal view {</span>
 1451 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1452 |     | <span class='neutral'>    }</span>
 1453 |     | <span class='neutral'></span>
 1454 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, string memory p3) internal view {</span>
 1455 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
 1456 |     | <span class='neutral'>    }</span>
 1457 |     | <span class='neutral'></span>
 1458 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, bool p3) internal view {</span>
 1459 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1460 |     | <span class='neutral'>    }</span>
 1461 |     | <span class='neutral'></span>
 1462 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, address p3) internal view {</span>
 1463 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
 1464 |     | <span class='neutral'>    }</span>
 1465 |     | <span class='neutral'></span>
 1466 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, uint256 p3) internal view {</span>
 1467 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1468 |     | <span class='neutral'>    }</span>
 1469 |     | <span class='neutral'></span>
 1470 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, string memory p3) internal view {</span>
 1471 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,string)&quot;, p0, p1, p2, p3));</span>
 1472 |     | <span class='neutral'>    }</span>
 1473 |     | <span class='neutral'></span>
 1474 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, bool p3) internal view {</span>
 1475 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
 1476 |     | <span class='neutral'>    }</span>
 1477 |     | <span class='neutral'></span>
 1478 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, address p3) internal view {</span>
 1479 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,address)&quot;, p0, p1, p2, p3));</span>
 1480 |     | <span class='neutral'>    }</span>
 1481 |     | <span class='neutral'></span>
 1482 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, uint256 p3) internal view {</span>
 1483 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1484 |     | <span class='neutral'>    }</span>
 1485 |     | <span class='neutral'></span>
 1486 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, string memory p3) internal view {</span>
 1487 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1488 |     | <span class='neutral'>    }</span>
 1489 |     | <span class='neutral'></span>
 1490 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, bool p3) internal view {</span>
 1491 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1492 |     | <span class='neutral'>    }</span>
 1493 |     | <span class='neutral'></span>
 1494 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, address p3) internal view {</span>
 1495 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1496 |     | <span class='neutral'>    }</span>
 1497 |     | <span class='neutral'></span>
 1498 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, uint256 p3) internal view {</span>
 1499 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1500 |     | <span class='neutral'>    }</span>
 1501 |     | <span class='neutral'></span>
 1502 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, string memory p3) internal view {</span>
 1503 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,string)&quot;, p0, p1, p2, p3));</span>
 1504 |     | <span class='neutral'>    }</span>
 1505 |     | <span class='neutral'></span>
 1506 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, bool p3) internal view {</span>
 1507 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1508 |     | <span class='neutral'>    }</span>
 1509 |     | <span class='neutral'></span>
 1510 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, address p3) internal view {</span>
 1511 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1512 |     | <span class='neutral'>    }</span>
 1513 |     | <span class='neutral'></span>
 1514 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, uint256 p3) internal view {</span>
 1515 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1516 |     | <span class='neutral'>    }</span>
 1517 |     | <span class='neutral'></span>
 1518 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, string memory p3) internal view {</span>
 1519 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1520 |     | <span class='neutral'>    }</span>
 1521 |     | <span class='neutral'></span>
 1522 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, bool p3) internal view {</span>
 1523 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1524 |     | <span class='neutral'>    }</span>
 1525 |     | <span class='neutral'></span>
 1526 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, address p3) internal view {</span>
 1527 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1528 |     | <span class='neutral'>    }</span>
 1529 |     | <span class='neutral'></span>
 1530 |     | <span class='neutral'>    function log(address p0, address p1, address p2, uint256 p3) internal view {</span>
 1531 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1532 |     | <span class='neutral'>    }</span>
 1533 |     | <span class='neutral'></span>
 1534 |     | <span class='neutral'>    function log(address p0, address p1, address p2, string memory p3) internal view {</span>
 1535 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1536 |     | <span class='neutral'>    }</span>
 1537 |     | <span class='neutral'></span>
 1538 |     | <span class='neutral'>    function log(address p0, address p1, address p2, bool p3) internal view {</span>
 1539 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1540 |     | <span class='neutral'>    }</span>
 1541 |     | <span class='neutral'></span>
 1542 |     | <span class='neutral'>    function log(address p0, address p1, address p2, address p3) internal view {</span>
 1543 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1544 |     | <span class='neutral'>    }</span>
 1545 |     | <span class='neutral'></span>
 1546 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/forge-std/src/interfaces/IMulticall3.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IMulticall3 {</span>
  7 |     | <span class='neutral'>    struct Call {</span>
  8 |     | <span class='neutral'>        address target;</span>
  9 |     | <span class='neutral'>        bytes callData;</span>
 10 |     | <span class='neutral'>    }</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    struct Call3 {</span>
 13 |     | <span class='neutral'>        address target;</span>
 14 |     | <span class='neutral'>        bool allowFailure;</span>
 15 |     | <span class='neutral'>        bytes callData;</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    struct Call3Value {</span>
 19 |     | <span class='neutral'>        address target;</span>
 20 |     | <span class='neutral'>        bool allowFailure;</span>
 21 |     | <span class='neutral'>        uint256 value;</span>
 22 |     | <span class='neutral'>        bytes callData;</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    struct Result {</span>
 26 |     | <span class='neutral'>        bool success;</span>
 27 |     | <span class='neutral'>        bytes returnData;</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    function aggregate(Call[] calldata calls)</span>
 31 |     | <span class='neutral'>        external</span>
 32 |     | <span class='neutral'>        payable</span>
 33 |     | <span class='neutral'>        returns (uint256 blockNumber, bytes[] memory returnData);</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    function aggregate3(Call3[] calldata calls) external payable returns (Result[] memory returnData);</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    function aggregate3Value(Call3Value[] calldata calls) external payable returns (Result[] memory returnData);</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    function blockAndAggregate(Call[] calldata calls)</span>
 40 |     | <span class='neutral'>        external</span>
 41 |     | <span class='neutral'>        payable</span>
 42 |     | <span class='neutral'>        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    function getBasefee() external view returns (uint256 basefee);</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    function getBlockHash(uint256 blockNumber) external view returns (bytes32 blockHash);</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    function getBlockNumber() external view returns (uint256 blockNumber);</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    function getChainId() external view returns (uint256 chainid);</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    function getCurrentBlockCoinbase() external view returns (address coinbase);</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>    function getCurrentBlockDifficulty() external view returns (uint256 difficulty);</span>
 55 |     | <span class='neutral'></span>
 56 |     | <span class='neutral'>    function getCurrentBlockGasLimit() external view returns (uint256 gaslimit);</span>
 57 |     | <span class='neutral'></span>
 58 |     | <span class='neutral'>    function getCurrentBlockTimestamp() external view returns (uint256 timestamp);</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='neutral'>    function getEthBalance(address addr) external view returns (uint256 balance);</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='neutral'>    function getLastBlockHash() external view returns (bytes32 blockHash);</span>
 63 |     | <span class='neutral'></span>
 64 |     | <span class='neutral'>    function tryAggregate(bool requireSuccess, Call[] calldata calls)</span>
 65 |     | <span class='neutral'>        external</span>
 66 |     | <span class='neutral'>        payable</span>
 67 |     | <span class='neutral'>        returns (Result[] memory returnData);</span>
 68 |     | <span class='neutral'></span>
 69 |     | <span class='neutral'>    function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls)</span>
 70 |     | <span class='neutral'>        external</span>
 71 |     | <span class='neutral'>        payable</span>
 72 |     | <span class='neutral'>        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);</span>
 73 |     | <span class='neutral'>}</span>
 74 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/openzeppelin-contracts/contracts/interfaces/IERC1363.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1363.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;./IERC20.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;./IERC165.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>interface IERC1363 is IERC165, IERC20 {</span>
 10 |     | <span class='neutral'>    /*</span>
 11 |     | <span class='neutral'>     * Note: the ERC-165 identifier for this interface is 0x4bbee2df.</span>
 12 |     | <span class='neutral'>     * 0x4bbee2df ===</span>
 13 |     | <span class='neutral'>     *   bytes4(keccak256(&#39;transferAndCall(address,uint256)&#39;)) ^</span>
 14 |     | <span class='neutral'>     *   bytes4(keccak256(&#39;transferAndCall(address,uint256,bytes)&#39;)) ^</span>
 15 |     | <span class='neutral'>     *   bytes4(keccak256(&#39;transferFromAndCall(address,address,uint256)&#39;)) ^</span>
 16 |     | <span class='neutral'>     *   bytes4(keccak256(&#39;transferFromAndCall(address,address,uint256,bytes)&#39;))</span>
 17 |     | <span class='neutral'>     */</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    /*</span>
 20 |     | <span class='neutral'>     * Note: the ERC-165 identifier for this interface is 0xfb9ec8ce.</span>
 21 |     | <span class='neutral'>     * 0xfb9ec8ce ===</span>
 22 |     | <span class='neutral'>     *   bytes4(keccak256(&#39;approveAndCall(address,uint256)&#39;)) ^</span>
 23 |     | <span class='neutral'>     *   bytes4(keccak256(&#39;approveAndCall(address,uint256,bytes)&#39;))</span>
 24 |     | <span class='neutral'>     */</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    /**</span>
 27 |     | <span class='neutral'>     * @dev Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver</span>
 28 |     | <span class='neutral'>     * @param to address The address which you want to transfer to</span>
 29 |     | <span class='neutral'>     * @param value uint256 The amount of tokens to be transferred</span>
 30 |     | <span class='neutral'>     * @return true unless throwing</span>
 31 |     | <span class='neutral'>     */</span>
 32 |     | <span class='neutral'>    function transferAndCall(address to, uint256 value) external returns (bool);</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /**</span>
 35 |     | <span class='neutral'>     * @dev Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver</span>
 36 |     | <span class='neutral'>     * @param to address The address which you want to transfer to</span>
 37 |     | <span class='neutral'>     * @param value uint256 The amount of tokens to be transferred</span>
 38 |     | <span class='neutral'>     * @param data bytes Additional data with no specified format, sent in call to `to`</span>
 39 |     | <span class='neutral'>     * @return true unless throwing</span>
 40 |     | <span class='neutral'>     */</span>
 41 |     | <span class='neutral'>    function transferAndCall(</span>
 42 |     | <span class='neutral'>        address to,</span>
 43 |     | <span class='neutral'>        uint256 value,</span>
 44 |     | <span class='neutral'>        bytes memory data</span>
 45 |     | <span class='neutral'>    ) external returns (bool);</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    /**</span>
 48 |     | <span class='neutral'>     * @dev Transfer tokens from one address to another and then call `onTransferReceived` on receiver</span>
 49 |     | <span class='neutral'>     * @param from address The address which you want to send tokens from</span>
 50 |     | <span class='neutral'>     * @param to address The address which you want to transfer to</span>
 51 |     | <span class='neutral'>     * @param value uint256 The amount of tokens to be transferred</span>
 52 |     | <span class='neutral'>     * @return true unless throwing</span>
 53 |     | <span class='neutral'>     */</span>
 54 |     | <span class='neutral'>    function transferFromAndCall(</span>
 55 |     | <span class='neutral'>        address from,</span>
 56 |     | <span class='neutral'>        address to,</span>
 57 |     | <span class='neutral'>        uint256 value</span>
 58 |     | <span class='neutral'>    ) external returns (bool);</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='neutral'>    /**</span>
 61 |     | <span class='neutral'>     * @dev Transfer tokens from one address to another and then call `onTransferReceived` on receiver</span>
 62 |     | <span class='neutral'>     * @param from address The address which you want to send tokens from</span>
 63 |     | <span class='neutral'>     * @param to address The address which you want to transfer to</span>
 64 |     | <span class='neutral'>     * @param value uint256 The amount of tokens to be transferred</span>
 65 |     | <span class='neutral'>     * @param data bytes Additional data with no specified format, sent in call to `to`</span>
 66 |     | <span class='neutral'>     * @return true unless throwing</span>
 67 |     | <span class='neutral'>     */</span>
 68 |     | <span class='neutral'>    function transferFromAndCall(</span>
 69 |     | <span class='neutral'>        address from,</span>
 70 |     | <span class='neutral'>        address to,</span>
 71 |     | <span class='neutral'>        uint256 value,</span>
 72 |     | <span class='neutral'>        bytes memory data</span>
 73 |     | <span class='neutral'>    ) external returns (bool);</span>
 74 |     | <span class='neutral'></span>
 75 |     | <span class='neutral'>    /**</span>
 76 |     | <span class='neutral'>     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender</span>
 77 |     | <span class='neutral'>     * and then call `onApprovalReceived` on spender.</span>
 78 |     | <span class='neutral'>     * @param spender address The address which will spend the funds</span>
 79 |     | <span class='neutral'>     * @param value uint256 The amount of tokens to be spent</span>
 80 |     | <span class='neutral'>     */</span>
 81 |     | <span class='neutral'>    function approveAndCall(address spender, uint256 value) external returns (bool);</span>
 82 |     | <span class='neutral'></span>
 83 |     | <span class='neutral'>    /**</span>
 84 |     | <span class='neutral'>     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender</span>
 85 |     | <span class='neutral'>     * and then call `onApprovalReceived` on spender.</span>
 86 |     | <span class='neutral'>     * @param spender address The address which will spend the funds</span>
 87 |     | <span class='neutral'>     * @param value uint256 The amount of tokens to be spent</span>
 88 |     | <span class='neutral'>     * @param data bytes Additional data with no specified format, sent in call to `spender`</span>
 89 |     | <span class='neutral'>     */</span>
 90 |     | <span class='neutral'>    function approveAndCall(</span>
 91 |     | <span class='neutral'>        address spender,</span>
 92 |     | <span class='neutral'>        uint256 value,</span>
 93 |     | <span class='neutral'>        bytes memory data</span>
 94 |     | <span class='neutral'>    ) external returns (bool);</span>
 95 |     | <span class='neutral'>}</span>
 96 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/openzeppelin-contracts/contracts/interfaces/IERC1363Receiver.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1363Receiver.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IERC1363Receiver {</span>
  7 |     | <span class='neutral'>    /*</span>
  8 |     | <span class='neutral'>     * Note: the ERC-165 identifier for this interface is 0x88a7ca5c.</span>
  9 |     | <span class='neutral'>     * 0x88a7ca5c === bytes4(keccak256(&quot;onTransferReceived(address,address,uint256,bytes)&quot;))</span>
 10 |     | <span class='neutral'>     */</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    /**</span>
 13 |     | <span class='neutral'>     * @notice Handle the receipt of ERC1363 tokens</span>
 14 |     | <span class='neutral'>     * @dev Any ERC1363 smart contract calls this function on the recipient</span>
 15 |     | <span class='neutral'>     * after a `transfer` or a `transferFrom`. This function MAY throw to revert and reject the</span>
 16 |     | <span class='neutral'>     * transfer. Return of other than the magic value MUST result in the</span>
 17 |     | <span class='neutral'>     * transaction being reverted.</span>
 18 |     | <span class='neutral'>     * Note: the token contract address is always the message sender.</span>
 19 |     | <span class='neutral'>     * @param operator address The address which called `transferAndCall` or `transferFromAndCall` function</span>
 20 |     | <span class='neutral'>     * @param from address The address which are token transferred from</span>
 21 |     | <span class='neutral'>     * @param value uint256 The amount of tokens transferred</span>
 22 |     | <span class='neutral'>     * @param data bytes Additional data with no specified format</span>
 23 |     | <span class='neutral'>     * @return `bytes4(keccak256(&quot;onTransferReceived(address,address,uint256,bytes)&quot;))`</span>
 24 |     | <span class='neutral'>     *  unless throwing</span>
 25 |     | <span class='neutral'>     */</span>
 26 |     | <span class='neutral'>    function onTransferReceived(</span>
 27 |     | <span class='neutral'>        address operator,</span>
 28 |     | <span class='neutral'>        address from,</span>
 29 |     | <span class='neutral'>        uint256 value,</span>
 30 |     | <span class='neutral'>        bytes memory data</span>
 31 |     | <span class='neutral'>    ) external returns (bytes4);</span>
 32 |     | <span class='neutral'>}</span>
 33 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/openzeppelin-contracts/contracts/interfaces/IERC1363Spender.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1363Spender.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IERC1363Spender {</span>
  7 |     | <span class='neutral'>    /*</span>
  8 |     | <span class='neutral'>     * Note: the ERC-165 identifier for this interface is 0x7b04a2d0.</span>
  9 |     | <span class='neutral'>     * 0x7b04a2d0 === bytes4(keccak256(&quot;onApprovalReceived(address,uint256,bytes)&quot;))</span>
 10 |     | <span class='neutral'>     */</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    /**</span>
 13 |     | <span class='neutral'>     * @notice Handle the approval of ERC1363 tokens</span>
 14 |     | <span class='neutral'>     * @dev Any ERC1363 smart contract calls this function on the recipient</span>
 15 |     | <span class='neutral'>     * after an `approve`. This function MAY throw to revert and reject the</span>
 16 |     | <span class='neutral'>     * approval. Return of other than the magic value MUST result in the</span>
 17 |     | <span class='neutral'>     * transaction being reverted.</span>
 18 |     | <span class='neutral'>     * Note: the token contract address is always the message sender.</span>
 19 |     | <span class='neutral'>     * @param owner address The address which called `approveAndCall` function</span>
 20 |     | <span class='neutral'>     * @param value uint256 The amount of tokens to be spent</span>
 21 |     | <span class='neutral'>     * @param data bytes Additional data with no specified format</span>
 22 |     | <span class='neutral'>     * @return `bytes4(keccak256(&quot;onApprovalReceived(address,uint256,bytes)&quot;))`</span>
 23 |     | <span class='neutral'>     *  unless throwing</span>
 24 |     | <span class='neutral'>     */</span>
 25 |     | <span class='neutral'>    function onApprovalReceived(</span>
 26 |     | <span class='neutral'>        address owner,</span>
 27 |     | <span class='neutral'>        uint256 value,</span>
 28 |     | <span class='neutral'>        bytes memory data</span>
 29 |     | <span class='neutral'>    ) external returns (bytes4);</span>
 30 |     | <span class='neutral'>}</span>
 31 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/openzeppelin-contracts/contracts/interfaces/IERC165.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
 2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
 5 |     | <span class='neutral'></span>
 6 |     | <span class='neutral'>import &quot;../utils/introspection/IERC165.sol&quot;;</span>
 7 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
 2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
 5 |     | <span class='neutral'></span>
 6 |     | <span class='neutral'>import &quot;../token/ERC20/IERC20.sol&quot;;</span>
 7 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;./IERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./extensions/IERC20Metadata.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../../utils/Context.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @dev Implementation of the {IERC20} interface.</span>
  12 |     | <span class='neutral'> *</span>
  13 |     | <span class='neutral'> * This implementation is agnostic to the way tokens are created. This means</span>
  14 |     | <span class='neutral'> * that a supply mechanism has to be added in a derived contract using {_mint}.</span>
  15 |     | <span class='neutral'> * For a generic mechanism see {ERC20PresetMinterPauser}.</span>
  16 |     | <span class='neutral'> *</span>
  17 |     | <span class='neutral'> * TIP: For a detailed writeup see our guide</span>
  18 |     | <span class='neutral'> * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How</span>
  19 |     | <span class='neutral'> * to implement supply mechanisms].</span>
  20 |     | <span class='neutral'> *</span>
  21 |     | <span class='neutral'> * We have followed general OpenZeppelin Contracts guidelines: functions revert</span>
  22 |     | <span class='neutral'> * instead returning `false` on failure. This behavior is nonetheless</span>
  23 |     | <span class='neutral'> * conventional and does not conflict with the expectations of ERC20</span>
  24 |     | <span class='neutral'> * applications.</span>
  25 |     | <span class='neutral'> *</span>
  26 |     | <span class='neutral'> * Additionally, an {Approval} event is emitted on calls to {transferFrom}.</span>
  27 |     | <span class='neutral'> * This allows applications to reconstruct the allowance for all accounts just</span>
  28 |     | <span class='neutral'> * by listening to said events. Other implementations of the EIP may not emit</span>
  29 |     | <span class='neutral'> * these events, as it isn&#39;t required by the specification.</span>
  30 |     | <span class='neutral'> *</span>
  31 |     | <span class='neutral'> * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}</span>
  32 |     | <span class='neutral'> * functions have been added to mitigate the well-known issues around setting</span>
  33 |     | <span class='neutral'> * allowances. See {IERC20-approve}.</span>
  34 |     | <span class='unexecuted'> */</span>
  35 |     | <span class='neutral'>contract ERC20 is Context, IERC20, IERC20Metadata {</span>
  36 |     | <span class='neutral'>    mapping(address =&gt; uint256) private _balances;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    uint256 private _totalSupply;</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    string private _name;</span>
  43 |     | <span class='neutral'>    string private _symbol;</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    /**</span>
  46 |     | <span class='neutral'>     * @dev Sets the values for {name} and {symbol}.</span>
  47 |     | <span class='neutral'>     *</span>
  48 |     | <span class='neutral'>     * The default value of {decimals} is 18. To select a different value for</span>
  49 |     | <span class='neutral'>     * {decimals} you should overload it.</span>
  50 |     | <span class='neutral'>     *</span>
  51 |     | <span class='neutral'>     * All two of these values are immutable: they can only be set once during</span>
  52 |     | <span class='neutral'>     * construction.</span>
  53 |     | <span class='neutral'>     */</span>
  54 |     | <span class='unexecuted'>    constructor(string memory name_, string memory symbol_) {</span>
  55 |     | <span class='unexecuted'>        _name = name_;</span>
  56 |     | <span class='unexecuted'>        _symbol = symbol_;</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /**</span>
  60 |     | <span class='neutral'>     * @dev Returns the name of the token.</span>
  61 |     | <span class='neutral'>     */</span>
  62 |     | <span class='unexecuted'>    function name() public view virtual override returns (string memory) {</span>
  63 |     | <span class='unexecuted'>        return _name;</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    /**</span>
  67 |     | <span class='neutral'>     * @dev Returns the symbol of the token, usually a shorter version of the</span>
  68 |     | <span class='neutral'>     * name.</span>
  69 |     | <span class='neutral'>     */</span>
  70 |     | <span class='unexecuted'>    function symbol() public view virtual override returns (string memory) {</span>
  71 |     | <span class='unexecuted'>        return _symbol;</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    /**</span>
  75 |     | <span class='neutral'>     * @dev Returns the number of decimals used to get its user representation.</span>
  76 |     | <span class='neutral'>     * For example, if `decimals` equals `2`, a balance of `505` tokens should</span>
  77 |     | <span class='neutral'>     * be displayed to a user as `5.05` (`505 / 10 ** 2`).</span>
  78 |     | <span class='neutral'>     *</span>
  79 |     | <span class='neutral'>     * Tokens usually opt for a value of 18, imitating the relationship between</span>
  80 |     | <span class='neutral'>     * Ether and Wei. This is the value {ERC20} uses, unless this function is</span>
  81 |     | <span class='neutral'>     * overridden;</span>
  82 |     | <span class='neutral'>     *</span>
  83 |     | <span class='neutral'>     * NOTE: This information is only used for _display_ purposes: it in</span>
  84 |     | <span class='neutral'>     * no way affects any of the arithmetic of the contract, including</span>
  85 |     | <span class='neutral'>     * {IERC20-balanceOf} and {IERC20-transfer}.</span>
  86 |     | <span class='neutral'>     */</span>
  87 |     | <span class='unexecuted'>    function decimals() public view virtual override returns (uint8) {</span>
  88 |     | <span class='unexecuted'>        return 18;</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /**</span>
  92 |     | <span class='neutral'>     * @dev See {IERC20-totalSupply}.</span>
  93 |     | <span class='neutral'>     */</span>
  94 | *r  | <span class='executed'>    function totalSupply() public view virtual override returns (uint256) {</span>
  95 | *r  | <span class='executed'>        return _totalSupply;</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    /**</span>
  99 |     | <span class='neutral'>     * @dev See {IERC20-balanceOf}.</span>
 100 |     | <span class='neutral'>     */</span>
 101 | r   | <span class='reverted'>    function balanceOf(address account) public view virtual override returns (uint256) {</span>
 102 | r   | <span class='reverted'>        return _balances[account];</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    /**</span>
 106 |     | <span class='neutral'>     * @dev See {IERC20-transfer}.</span>
 107 |     | <span class='neutral'>     *</span>
 108 |     | <span class='neutral'>     * Requirements:</span>
 109 |     | <span class='neutral'>     *</span>
 110 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 111 |     | <span class='neutral'>     * - the caller must have a balance of at least `amount`.</span>
 112 |     | <span class='neutral'>     */</span>
 113 |     | <span class='unexecuted'>    function transfer(address to, uint256 amount) public virtual override returns (bool) {</span>
 114 |     | <span class='neutral'>        address owner = _msgSender();</span>
 115 |     | <span class='unexecuted'>        _transfer(owner, to, amount);</span>
 116 |     | <span class='neutral'>        return true;</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    /**</span>
 120 |     | <span class='neutral'>     * @dev See {IERC20-allowance}.</span>
 121 |     | <span class='neutral'>     */</span>
 122 | *   | <span class='executed'>    function allowance(address owner, address spender) public view virtual override returns (uint256) {</span>
 123 | *   | <span class='executed'>        return _allowances[owner][spender];</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    /**</span>
 127 |     | <span class='neutral'>     * @dev See {IERC20-approve}.</span>
 128 |     | <span class='neutral'>     *</span>
 129 |     | <span class='neutral'>     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on</span>
 130 |     | <span class='neutral'>     * `transferFrom`. This is semantically equivalent to an infinite approval.</span>
 131 |     | <span class='neutral'>     *</span>
 132 |     | <span class='neutral'>     * Requirements:</span>
 133 |     | <span class='neutral'>     *</span>
 134 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 135 |     | <span class='neutral'>     */</span>
 136 | *   | <span class='executed'>    function approve(address spender, uint256 amount) public virtual override returns (bool) {</span>
 137 |     | <span class='neutral'>        address owner = _msgSender();</span>
 138 | *   | <span class='executed'>        _approve(owner, spender, amount);</span>
 139 | *   | <span class='executed'>        return true;</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    /**</span>
 143 |     | <span class='neutral'>     * @dev See {IERC20-transferFrom}.</span>
 144 |     | <span class='neutral'>     *</span>
 145 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance. This is not</span>
 146 |     | <span class='neutral'>     * required by the EIP. See the note at the beginning of {ERC20}.</span>
 147 |     | <span class='neutral'>     *</span>
 148 |     | <span class='neutral'>     * NOTE: Does not update the allowance if the current allowance</span>
 149 |     | <span class='neutral'>     * is the maximum `uint256`.</span>
 150 |     | <span class='neutral'>     *</span>
 151 |     | <span class='neutral'>     * Requirements:</span>
 152 |     | <span class='neutral'>     *</span>
 153 |     | <span class='neutral'>     * - `from` and `to` cannot be the zero address.</span>
 154 |     | <span class='neutral'>     * - `from` must have a balance of at least `amount`.</span>
 155 |     | <span class='neutral'>     * - the caller must have allowance for ``from``&#39;s tokens of at least</span>
 156 |     | <span class='neutral'>     * `amount`.</span>
 157 |     | <span class='neutral'>     */</span>
 158 | *   | <span class='executed'>    function transferFrom(</span>
 159 |     | <span class='neutral'>        address from,</span>
 160 |     | <span class='neutral'>        address to,</span>
 161 |     | <span class='neutral'>        uint256 amount</span>
 162 | *   | <span class='executed'>    ) public virtual override returns (bool) {</span>
 163 |     | <span class='neutral'>        address spender = _msgSender();</span>
 164 | *   | <span class='executed'>        _spendAllowance(from, spender, amount);</span>
 165 | *   | <span class='executed'>        _transfer(from, to, amount);</span>
 166 | *   | <span class='executed'>        return true;</span>
 167 |     | <span class='neutral'>    }</span>
 168 |     | <span class='neutral'></span>
 169 |     | <span class='neutral'>    /**</span>
 170 |     | <span class='neutral'>     * @dev Atomically increases the allowance granted to `spender` by the caller.</span>
 171 |     | <span class='neutral'>     *</span>
 172 |     | <span class='neutral'>     * This is an alternative to {approve} that can be used as a mitigation for</span>
 173 |     | <span class='neutral'>     * problems described in {IERC20-approve}.</span>
 174 |     | <span class='neutral'>     *</span>
 175 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance.</span>
 176 |     | <span class='neutral'>     *</span>
 177 |     | <span class='neutral'>     * Requirements:</span>
 178 |     | <span class='neutral'>     *</span>
 179 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 180 |     | <span class='neutral'>     */</span>
 181 |     | <span class='unexecuted'>    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {</span>
 182 |     | <span class='neutral'>        address owner = _msgSender();</span>
 183 |     | <span class='unexecuted'>        _approve(owner, spender, allowance(owner, spender) + addedValue);</span>
 184 |     | <span class='neutral'>        return true;</span>
 185 |     | <span class='neutral'>    }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>    /**</span>
 188 |     | <span class='neutral'>     * @dev Atomically decreases the allowance granted to `spender` by the caller.</span>
 189 |     | <span class='neutral'>     *</span>
 190 |     | <span class='neutral'>     * This is an alternative to {approve} that can be used as a mitigation for</span>
 191 |     | <span class='neutral'>     * problems described in {IERC20-approve}.</span>
 192 |     | <span class='neutral'>     *</span>
 193 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance.</span>
 194 |     | <span class='neutral'>     *</span>
 195 |     | <span class='neutral'>     * Requirements:</span>
 196 |     | <span class='neutral'>     *</span>
 197 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 198 |     | <span class='neutral'>     * - `spender` must have allowance for the caller of at least</span>
 199 |     | <span class='neutral'>     * `subtractedValue`.</span>
 200 |     | <span class='neutral'>     */</span>
 201 |     | <span class='unexecuted'>    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {</span>
 202 |     | <span class='neutral'>        address owner = _msgSender();</span>
 203 |     | <span class='unexecuted'>        uint256 currentAllowance = allowance(owner, spender);</span>
 204 |     | <span class='unexecuted'>        require(currentAllowance &gt;= subtractedValue, &quot;ERC20: decreased allowance below zero&quot;);</span>
 205 |     | <span class='neutral'>        unchecked {</span>
 206 |     | <span class='unexecuted'>            _approve(owner, spender, currentAllowance - subtractedValue);</span>
 207 |     | <span class='neutral'>        }</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='neutral'>        return true;</span>
 210 |     | <span class='neutral'>    }</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='neutral'>    /**</span>
 213 |     | <span class='neutral'>     * @dev Moves `amount` of tokens from `from` to `to`.</span>
 214 |     | <span class='neutral'>     *</span>
 215 |     | <span class='neutral'>     * This internal function is equivalent to {transfer}, and can be used to</span>
 216 |     | <span class='neutral'>     * e.g. implement automatic token fees, slashing mechanisms, etc.</span>
 217 |     | <span class='neutral'>     *</span>
 218 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 219 |     | <span class='neutral'>     *</span>
 220 |     | <span class='neutral'>     * Requirements:</span>
 221 |     | <span class='neutral'>     *</span>
 222 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
 223 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 224 |     | <span class='neutral'>     * - `from` must have a balance of at least `amount`.</span>
 225 |     | <span class='neutral'>     */</span>
 226 | *   | <span class='executed'>    function _transfer(</span>
 227 |     | <span class='neutral'>        address from,</span>
 228 |     | <span class='neutral'>        address to,</span>
 229 |     | <span class='neutral'>        uint256 amount</span>
 230 |     | <span class='neutral'>    ) internal virtual {</span>
 231 | *   | <span class='executed'>        require(from != address(0), &quot;ERC20: transfer from the zero address&quot;);</span>
 232 | *   | <span class='executed'>        require(to != address(0), &quot;ERC20: transfer to the zero address&quot;);</span>
 233 |     | <span class='neutral'></span>
 234 | *   | <span class='executed'>        _beforeTokenTransfer(from, to, amount);</span>
 235 |     | <span class='neutral'></span>
 236 | *   | <span class='executed'>        uint256 fromBalance = _balances[from];</span>
 237 | *   | <span class='executed'>        require(fromBalance &gt;= amount, &quot;ERC20: transfer amount exceeds balance&quot;);</span>
 238 |     | <span class='neutral'>        unchecked {</span>
 239 | *   | <span class='executed'>            _balances[from] = fromBalance - amount;</span>
 240 |     | <span class='neutral'>            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by</span>
 241 |     | <span class='neutral'>            // decrementing then incrementing.</span>
 242 | *   | <span class='executed'>            _balances[to] += amount;</span>
 243 |     | <span class='neutral'>        }</span>
 244 |     | <span class='neutral'></span>
 245 | *   | <span class='executed'>        emit Transfer(from, to, amount);</span>
 246 |     | <span class='neutral'></span>
 247 | *   | <span class='executed'>        _afterTokenTransfer(from, to, amount);</span>
 248 |     | <span class='neutral'>    }</span>
 249 |     | <span class='neutral'></span>
 250 |     | <span class='neutral'>    /** @dev Creates `amount` tokens and assigns them to `account`, increasing</span>
 251 |     | <span class='neutral'>     * the total supply.</span>
 252 |     | <span class='neutral'>     *</span>
 253 |     | <span class='neutral'>     * Emits a {Transfer} event with `from` set to the zero address.</span>
 254 |     | <span class='neutral'>     *</span>
 255 |     | <span class='neutral'>     * Requirements:</span>
 256 |     | <span class='neutral'>     *</span>
 257 |     | <span class='neutral'>     * - `account` cannot be the zero address.</span>
 258 |     | <span class='neutral'>     */</span>
 259 | *   | <span class='executed'>    function _mint(address account, uint256 amount) internal virtual {</span>
 260 | *   | <span class='executed'>        require(account != address(0), &quot;ERC20: mint to the zero address&quot;);</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='unexecuted'>        _beforeTokenTransfer(address(0), account, amount);</span>
 263 |     | <span class='neutral'></span>
 264 | *   | <span class='executed'>        _totalSupply += amount;</span>
 265 |     | <span class='neutral'>        unchecked {</span>
 266 |     | <span class='neutral'>            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.</span>
 267 | *   | <span class='executed'>            _balances[account] += amount;</span>
 268 |     | <span class='neutral'>        }</span>
 269 | *   | <span class='executed'>        emit Transfer(address(0), account, amount);</span>
 270 |     | <span class='neutral'></span>
 271 |     | <span class='neutral'>        _afterTokenTransfer(address(0), account, amount);</span>
 272 |     | <span class='neutral'>    }</span>
 273 |     | <span class='neutral'></span>
 274 |     | <span class='neutral'>    /**</span>
 275 |     | <span class='neutral'>     * @dev Destroys `amount` tokens from `account`, reducing the</span>
 276 |     | <span class='neutral'>     * total supply.</span>
 277 |     | <span class='neutral'>     *</span>
 278 |     | <span class='neutral'>     * Emits a {Transfer} event with `to` set to the zero address.</span>
 279 |     | <span class='neutral'>     *</span>
 280 |     | <span class='neutral'>     * Requirements:</span>
 281 |     | <span class='neutral'>     *</span>
 282 |     | <span class='neutral'>     * - `account` cannot be the zero address.</span>
 283 |     | <span class='neutral'>     * - `account` must have at least `amount` tokens.</span>
 284 |     | <span class='neutral'>     */</span>
 285 |     | <span class='unexecuted'>    function _burn(address account, uint256 amount) internal virtual {</span>
 286 |     | <span class='unexecuted'>        require(account != address(0), &quot;ERC20: burn from the zero address&quot;);</span>
 287 |     | <span class='neutral'></span>
 288 |     | <span class='neutral'>        _beforeTokenTransfer(account, address(0), amount);</span>
 289 |     | <span class='neutral'></span>
 290 |     | <span class='unexecuted'>        uint256 accountBalance = _balances[account];</span>
 291 |     | <span class='unexecuted'>        require(accountBalance &gt;= amount, &quot;ERC20: burn amount exceeds balance&quot;);</span>
 292 |     | <span class='neutral'>        unchecked {</span>
 293 |     | <span class='unexecuted'>            _balances[account] = accountBalance - amount;</span>
 294 |     | <span class='neutral'>            // Overflow not possible: amount &lt;= accountBalance &lt;= totalSupply.</span>
 295 |     | <span class='unexecuted'>            _totalSupply -= amount;</span>
 296 |     | <span class='neutral'>        }</span>
 297 |     | <span class='neutral'></span>
 298 |     | <span class='unexecuted'>        emit Transfer(account, address(0), amount);</span>
 299 |     | <span class='neutral'></span>
 300 |     | <span class='neutral'>        _afterTokenTransfer(account, address(0), amount);</span>
 301 |     | <span class='neutral'>    }</span>
 302 |     | <span class='neutral'></span>
 303 |     | <span class='neutral'>    /**</span>
 304 |     | <span class='neutral'>     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.</span>
 305 |     | <span class='neutral'>     *</span>
 306 |     | <span class='neutral'>     * This internal function is equivalent to `approve`, and can be used to</span>
 307 |     | <span class='neutral'>     * e.g. set automatic allowances for certain subsystems, etc.</span>
 308 |     | <span class='neutral'>     *</span>
 309 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 310 |     | <span class='neutral'>     *</span>
 311 |     | <span class='neutral'>     * Requirements:</span>
 312 |     | <span class='neutral'>     *</span>
 313 |     | <span class='neutral'>     * - `owner` cannot be the zero address.</span>
 314 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 315 |     | <span class='neutral'>     */</span>
 316 | *   | <span class='executed'>    function _approve(</span>
 317 |     | <span class='neutral'>        address owner,</span>
 318 |     | <span class='neutral'>        address spender,</span>
 319 |     | <span class='neutral'>        uint256 amount</span>
 320 |     | <span class='neutral'>    ) internal virtual {</span>
 321 | *   | <span class='executed'>        require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);</span>
 322 | *   | <span class='executed'>        require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);</span>
 323 |     | <span class='neutral'></span>
 324 | *   | <span class='executed'>        _allowances[owner][spender] = amount;</span>
 325 | *   | <span class='executed'>        emit Approval(owner, spender, amount);</span>
 326 |     | <span class='neutral'>    }</span>
 327 |     | <span class='neutral'></span>
 328 |     | <span class='neutral'>    /**</span>
 329 |     | <span class='neutral'>     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.</span>
 330 |     | <span class='neutral'>     *</span>
 331 |     | <span class='neutral'>     * Does not update the allowance amount in case of infinite allowance.</span>
 332 |     | <span class='neutral'>     * Revert if not enough allowance is available.</span>
 333 |     | <span class='neutral'>     *</span>
 334 |     | <span class='neutral'>     * Might emit an {Approval} event.</span>
 335 |     | <span class='neutral'>     */</span>
 336 | *   | <span class='executed'>    function _spendAllowance(</span>
 337 |     | <span class='neutral'>        address owner,</span>
 338 |     | <span class='neutral'>        address spender,</span>
 339 |     | <span class='neutral'>        uint256 amount</span>
 340 | *   | <span class='executed'>    ) internal virtual {</span>
 341 | *   | <span class='executed'>        uint256 currentAllowance = allowance(owner, spender);</span>
 342 | *   | <span class='executed'>        if (currentAllowance != type(uint256).max) {</span>
 343 | *   | <span class='executed'>            require(currentAllowance &gt;= amount, &quot;ERC20: insufficient allowance&quot;);</span>
 344 |     | <span class='neutral'>            unchecked {</span>
 345 | *   | <span class='executed'>                _approve(owner, spender, currentAllowance - amount);</span>
 346 |     | <span class='neutral'>            }</span>
 347 |     | <span class='neutral'>        }</span>
 348 |     | <span class='neutral'>    }</span>
 349 |     | <span class='neutral'></span>
 350 |     | <span class='neutral'>    /**</span>
 351 |     | <span class='neutral'>     * @dev Hook that is called before any transfer of tokens. This includes</span>
 352 |     | <span class='neutral'>     * minting and burning.</span>
 353 |     | <span class='neutral'>     *</span>
 354 |     | <span class='neutral'>     * Calling conditions:</span>
 355 |     | <span class='neutral'>     *</span>
 356 |     | <span class='neutral'>     * - when `from` and `to` are both non-zero, `amount` of ``from``&#39;s tokens</span>
 357 |     | <span class='neutral'>     * will be transferred to `to`.</span>
 358 |     | <span class='neutral'>     * - when `from` is zero, `amount` tokens will be minted for `to`.</span>
 359 |     | <span class='neutral'>     * - when `to` is zero, `amount` of ``from``&#39;s tokens will be burned.</span>
 360 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 361 |     | <span class='neutral'>     *</span>
 362 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 363 |     | <span class='neutral'>     */</span>
 364 |     | <span class='unexecuted'>    function _beforeTokenTransfer(</span>
 365 |     | <span class='neutral'>        address from,</span>
 366 |     | <span class='neutral'>        address to,</span>
 367 |     | <span class='neutral'>        uint256 amount</span>
 368 |     | <span class='neutral'>    ) internal virtual {}</span>
 369 |     | <span class='neutral'></span>
 370 |     | <span class='neutral'>    /**</span>
 371 |     | <span class='neutral'>     * @dev Hook that is called after any transfer of tokens. This includes</span>
 372 |     | <span class='neutral'>     * minting and burning.</span>
 373 |     | <span class='neutral'>     *</span>
 374 |     | <span class='neutral'>     * Calling conditions:</span>
 375 |     | <span class='neutral'>     *</span>
 376 |     | <span class='neutral'>     * - when `from` and `to` are both non-zero, `amount` of ``from``&#39;s tokens</span>
 377 |     | <span class='neutral'>     * has been transferred to `to`.</span>
 378 |     | <span class='neutral'>     * - when `from` is zero, `amount` tokens have been minted for `to`.</span>
 379 |     | <span class='neutral'>     * - when `to` is zero, `amount` of ``from``&#39;s tokens have been burned.</span>
 380 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 381 |     | <span class='neutral'>     *</span>
 382 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 383 |     | <span class='neutral'>     */</span>
 384 |     | <span class='neutral'>    function _afterTokenTransfer(</span>
 385 |     | <span class='neutral'>        address from,</span>
 386 |     | <span class='neutral'>        address to,</span>
 387 |     | <span class='neutral'>        uint256 amount</span>
 388 |     | <span class='neutral'>    ) internal virtual {}</span>
 389 |     | <span class='neutral'>}</span>
 390 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC20 standard as defined in the EIP.</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='neutral'>interface IERC20 {</span>
 10 |     | <span class='neutral'>    /**</span>
 11 |     | <span class='neutral'>     * @dev Emitted when `value` tokens are moved from one account (`from`) to</span>
 12 |     | <span class='neutral'>     * another (`to`).</span>
 13 |     | <span class='neutral'>     *</span>
 14 |     | <span class='neutral'>     * Note that `value` may be zero.</span>
 15 |     | <span class='neutral'>     */</span>
 16 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /**</span>
 19 |     | <span class='neutral'>     * @dev Emitted when the allowance of a `spender` for an `owner` is set by</span>
 20 |     | <span class='neutral'>     * a call to {approve}. `value` is the new allowance.</span>
 21 |     | <span class='neutral'>     */</span>
 22 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the amount of tokens in existence.</span>
 26 |     | <span class='neutral'>     */</span>
 27 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    /**</span>
 30 |     | <span class='neutral'>     * @dev Returns the amount of tokens owned by `account`.</span>
 31 |     | <span class='neutral'>     */</span>
 32 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /**</span>
 35 |     | <span class='neutral'>     * @dev Moves `amount` tokens from the caller&#39;s account to `to`.</span>
 36 |     | <span class='neutral'>     *</span>
 37 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 38 |     | <span class='neutral'>     *</span>
 39 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 40 |     | <span class='neutral'>     */</span>
 41 |     | <span class='neutral'>    function transfer(address to, uint256 amount) external returns (bool);</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    /**</span>
 44 |     | <span class='neutral'>     * @dev Returns the remaining number of tokens that `spender` will be</span>
 45 |     | <span class='neutral'>     * allowed to spend on behalf of `owner` through {transferFrom}. This is</span>
 46 |     | <span class='neutral'>     * zero by default.</span>
 47 |     | <span class='neutral'>     *</span>
 48 |     | <span class='neutral'>     * This value changes when {approve} or {transferFrom} are called.</span>
 49 |     | <span class='neutral'>     */</span>
 50 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    /**</span>
 53 |     | <span class='neutral'>     * @dev Sets `amount` as the allowance of `spender` over the caller&#39;s tokens.</span>
 54 |     | <span class='neutral'>     *</span>
 55 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 56 |     | <span class='neutral'>     *</span>
 57 |     | <span class='neutral'>     * IMPORTANT: Beware that changing an allowance with this method brings the risk</span>
 58 |     | <span class='neutral'>     * that someone may use both the old and the new allowance by unfortunate</span>
 59 |     | <span class='neutral'>     * transaction ordering. One possible solution to mitigate this race</span>
 60 |     | <span class='neutral'>     * condition is to first reduce the spender&#39;s allowance to 0 and set the</span>
 61 |     | <span class='neutral'>     * desired value afterwards:</span>
 62 |     | <span class='neutral'>     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</span>
 63 |     | <span class='neutral'>     *</span>
 64 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 65 |     | <span class='neutral'>     */</span>
 66 |     | <span class='neutral'>    function approve(address spender, uint256 amount) external returns (bool);</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='neutral'>    /**</span>
 69 |     | <span class='neutral'>     * @dev Moves `amount` tokens from `from` to `to` using the</span>
 70 |     | <span class='neutral'>     * allowance mechanism. `amount` is then deducted from the caller&#39;s</span>
 71 |     | <span class='neutral'>     * allowance.</span>
 72 |     | <span class='neutral'>     *</span>
 73 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 74 |     | <span class='neutral'>     *</span>
 75 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 76 |     | <span class='neutral'>     */</span>
 77 |     | <span class='neutral'>    function transferFrom(</span>
 78 |     | <span class='neutral'>        address from,</span>
 79 |     | <span class='neutral'>        address to,</span>
 80 |     | <span class='neutral'>        uint256 amount</span>
 81 |     | <span class='neutral'>    ) external returns (bool);</span>
 82 |     | <span class='neutral'>}</span>
 83 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;../IERC20.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Interface for the optional metadata functions from the ERC20 standard.</span>
 10 |     | <span class='neutral'> *</span>
 11 |     | <span class='neutral'> * _Available since v4.1._</span>
 12 |     | <span class='neutral'> */</span>
 13 |     | <span class='neutral'>interface IERC20Metadata is IERC20 {</span>
 14 |     | <span class='neutral'>    /**</span>
 15 |     | <span class='neutral'>     * @dev Returns the name of the token.</span>
 16 |     | <span class='neutral'>     */</span>
 17 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    /**</span>
 20 |     | <span class='neutral'>     * @dev Returns the symbol of the token.</span>
 21 |     | <span class='neutral'>     */</span>
 22 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the decimals places of the token.</span>
 26 |     | <span class='neutral'>     */</span>
 27 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
 28 |     | <span class='neutral'>}</span>
 29 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/openzeppelin-contracts/contracts/utils/Address.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.1;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * @dev Collection of functions related to the address type</span>
   8 |     | <span class='unexecuted'> */</span>
   9 |     | <span class='neutral'>library Address {</span>
  10 |     | <span class='neutral'>    /**</span>
  11 |     | <span class='neutral'>     * @dev Returns true if `account` is a contract.</span>
  12 |     | <span class='neutral'>     *</span>
  13 |     | <span class='neutral'>     * [IMPORTANT]</span>
  14 |     | <span class='neutral'>     * ====</span>
  15 |     | <span class='neutral'>     * It is unsafe to assume that an address for which this function returns</span>
  16 |     | <span class='neutral'>     * false is an externally-owned account (EOA) and not a contract.</span>
  17 |     | <span class='neutral'>     *</span>
  18 |     | <span class='neutral'>     * Among others, `isContract` will return false for the following</span>
  19 |     | <span class='neutral'>     * types of addresses:</span>
  20 |     | <span class='neutral'>     *</span>
  21 |     | <span class='neutral'>     *  - an externally-owned account</span>
  22 |     | <span class='neutral'>     *  - a contract in construction</span>
  23 |     | <span class='neutral'>     *  - an address where a contract will be created</span>
  24 |     | <span class='neutral'>     *  - an address where a contract lived, but was destroyed</span>
  25 |     | <span class='neutral'>     * ====</span>
  26 |     | <span class='neutral'>     *</span>
  27 |     | <span class='neutral'>     * [IMPORTANT]</span>
  28 |     | <span class='neutral'>     * ====</span>
  29 |     | <span class='neutral'>     * You shouldn&#39;t rely on `isContract` to protect against flash loan attacks!</span>
  30 |     | <span class='neutral'>     *</span>
  31 |     | <span class='neutral'>     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets</span>
  32 |     | <span class='neutral'>     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract</span>
  33 |     | <span class='neutral'>     * constructor.</span>
  34 |     | <span class='neutral'>     * ====</span>
  35 |     | <span class='neutral'>     */</span>
  36 |     | <span class='neutral'>    function isContract(address account) internal view returns (bool) {</span>
  37 |     | <span class='neutral'>        // This method relies on extcodesize/address.code.length, which returns 0</span>
  38 |     | <span class='neutral'>        // for contracts in construction, since the code is only stored at the end</span>
  39 |     | <span class='neutral'>        // of the constructor execution.</span>
  40 |     | <span class='neutral'></span>
  41 | *   | <span class='executed'>        return account.code.length &gt; 0;</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    /**</span>
  45 |     | <span class='neutral'>     * @dev Replacement for Solidity&#39;s `transfer`: sends `amount` wei to</span>
  46 |     | <span class='neutral'>     * `recipient`, forwarding all available gas and reverting on errors.</span>
  47 |     | <span class='neutral'>     *</span>
  48 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost</span>
  49 |     | <span class='neutral'>     * of certain opcodes, possibly making contracts go over the 2300 gas limit</span>
  50 |     | <span class='neutral'>     * imposed by `transfer`, making them unable to receive funds via</span>
  51 |     | <span class='neutral'>     * `transfer`. {sendValue} removes this limitation.</span>
  52 |     | <span class='neutral'>     *</span>
  53 |     | <span class='neutral'>     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].</span>
  54 |     | <span class='neutral'>     *</span>
  55 |     | <span class='neutral'>     * IMPORTANT: because control is transferred to `recipient`, care must be</span>
  56 |     | <span class='neutral'>     * taken to not create reentrancy vulnerabilities. Consider using</span>
  57 |     | <span class='neutral'>     * {ReentrancyGuard} or the</span>
  58 |     | <span class='neutral'>     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].</span>
  59 |     | <span class='neutral'>     */</span>
  60 |     | <span class='neutral'>    function sendValue(address payable recipient, uint256 amount) internal {</span>
  61 |     | <span class='neutral'>        require(address(this).balance &gt;= amount, &quot;Address: insufficient balance&quot;);</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>        (bool success, ) = recipient.call{value: amount}(&quot;&quot;);</span>
  64 |     | <span class='neutral'>        require(success, &quot;Address: unable to send value, recipient may have reverted&quot;);</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    /**</span>
  68 |     | <span class='neutral'>     * @dev Performs a Solidity function call using a low level `call`. A</span>
  69 |     | <span class='neutral'>     * plain `call` is an unsafe replacement for a function call: use this</span>
  70 |     | <span class='neutral'>     * function instead.</span>
  71 |     | <span class='neutral'>     *</span>
  72 |     | <span class='neutral'>     * If `target` reverts with a revert reason, it is bubbled up by this</span>
  73 |     | <span class='neutral'>     * function (like regular Solidity function calls).</span>
  74 |     | <span class='neutral'>     *</span>
  75 |     | <span class='neutral'>     * Returns the raw returned data. To convert to the expected return value,</span>
  76 |     | <span class='neutral'>     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].</span>
  77 |     | <span class='neutral'>     *</span>
  78 |     | <span class='neutral'>     * Requirements:</span>
  79 |     | <span class='neutral'>     *</span>
  80 |     | <span class='neutral'>     * - `target` must be a contract.</span>
  81 |     | <span class='neutral'>     * - calling `target` with `data` must not revert.</span>
  82 |     | <span class='neutral'>     *</span>
  83 |     | <span class='neutral'>     * _Available since v3.1._</span>
  84 |     | <span class='neutral'>     */</span>
  85 |     | <span class='neutral'>    function functionCall(address target, bytes memory data) internal returns (bytes memory) {</span>
  86 |     | <span class='neutral'>        return functionCallWithValue(target, data, 0, &quot;Address: low-level call failed&quot;);</span>
  87 |     | <span class='neutral'>    }</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    /**</span>
  90 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with</span>
  91 |     | <span class='neutral'>     * `errorMessage` as a fallback revert reason when `target` reverts.</span>
  92 |     | <span class='neutral'>     *</span>
  93 |     | <span class='neutral'>     * _Available since v3.1._</span>
  94 |     | <span class='neutral'>     */</span>
  95 |     | <span class='neutral'>    function functionCall(</span>
  96 |     | <span class='neutral'>        address target,</span>
  97 |     | <span class='neutral'>        bytes memory data,</span>
  98 |     | <span class='neutral'>        string memory errorMessage</span>
  99 |     | <span class='neutral'>    ) internal returns (bytes memory) {</span>
 100 |     | <span class='neutral'>        return functionCallWithValue(target, data, 0, errorMessage);</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    /**</span>
 104 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],</span>
 105 |     | <span class='neutral'>     * but also transferring `value` wei to `target`.</span>
 106 |     | <span class='neutral'>     *</span>
 107 |     | <span class='neutral'>     * Requirements:</span>
 108 |     | <span class='neutral'>     *</span>
 109 |     | <span class='neutral'>     * - the calling contract must have an ETH balance of at least `value`.</span>
 110 |     | <span class='neutral'>     * - the called Solidity function must be `payable`.</span>
 111 |     | <span class='neutral'>     *</span>
 112 |     | <span class='neutral'>     * _Available since v3.1._</span>
 113 |     | <span class='neutral'>     */</span>
 114 |     | <span class='neutral'>    function functionCallWithValue(</span>
 115 |     | <span class='neutral'>        address target,</span>
 116 |     | <span class='neutral'>        bytes memory data,</span>
 117 |     | <span class='neutral'>        uint256 value</span>
 118 |     | <span class='neutral'>    ) internal returns (bytes memory) {</span>
 119 |     | <span class='neutral'>        return functionCallWithValue(target, data, value, &quot;Address: low-level call with value failed&quot;);</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    /**</span>
 123 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but</span>
 124 |     | <span class='neutral'>     * with `errorMessage` as a fallback revert reason when `target` reverts.</span>
 125 |     | <span class='neutral'>     *</span>
 126 |     | <span class='neutral'>     * _Available since v3.1._</span>
 127 |     | <span class='neutral'>     */</span>
 128 |     | <span class='neutral'>    function functionCallWithValue(</span>
 129 |     | <span class='neutral'>        address target,</span>
 130 |     | <span class='neutral'>        bytes memory data,</span>
 131 |     | <span class='neutral'>        uint256 value,</span>
 132 |     | <span class='neutral'>        string memory errorMessage</span>
 133 |     | <span class='neutral'>    ) internal returns (bytes memory) {</span>
 134 |     | <span class='neutral'>        require(address(this).balance &gt;= value, &quot;Address: insufficient balance for call&quot;);</span>
 135 |     | <span class='neutral'>        (bool success, bytes memory returndata) = target.call{value: value}(data);</span>
 136 |     | <span class='neutral'>        return verifyCallResultFromTarget(target, success, returndata, errorMessage);</span>
 137 |     | <span class='neutral'>    }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>    /**</span>
 140 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],</span>
 141 |     | <span class='neutral'>     * but performing a static call.</span>
 142 |     | <span class='neutral'>     *</span>
 143 |     | <span class='neutral'>     * _Available since v3.3._</span>
 144 |     | <span class='neutral'>     */</span>
 145 |     | <span class='neutral'>    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {</span>
 146 |     | <span class='neutral'>        return functionStaticCall(target, data, &quot;Address: low-level static call failed&quot;);</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    /**</span>
 150 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],</span>
 151 |     | <span class='neutral'>     * but performing a static call.</span>
 152 |     | <span class='neutral'>     *</span>
 153 |     | <span class='neutral'>     * _Available since v3.3._</span>
 154 |     | <span class='neutral'>     */</span>
 155 |     | <span class='neutral'>    function functionStaticCall(</span>
 156 |     | <span class='neutral'>        address target,</span>
 157 |     | <span class='neutral'>        bytes memory data,</span>
 158 |     | <span class='neutral'>        string memory errorMessage</span>
 159 |     | <span class='neutral'>    ) internal view returns (bytes memory) {</span>
 160 |     | <span class='neutral'>        (bool success, bytes memory returndata) = target.staticcall(data);</span>
 161 |     | <span class='neutral'>        return verifyCallResultFromTarget(target, success, returndata, errorMessage);</span>
 162 |     | <span class='neutral'>    }</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>    /**</span>
 165 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],</span>
 166 |     | <span class='neutral'>     * but performing a delegate call.</span>
 167 |     | <span class='neutral'>     *</span>
 168 |     | <span class='neutral'>     * _Available since v3.4._</span>
 169 |     | <span class='neutral'>     */</span>
 170 |     | <span class='neutral'>    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {</span>
 171 |     | <span class='neutral'>        return functionDelegateCall(target, data, &quot;Address: low-level delegate call failed&quot;);</span>
 172 |     | <span class='neutral'>    }</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>    /**</span>
 175 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],</span>
 176 |     | <span class='neutral'>     * but performing a delegate call.</span>
 177 |     | <span class='neutral'>     *</span>
 178 |     | <span class='neutral'>     * _Available since v3.4._</span>
 179 |     | <span class='neutral'>     */</span>
 180 |     | <span class='neutral'>    function functionDelegateCall(</span>
 181 |     | <span class='neutral'>        address target,</span>
 182 |     | <span class='neutral'>        bytes memory data,</span>
 183 |     | <span class='neutral'>        string memory errorMessage</span>
 184 |     | <span class='neutral'>    ) internal returns (bytes memory) {</span>
 185 |     | <span class='neutral'>        (bool success, bytes memory returndata) = target.delegatecall(data);</span>
 186 |     | <span class='neutral'>        return verifyCallResultFromTarget(target, success, returndata, errorMessage);</span>
 187 |     | <span class='neutral'>    }</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='neutral'>    /**</span>
 190 |     | <span class='neutral'>     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling</span>
 191 |     | <span class='neutral'>     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.</span>
 192 |     | <span class='neutral'>     *</span>
 193 |     | <span class='neutral'>     * _Available since v4.8._</span>
 194 |     | <span class='neutral'>     */</span>
 195 |     | <span class='neutral'>    function verifyCallResultFromTarget(</span>
 196 |     | <span class='neutral'>        address target,</span>
 197 |     | <span class='neutral'>        bool success,</span>
 198 |     | <span class='neutral'>        bytes memory returndata,</span>
 199 |     | <span class='neutral'>        string memory errorMessage</span>
 200 |     | <span class='neutral'>    ) internal view returns (bytes memory) {</span>
 201 |     | <span class='neutral'>        if (success) {</span>
 202 |     | <span class='neutral'>            if (returndata.length == 0) {</span>
 203 |     | <span class='neutral'>                // only check isContract if the call was successful and the return data is empty</span>
 204 |     | <span class='neutral'>                // otherwise we already know that it was a contract</span>
 205 |     | <span class='neutral'>                require(isContract(target), &quot;Address: call to non-contract&quot;);</span>
 206 |     | <span class='neutral'>            }</span>
 207 |     | <span class='neutral'>            return returndata;</span>
 208 |     | <span class='neutral'>        } else {</span>
 209 |     | <span class='neutral'>            _revert(returndata, errorMessage);</span>
 210 |     | <span class='neutral'>        }</span>
 211 |     | <span class='neutral'>    }</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='neutral'>    /**</span>
 214 |     | <span class='neutral'>     * @dev Tool to verify that a low level call was successful, and revert if it wasn&#39;t, either by bubbling the</span>
 215 |     | <span class='neutral'>     * revert reason or using the provided one.</span>
 216 |     | <span class='neutral'>     *</span>
 217 |     | <span class='neutral'>     * _Available since v4.3._</span>
 218 |     | <span class='neutral'>     */</span>
 219 |     | <span class='neutral'>    function verifyCallResult(</span>
 220 |     | <span class='neutral'>        bool success,</span>
 221 |     | <span class='neutral'>        bytes memory returndata,</span>
 222 |     | <span class='neutral'>        string memory errorMessage</span>
 223 |     | <span class='neutral'>    ) internal pure returns (bytes memory) {</span>
 224 |     | <span class='neutral'>        if (success) {</span>
 225 |     | <span class='neutral'>            return returndata;</span>
 226 |     | <span class='neutral'>        } else {</span>
 227 |     | <span class='neutral'>            _revert(returndata, errorMessage);</span>
 228 |     | <span class='neutral'>        }</span>
 229 |     | <span class='neutral'>    }</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='neutral'>    function _revert(bytes memory returndata, string memory errorMessage) private pure {</span>
 232 |     | <span class='neutral'>        // Look for revert reason and bubble it up if present</span>
 233 |     | <span class='neutral'>        if (returndata.length &gt; 0) {</span>
 234 |     | <span class='neutral'>            // The easiest way to bubble the revert reason is using memory via assembly</span>
 235 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
 236 |     | <span class='neutral'>            assembly {</span>
 237 |     | <span class='neutral'>                let returndata_size := mload(returndata)</span>
 238 |     | <span class='neutral'>                revert(add(32, returndata), returndata_size)</span>
 239 |     | <span class='neutral'>            }</span>
 240 |     | <span class='neutral'>        } else {</span>
 241 |     | <span class='neutral'>            revert(errorMessage);</span>
 242 |     | <span class='neutral'>        }</span>
 243 |     | <span class='neutral'>    }</span>
 244 |     | <span class='neutral'>}</span>
 245 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/openzeppelin-contracts/contracts/utils/Context.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Provides information about the current execution context, including the</span>
  8 |     | <span class='neutral'> * sender of the transaction and its data. While these are generally available</span>
  9 |     | <span class='neutral'> * via msg.sender and msg.data, they should not be accessed in such a direct</span>
 10 |     | <span class='neutral'> * manner, since when dealing with meta-transactions the account sending and</span>
 11 |     | <span class='neutral'> * paying for execution may not be the actual sender (as far as an application</span>
 12 |     | <span class='neutral'> * is concerned).</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * This contract is only required for intermediate, library-like contracts.</span>
 15 |     | <span class='neutral'> */</span>
 16 |     | <span class='neutral'>abstract contract Context {</span>
 17 |     | <span class='neutral'>    function _msgSender() internal view virtual returns (address) {</span>
 18 | *   | <span class='executed'>        return msg.sender;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function _msgData() internal view virtual returns (bytes calldata) {</span>
 22 |     | <span class='neutral'>        return msg.data;</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'>}</span>
 25 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;./IERC165.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Implementation of the {IERC165} interface.</span>
 10 |     | <span class='neutral'> *</span>
 11 |     | <span class='neutral'> * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check</span>
 12 |     | <span class='neutral'> * for the additional interface id that will be supported. For example:</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * ```solidity</span>
 15 |     | <span class='neutral'> * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {</span>
 16 |     | <span class='neutral'> *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);</span>
 17 |     | <span class='neutral'> * }</span>
 18 |     | <span class='neutral'> * ```</span>
 19 |     | <span class='neutral'> *</span>
 20 |     | <span class='neutral'> * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.</span>
 21 |     | <span class='neutral'> */</span>
 22 |     | <span class='neutral'>abstract contract ERC165 is IERC165 {</span>
 23 |     | <span class='neutral'>    /**</span>
 24 |     | <span class='neutral'>     * @dev See {IERC165-supportsInterface}.</span>
 25 |     | <span class='neutral'>     */</span>
 26 |     | <span class='neutral'>    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {</span>
 27 |     | <span class='unexecuted'>        return interfaceId == type(IERC165).interfaceId;</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'>}</span>
 30 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC165 standard, as defined in the</span>
  8 |     | <span class='neutral'> * https://eips.ethereum.org/EIPS/eip-165[EIP].</span>
  9 |     | <span class='neutral'> *</span>
 10 |     | <span class='neutral'> * Implementers can declare support of contract interfaces, which can then be</span>
 11 |     | <span class='neutral'> * queried by others ({ERC165Checker}).</span>
 12 |     | <span class='neutral'> *</span>
 13 |     | <span class='neutral'> * For an implementation, see {ERC165}.</span>
 14 |     | <span class='neutral'> */</span>
 15 |     | <span class='neutral'>interface IERC165 {</span>
 16 |     | <span class='neutral'>    /**</span>
 17 |     | <span class='neutral'>     * @dev Returns true if this contract implements the interface defined by</span>
 18 |     | <span class='neutral'>     * `interfaceId`. See the corresponding</span>
 19 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]</span>
 20 |     | <span class='neutral'>     * to learn more about how these ids are created.</span>
 21 |     | <span class='neutral'>     *</span>
 22 |     | <span class='neutral'>     * This function call must use less than 30 000 gas.</span>
 23 |     | <span class='neutral'>     */</span>
 24 |     | <span class='neutral'>    function supportsInterface(bytes4 interfaceId) external view returns (bool);</span>
 25 |     | <span class='neutral'>}</span>
 26 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/script/Counter.s.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;forge-std/Script.sol&quot;;</span>
  5 |     | <span class='unexecuted'></span>
  6 |     | <span class='neutral'>contract SanctionTokenScript is Script {</span>
  7 |     | <span class='unexecuted'>    function setUp() public {}</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>    function run() public {</span>
 10 |     | <span class='unexecuted'>        vm.broadcast();</span>
 11 |     | <span class='neutral'>    }</span>
 12 |     | <span class='neutral'>}</span>
 13 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/script/SanctionTokenScript.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;forge-std/Script.sol&quot;;</span>
  5 |     | <span class='unexecuted'></span>
  6 |     | <span class='neutral'>contract SanctionTokenScript is Script {</span>
  7 |     | <span class='unexecuted'>    function setUp() public {}</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>    function run() public {</span>
 10 |     | <span class='unexecuted'>        vm.broadcast();</span>
 11 |     | <span class='neutral'>    }</span>
 12 |     | <span class='neutral'>}</span>
 13 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/src/BondingCurveToken.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/token/ERC20/ERC20.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/utils/Address.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/utils/introspection/ERC165.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/interfaces/IERC20.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/interfaces/IERC1363.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/interfaces/IERC1363Receiver.sol&quot;;</span>
  11 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/interfaces/IERC1363Spender.sol&quot;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>/**</span>
  14 |     | <span class='neutral'> * @title ERC1363</span>
  15 |     | <span class='neutral'> * @dev Implementation of an ERC1363 interface.</span>
  16 | *r  | <span class='executed'> */</span>
  17 |     | <span class='neutral'>contract BondingCurveToken is ERC20, IERC1363, ERC165, IERC1363Receiver, IERC1363Spender {</span>
  18 |     | <span class='neutral'>    using Address for address;</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    event TokensReceived(address indexed operator, address indexed sender, uint256 amount, bytes data);</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='unexecuted'>    address public immutable _owner;</span>
  23 | *   | <span class='executed'>    uint8 public constant _decimals = 18;</span>
  24 |     | <span class='unexecuted'>    IERC1363 public immutable _reserveToken;</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    // TODO: add admins to constructor</span>
  27 |     | <span class='unexecuted'>    constructor(IERC1363 reserveToken) ERC20(&quot;BondingCurveToken&quot;, &quot;BCT&quot;) {</span>
  28 |     | <span class='unexecuted'>        _owner = msg.sender;</span>
  29 |     | <span class='unexecuted'>        _reserveToken = reserveToken;</span>
  30 |     | <span class='neutral'>    }</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    modifier onlyOwner() {</span>
  33 |     | <span class='neutral'>        _isOwner();</span>
  34 |     | <span class='neutral'>        _;</span>
  35 |     | <span class='neutral'>    }</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    // y = x where x is the supply</span>
  38 |     | <span class='neutral'>    function getCurrentPrice() internal view returns (uint256) {</span>
  39 |     | <span class='neutral'>        return totalSupply();</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    /*</span>
  43 |     | <span class='neutral'>    //useful for another curve</span>
  44 |     | <span class='neutral'>    function calculatePrice(uint256 supply) internal pure returns (uint256) {</span>
  45 |     | <span class='neutral'>        return supply * 1;</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'>    */</span>
  48 |     | <span class='neutral'></span>
  49 | *   | <span class='executed'>    function sqrt(uint256 x) internal pure returns (uint256 y) {</span>
  50 | *   | <span class='executed'>        uint256 z = (x + 1) / 2;</span>
  51 | *   | <span class='executed'>        y = x;</span>
  52 | *   | <span class='executed'>        while (z &lt; y) {</span>
  53 | *   | <span class='executed'>            y = z;</span>
  54 | *   | <span class='executed'>            z = (x / z + z) / 2;</span>
  55 |     | <span class='neutral'>        }</span>
  56 | *   | <span class='executed'>        return y;</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    // Swap exact reserve for tokens</span>
  60 | *   | <span class='executed'>    function calculateBuyPriceOnlyIn(uint256 amountIn) public view returns (uint256) {</span>
  61 | *   | <span class='executed'>        uint256 currentSupply = totalSupply();</span>
  62 | *   | <span class='executed'>        uint256 futureSupply = sqrt(amountIn * 2 + (currentSupply ** 2));</span>
  63 | *   | <span class='executed'>        return futureSupply - currentSupply;</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    // TODO: implement swap exact token for reserve, give back additional reserve</span>
  67 |     | <span class='neutral'>    /* </span>
  68 |     | <span class='neutral'>    function calculatePriceInAndOut(uint256 amountIn, uint256 amountOut) public returns (uint256) {}</span>
  69 |     | <span class='neutral'>    */</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    // Swap exact tokens for reserve</span>
  72 | *r  | <span class='executed'>    function calculateSellPriceOnlyOut(uint256 amountOut) public view returns (uint256) {</span>
  73 | r   | <span class='reverted'>        uint256 currentSupply = totalSupply();</span>
  74 | r   | <span class='reverted'>        uint256 reserveToPay = ((currentSupply ** 2) - ((currentSupply - amountOut) ** 2)) / 2;</span>
  75 | *   | <span class='executed'>        return reserveToPay / 10 ** _decimals;</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'>    /*</span>
  78 |     | <span class='neutral'>    // TODO: Swap tokens for exact reserve</span>
  79 |     | <span class='neutral'>    function calculateSellAmountToGet(uint256 amountToGet) public view returns (uint256) {}</span>
  80 |     | <span class='neutral'>    */</span>
  81 |     | <span class='neutral'></span>
  82 | *   | <span class='executed'>    function buy(uint256 amountIn) public {</span>
  83 | *   | <span class='executed'>        uint256 amountOut = calculateBuyPriceOnlyIn(amountIn * 10 ** _decimals);</span>
  84 | *   | <span class='executed'>        _reserveToken.transferFromAndCall(msg.sender, address(this), amountIn);</span>
  85 | *   | <span class='executed'>        ERC20._mint(msg.sender, amountOut);</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='unexecuted'>    function sell(uint256 amountOut) public {</span>
  89 |     | <span class='unexecuted'>        uint256 reserveToPay = calculateSellPriceOnlyOut(amountOut);</span>
  90 |     | <span class='unexecuted'>        _reserveToken.transfer(address(this), reserveToPay);</span>
  91 |     | <span class='unexecuted'>        ERC20._burn(msg.sender, amountOut);</span>
  92 |     | <span class='neutral'>    }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='unexecuted'>    function decimals() public view override returns (uint8) {</span>
  95 |     | <span class='neutral'>        return _decimals;</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    function _isOwner() internal view virtual {</span>
  99 |     | <span class='neutral'>        require(_owner == msg.sender, &quot;OnlyOwner: caller is not the Owner&quot;);</span>
 100 |     | <span class='neutral'>    }</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>    /**</span>
 103 |     | <span class='neutral'>     * @dev See {IERC165-supportsInterface}.</span>
 104 |     | <span class='neutral'>     */</span>
 105 | *r  | <span class='executed'>    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {</span>
 106 | *   | <span class='executed'>        return interfaceId == type(IERC1363).interfaceId || super.supportsInterface(interfaceId);</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    /**</span>
 110 |     | <span class='neutral'>     * @dev Transfer tokens to a specified address and then execute a callback on `to`.</span>
 111 |     | <span class='neutral'>     * @param to The address to transfer to.</span>
 112 |     | <span class='neutral'>     * @param amount The amount to be transferred.</span>
 113 |     | <span class='neutral'>     * @return A boolean that indicates if the operation was successful.</span>
 114 |     | <span class='neutral'>     */</span>
 115 | *r  | <span class='executed'>    function transferAndCall(address to, uint256 amount) public virtual override returns (bool) {</span>
 116 | *r  | <span class='executed'>        return transferAndCall(to, amount, &quot;&quot;);</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    /**</span>
 120 |     | <span class='neutral'>     * @dev Transfer tokens to a specified address and then execute a callback on `to`.</span>
 121 |     | <span class='neutral'>     * @param to The address to transfer to</span>
 122 |     | <span class='neutral'>     * @param amount The amount to be transferred</span>
 123 |     | <span class='neutral'>     * @param data Additional data with no specified format</span>
 124 |     | <span class='neutral'>     * @return A boolean that indicates if the operation was successful.</span>
 125 |     | <span class='neutral'>     */</span>
 126 |     | <span class='unexecuted'>    function transferAndCall(address to, uint256 amount, bytes memory data) public virtual override returns (bool) {</span>
 127 |     | <span class='unexecuted'>        transfer(to, amount);</span>
 128 |     | <span class='unexecuted'>        require(_checkOnTransferReceived(_msgSender(), to, amount, data), &quot;ERC1363: receiver returned wrong data&quot;);</span>
 129 |     | <span class='neutral'>        return true;</span>
 130 |     | <span class='neutral'>    }</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>    /**</span>
 133 |     | <span class='neutral'>     * @dev Transfer tokens from one address to another and then execute a callback on `to`.</span>
 134 |     | <span class='neutral'>     * @param from The address which you want to send tokens from</span>
 135 |     | <span class='neutral'>     * @param to The address which you want to transfer to</span>
 136 |     | <span class='neutral'>     * @param amount The amount of tokens to be transferred</span>
 137 |     | <span class='neutral'>     * @return A boolean that indicates if the operation was successful.</span>
 138 |     | <span class='neutral'>     */</span>
 139 |     | <span class='unexecuted'>    function transferFromAndCall(address from, address to, uint256 amount) public virtual override returns (bool) {</span>
 140 |     | <span class='unexecuted'>        return transferFromAndCall(from, to, amount, &quot;&quot;);</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    /**</span>
 144 |     | <span class='neutral'>     * @dev Transfer tokens from one address to another and then execute a callback on `to`.</span>
 145 |     | <span class='neutral'>     * @param from The address which you want to send tokens from</span>
 146 |     | <span class='neutral'>     * @param to The address which you want to transfer to</span>
 147 |     | <span class='neutral'>     * @param amount The amount of tokens to be transferred</span>
 148 |     | <span class='neutral'>     * @param data Additional data with no specified format</span>
 149 |     | <span class='neutral'>     * @return A boolean that indicates if the operation was successful.</span>
 150 |     | <span class='neutral'>     */</span>
 151 |     | <span class='unexecuted'>    function transferFromAndCall(address from, address to, uint256 amount, bytes memory data)</span>
 152 |     | <span class='neutral'>        public</span>
 153 |     | <span class='neutral'>        virtual</span>
 154 |     | <span class='neutral'>        override</span>
 155 |     | <span class='unexecuted'>        returns (bool)</span>
 156 |     | <span class='neutral'>    {</span>
 157 |     | <span class='unexecuted'>        transferFrom(from, to, amount);</span>
 158 |     | <span class='unexecuted'>        require(_checkOnTransferReceived(from, to, amount, data), &quot;ERC1363: receiver returned wrong data&quot;);</span>
 159 |     | <span class='neutral'>        return true;</span>
 160 |     | <span class='neutral'>    }</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>    /**</span>
 163 |     | <span class='neutral'>     * @dev Approve spender to transfer tokens and then execute a callback on `spender`.</span>
 164 |     | <span class='neutral'>     * @param spender The address allowed to transfer to</span>
 165 |     | <span class='neutral'>     * @param amount The amount allowed to be transferred</span>
 166 |     | <span class='neutral'>     * @return A boolean that indicates if the operation was successful.</span>
 167 |     | <span class='neutral'>     */</span>
 168 |     | <span class='unexecuted'>    function approveAndCall(address spender, uint256 amount) public virtual override returns (bool) {</span>
 169 |     | <span class='unexecuted'>        return approveAndCall(spender, amount, &quot;&quot;);</span>
 170 |     | <span class='neutral'>    }</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='neutral'>    /**</span>
 173 |     | <span class='neutral'>     * @dev Approve spender to transfer tokens and then execute a callback on `spender`.</span>
 174 |     | <span class='neutral'>     * @param spender The address allowed to transfer to.</span>
 175 |     | <span class='neutral'>     * @param amount The amount allowed to be transferred.</span>
 176 |     | <span class='neutral'>     * @param data Additional data with no specified format.</span>
 177 |     | <span class='neutral'>     * @return A boolean that indicates if the operation was successful.</span>
 178 |     | <span class='neutral'>     */</span>
 179 |     | <span class='unexecuted'>    function approveAndCall(address spender, uint256 amount, bytes memory data)</span>
 180 |     | <span class='neutral'>        public</span>
 181 |     | <span class='neutral'>        virtual</span>
 182 |     | <span class='neutral'>        override</span>
 183 |     | <span class='unexecuted'>        returns (bool)</span>
 184 |     | <span class='neutral'>    {</span>
 185 |     | <span class='unexecuted'>        approve(spender, amount);</span>
 186 |     | <span class='unexecuted'>        require(_checkOnApprovalReceived(spender, amount, data), &quot;ERC1363: spender returned wrong data&quot;);</span>
 187 |     | <span class='neutral'>        return true;</span>
 188 |     | <span class='neutral'>    }</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='neutral'>    /**</span>
 191 |     | <span class='neutral'>     * @dev Internal function to invoke {IERC1363Receiver-onTransferReceived} on a target address.</span>
 192 |     | <span class='neutral'>     *  The call is not executed if the target address is not a contract.</span>
 193 |     | <span class='neutral'>     * @param sender address Representing the previous owner of the given token amount</span>
 194 |     | <span class='neutral'>     * @param recipient address Target address that will receive the tokens</span>
 195 |     | <span class='neutral'>     * @param amount uint256 The amount mount of tokens to be transferred</span>
 196 |     | <span class='neutral'>     * @param data bytes Optional data to send along with the call</span>
 197 |     | <span class='neutral'>     * @return whether the call correctly returned the expected magic value</span>
 198 |     | <span class='neutral'>     */</span>
 199 |     | <span class='unexecuted'>    function _checkOnTransferReceived(address sender, address recipient, uint256 amount, bytes memory data)</span>
 200 |     | <span class='neutral'>        internal</span>
 201 |     | <span class='neutral'>        virtual</span>
 202 |     | <span class='unexecuted'>        returns (bool)</span>
 203 |     | <span class='neutral'>    {</span>
 204 |     | <span class='unexecuted'>        if (!recipient.isContract()) {</span>
 205 |     | <span class='unexecuted'>            revert(&quot;ERC1363: transfer to non contract address&quot;);</span>
 206 |     | <span class='neutral'>        }</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='unexecuted'>        try IERC1363Receiver(recipient).onTransferReceived(_msgSender(), sender, amount, data) returns (bytes4 retval) {</span>
 209 |     | <span class='unexecuted'>            return retval == IERC1363Receiver.onTransferReceived.selector;</span>
 210 |     | <span class='neutral'>        } catch (bytes memory reason) {</span>
 211 |     | <span class='unexecuted'>            if (reason.length == 0) {</span>
 212 |     | <span class='unexecuted'>                revert(&quot;ERC1363: transfer to non ERC1363Receiver implementer&quot;);</span>
 213 |     | <span class='neutral'>            } else {</span>
 214 |     | <span class='neutral'>                /// @solidity memory-safe-assembly</span>
 215 |     | <span class='neutral'>                assembly {</span>
 216 |     | <span class='unexecuted'>                    revert(add(32, reason), mload(reason))</span>
 217 |     | <span class='neutral'>                }</span>
 218 |     | <span class='neutral'>            }</span>
 219 |     | <span class='neutral'>        }</span>
 220 |     | <span class='neutral'>    }</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='neutral'>    /**</span>
 223 |     | <span class='neutral'>     * @dev Internal function to invoke {IERC1363Receiver-onApprovalReceived} on a target address.</span>
 224 |     | <span class='neutral'>     *  The call is not executed if the target address is not a contract.</span>
 225 |     | <span class='neutral'>     * @param spender address The address which will spend the funds</span>
 226 |     | <span class='neutral'>     * @param amount uint256 The amount of tokens to be spent</span>
 227 |     | <span class='neutral'>     * @param data bytes Optional data to send along with the call</span>
 228 |     | <span class='neutral'>     * @return whether the call correctly returned the expected magic value</span>
 229 |     | <span class='neutral'>     */</span>
 230 |     | <span class='unexecuted'>    function _checkOnApprovalReceived(address spender, uint256 amount, bytes memory data)</span>
 231 |     | <span class='neutral'>        internal</span>
 232 |     | <span class='neutral'>        virtual</span>
 233 |     | <span class='unexecuted'>        returns (bool)</span>
 234 |     | <span class='neutral'>    {</span>
 235 |     | <span class='unexecuted'>        if (!spender.isContract()) {</span>
 236 |     | <span class='unexecuted'>            revert(&quot;ERC1363: approve a non contract address&quot;);</span>
 237 |     | <span class='neutral'>        }</span>
 238 |     | <span class='neutral'></span>
 239 |     | <span class='unexecuted'>        try IERC1363Spender(spender).onApprovalReceived(_msgSender(), amount, data) returns (bytes4 retval) {</span>
 240 |     | <span class='unexecuted'>            return retval == IERC1363Spender.onApprovalReceived.selector;</span>
 241 |     | <span class='neutral'>        } catch (bytes memory reason) {</span>
 242 |     | <span class='unexecuted'>            if (reason.length == 0) {</span>
 243 |     | <span class='unexecuted'>                revert(&quot;ERC1363: approve a non ERC1363Spender implementer&quot;);</span>
 244 |     | <span class='neutral'>            } else {</span>
 245 |     | <span class='neutral'>                /// @solidity memory-safe-assembly</span>
 246 |     | <span class='neutral'>                assembly {</span>
 247 |     | <span class='neutral'>                    revert(add(32, reason), mload(reason))</span>
 248 |     | <span class='neutral'>                }</span>
 249 |     | <span class='neutral'>            }</span>
 250 |     | <span class='neutral'>        }</span>
 251 |     | <span class='neutral'>    }</span>
 252 |     | <span class='neutral'></span>
 253 | *   | <span class='executed'>    function onTransferReceived(address operator, address from, uint256 value, bytes memory data)</span>
 254 |     | <span class='neutral'>        external</span>
 255 |     | <span class='neutral'>        override</span>
 256 | *   | <span class='executed'>        returns (bytes4)</span>
 257 |     | <span class='neutral'>    {</span>
 258 | *   | <span class='executed'>        emit TokensReceived(operator, from, value, data);</span>
 259 |     | <span class='neutral'>        return IERC1363Receiver.onTransferReceived.selector;</span>
 260 |     | <span class='neutral'>    }</span>
 261 |     | <span class='neutral'></span>
 262 | *   | <span class='executed'>    function onApprovalReceived(address owner, uint256 value, bytes memory data) external override returns (bytes4) {}</span>
 263 |     | <span class='neutral'>}</span>
 264 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/src/EchidnaBonding.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./BondingCurveToken.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;./SanctionToken.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 | *r  | <span class='executed'></span>
  8 |     | <span class='neutral'>contract EchidnaBonding {</span>
  9 |     | <span class='neutral'>  BondingCurveToken bondingToken;</span>
 10 |     | <span class='neutral'>  SanctionToken reserveToken;</span>
 11 |     | <span class='unexecuted'>  address[] adminList = new address[](1);</span>
 12 |     | <span class='neutral'>    /* ================================================================</span>
 13 |     | <span class='neutral'>       Events used for debugging or showing information.</span>
 14 |     | <span class='neutral'>       ================================================================ */</span>
 15 |     | <span class='neutral'>    event Value(string reason, uint256 val);</span>
 16 |     | <span class='neutral'>    event LogErr(bytes error);</span>
 17 |     | <span class='neutral'>    event Debug(int128, int128);</span>
 18 |     | <span class='neutral'>    event Addy(address);</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>  // setup</span>
 21 |     | <span class='unexecuted'>  constructor() {</span>
 22 |     | <span class='unexecuted'>    adminList[0] = address(this);</span>
 23 |     | <span class='unexecuted'>    reserveToken = new SanctionToken(adminList);</span>
 24 |     | <span class='unexecuted'>    bondingToken = new BondingCurveToken(reserveToken);</span>
 25 |     | <span class='neutral'>  }</span>
 26 |     | <span class='neutral'></span>
 27 | *   | <span class='executed'>  function testBuying(uint _amountIn) public{</span>
 28 |     | <span class='neutral'>    // Pre conditions</span>
 29 | *   | <span class='executed'>    _amountIn = 1 + (_amountIn % 1500);</span>
 30 |     | <span class='neutral'>    // Action</span>
 31 | *   | <span class='executed'>    uint256 preBuyAmountToReceive = bondingToken.calculateBuyPriceOnlyIn(_amountIn * 10**18);</span>
 32 | *   | <span class='executed'>    uint256 oldSupply = bondingToken.totalSupply();</span>
 33 | *   | <span class='executed'>    reserveToken.approve(address(bondingToken), _amountIn);</span>
 34 | *   | <span class='executed'>    try bondingToken.buy(_amountIn){</span>
 35 | *   | <span class='executed'>      assert(preBuyAmountToReceive &gt; bondingToken.calculateBuyPriceOnlyIn(_amountIn * 10**18));</span>
 36 | *   | <span class='executed'>      assert(oldSupply + preBuyAmountToReceive == bondingToken.totalSupply());</span>
 37 |     | <span class='unexecuted'>    } catch (bytes memory err) {</span>
 38 |     | <span class='unexecuted'>      assert(false);</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'>  }</span>
 41 |     | <span class='neutral'></span>
 42 | *r  | <span class='executed'>  function testSelling(uint _amountOut) public{</span>
 43 |     | <span class='neutral'>    // Pre conditions</span>
 44 | r   | <span class='reverted'>    _amountOut = 1 + (_amountOut % bondingToken.balanceOf(address(this)));</span>
 45 |     | <span class='neutral'>    // Action</span>
 46 | r   | <span class='reverted'>    uint256 preSellPrice = bondingToken.calculateSellPriceOnlyOut(_amountOut * 10**18);</span>
 47 |     | <span class='unexecuted'>    try bondingToken.sell(_amountOut){</span>
 48 |     | <span class='unexecuted'>      assert(preSellPrice &lt; bondingToken.calculateSellPriceOnlyOut(_amountOut * 10**18));</span>
 49 | *   | <span class='executed'>    } catch (bytes memory err) {</span>
 50 | *   | <span class='executed'>      assert(false);</span>
 51 |     | <span class='neutral'>    }</span>
 52 |     | <span class='neutral'>  }</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>}</span>
 55 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/src/GodModeToken.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/token/ERC20/ERC20.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/utils/Address.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/utils/introspection/ERC165.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/interfaces/IERC1363.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/interfaces/IERC1363Receiver.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/interfaces/IERC1363Spender.sol&quot;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>/**</span>
  13 |     | <span class='neutral'> * @title ERC1363</span>
  14 |     | <span class='neutral'> * @dev Implementation of an ERC1363 interface.</span>
  15 |     | <span class='neutral'> */</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>abstract contract ERC1363Implementer is ERC20, IERC1363 {</span>
  18 |     | <span class='neutral'>    using Address for address;</span>
  19 |     | <span class='neutral'>    /**</span>
  20 |     | <span class='neutral'>     * @dev Transfer tokens to a specified address and then execute a callback on `to`.</span>
  21 |     | <span class='neutral'>     * @param to The address to transfer to.</span>
  22 |     | <span class='neutral'>     * @param amount The amount to be transferred.</span>
  23 |     | <span class='neutral'>     * @return A boolean that indicates if the operation was successful.</span>
  24 |     | <span class='neutral'>     */</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='unexecuted'>    function transferAndCall(address to, uint256 amount) public override returns (bool) {</span>
  27 |     | <span class='unexecuted'>        return transferAndCall(to, amount, &quot;&quot;);</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    /**</span>
  31 |     | <span class='neutral'>     * @dev Transfer tokens to a specified address and then execute a callback on `to`.</span>
  32 |     | <span class='neutral'>     * @param to The address to transfer to</span>
  33 |     | <span class='neutral'>     * @param amount The amount to be transferred</span>
  34 |     | <span class='neutral'>     * @param data Additional data with no specified format</span>
  35 |     | <span class='neutral'>     * @return A boolean that indicates if the operation was successful.</span>
  36 |     | <span class='neutral'>     */</span>
  37 |     | <span class='unexecuted'>    function transferAndCall(address to, uint256 amount, bytes memory data) public override returns (bool) {</span>
  38 |     | <span class='unexecuted'>        transfer(to, amount);</span>
  39 |     | <span class='unexecuted'>        require(_checkOnTransferReceived(_msgSender(), to, amount, data), &quot;ERC1363: receiver returned wrong data&quot;);</span>
  40 |     | <span class='neutral'>        return true;</span>
  41 |     | <span class='neutral'>    }</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    /**</span>
  44 |     | <span class='neutral'>     * @dev Transfer tokens from one address to another and then execute a callback on `to`.</span>
  45 |     | <span class='neutral'>     * @param from The address which you want to send tokens from</span>
  46 |     | <span class='neutral'>     * @param to The address which you want to transfer to</span>
  47 |     | <span class='neutral'>     * @param amount The amount of tokens to be transferred</span>
  48 |     | <span class='neutral'>     * @return A boolean that indicates if the operation was successful.</span>
  49 |     | <span class='neutral'>     */</span>
  50 |     | <span class='unexecuted'>    function transferFromAndCall(address from, address to, uint256 amount) public override returns (bool) {</span>
  51 |     | <span class='unexecuted'>        return transferFromAndCall(from, to, amount, &quot;&quot;);</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    /**</span>
  55 |     | <span class='neutral'>     * @dev Transfer tokens from one address to another and then execute a callback on `to`.</span>
  56 |     | <span class='neutral'>     * @param from The address which you want to send tokens from</span>
  57 |     | <span class='neutral'>     * @param to The address which you want to transfer to</span>
  58 |     | <span class='neutral'>     * @param amount The amount of tokens to be transferred</span>
  59 |     | <span class='neutral'>     * @param data Additional data with no specified format</span>
  60 |     | <span class='neutral'>     * @return A boolean that indicates if the operation was successful.</span>
  61 |     | <span class='neutral'>     */</span>
  62 |     | <span class='unexecuted'>    function transferFromAndCall(address from, address to, uint256 amount, bytes memory data)</span>
  63 |     | <span class='neutral'>        public</span>
  64 |     | <span class='neutral'>        override</span>
  65 |     | <span class='unexecuted'>        returns (bool)</span>
  66 |     | <span class='neutral'>    {</span>
  67 |     | <span class='unexecuted'>        transferFrom(from, to, amount);</span>
  68 |     | <span class='unexecuted'>        require(_checkOnTransferReceived(from, to, amount, data), &quot;ERC1363: receiver returned wrong data&quot;);</span>
  69 |     | <span class='neutral'>        return true;</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    /**</span>
  73 |     | <span class='neutral'>     * @dev Approve spender to transfer tokens and then execute a callback on `spender`.</span>
  74 |     | <span class='neutral'>     * @param spender The address allowed to transfer to</span>
  75 |     | <span class='neutral'>     * @param amount The amount allowed to be transferred</span>
  76 |     | <span class='neutral'>     * @return A boolean that indicates if the operation was successful.</span>
  77 |     | <span class='neutral'>     */</span>
  78 |     | <span class='unexecuted'>    function approveAndCall(address spender, uint256 amount) public override returns (bool) {</span>
  79 |     | <span class='unexecuted'>        return approveAndCall(spender, amount, &quot;&quot;);</span>
  80 |     | <span class='neutral'>    }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    /**</span>
  83 |     | <span class='neutral'>     * @dev Approve spender to transfer tokens and then execute a callback on `spender`.</span>
  84 |     | <span class='neutral'>     * @param spender The address allowed to transfer to.</span>
  85 |     | <span class='neutral'>     * @param amount The amount allowed to be transferred.</span>
  86 |     | <span class='neutral'>     * @param data Additional data with no specified format.</span>
  87 |     | <span class='neutral'>     * @return A boolean that indicates if the operation was successful.</span>
  88 |     | <span class='neutral'>     */</span>
  89 |     | <span class='unexecuted'>    function approveAndCall(address spender, uint256 amount, bytes memory data) public override returns (bool) {</span>
  90 |     | <span class='unexecuted'>        approve(spender, amount);</span>
  91 |     | <span class='unexecuted'>        require(_checkOnApprovalReceived(spender, amount, data), &quot;ERC1363: spender returned wrong data&quot;);</span>
  92 |     | <span class='neutral'>        return true;</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    /**</span>
  96 |     | <span class='neutral'>     * @dev Internal function to invoke {IERC1363Receiver-onTransferReceived} on a target address.</span>
  97 |     | <span class='neutral'>     *  The call is not executed if the target address is not a contract.</span>
  98 |     | <span class='neutral'>     * @param sender address Representing the previous owner of the given token amount</span>
  99 |     | <span class='neutral'>     * @param recipient address Target address that will receive the tokens</span>
 100 |     | <span class='neutral'>     * @param amount uint256 The amount mount of tokens to be transferred</span>
 101 |     | <span class='neutral'>     * @param data bytes Optional data to send along with the call</span>
 102 |     | <span class='neutral'>     * @return whether the call correctly returned the expected magic value</span>
 103 |     | <span class='neutral'>     */</span>
 104 |     | <span class='unexecuted'>    function _checkOnTransferReceived(address sender, address recipient, uint256 amount, bytes memory data)</span>
 105 |     | <span class='neutral'>        internal</span>
 106 |     | <span class='unexecuted'>        returns (bool)</span>
 107 |     | <span class='neutral'>    {</span>
 108 |     | <span class='unexecuted'>        if (!recipient.isContract()) {</span>
 109 |     | <span class='unexecuted'>            revert(&quot;ERC1363: transfer to non contract address&quot;);</span>
 110 |     | <span class='neutral'>        }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='unexecuted'>        try IERC1363Receiver(recipient).onTransferReceived(_msgSender(), sender, amount, data) returns (bytes4 retval) {</span>
 113 |     | <span class='unexecuted'>            return retval == IERC1363Receiver.onTransferReceived.selector;</span>
 114 |     | <span class='neutral'>        } catch (bytes memory reason) {</span>
 115 |     | <span class='unexecuted'>            if (reason.length == 0) {</span>
 116 |     | <span class='unexecuted'>                revert(&quot;ERC1363: transfer to non ERC1363Receiver implementer&quot;);</span>
 117 |     | <span class='neutral'>            } else {</span>
 118 |     | <span class='neutral'>                /// @solidity memory-safe-assembly</span>
 119 |     | <span class='neutral'>                assembly {</span>
 120 |     | <span class='unexecuted'>                    revert(add(32, reason), mload(reason))</span>
 121 |     | <span class='neutral'>                }</span>
 122 |     | <span class='neutral'>            }</span>
 123 |     | <span class='neutral'>        }</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    /**</span>
 127 |     | <span class='neutral'>     * @dev Internal function to invoke {IERC1363Receiver-onApprovalReceived} on a target address.</span>
 128 |     | <span class='neutral'>     *  The call is not executed if the target address is not a contract.</span>
 129 |     | <span class='neutral'>     * @param spender address The address which will spend the funds</span>
 130 |     | <span class='neutral'>     * @param amount uint256 The amount of tokens to be spent</span>
 131 |     | <span class='neutral'>     * @param data bytes Optional data to send along with the call</span>
 132 |     | <span class='neutral'>     * @return whether the call correctly returned the expected magic value</span>
 133 |     | <span class='neutral'>     */</span>
 134 |     | <span class='unexecuted'>    function _checkOnApprovalReceived(address spender, uint256 amount, bytes memory data) internal returns (bool) {</span>
 135 |     | <span class='unexecuted'>        if (!spender.isContract()) {</span>
 136 |     | <span class='unexecuted'>            revert(&quot;ERC1363: approve a non contract address&quot;);</span>
 137 |     | <span class='neutral'>        }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='unexecuted'>        try IERC1363Spender(spender).onApprovalReceived(_msgSender(), amount, data) returns (bytes4 retval) {</span>
 140 |     | <span class='unexecuted'>            return retval == IERC1363Spender.onApprovalReceived.selector;</span>
 141 |     | <span class='neutral'>        } catch (bytes memory reason) {</span>
 142 |     | <span class='unexecuted'>            if (reason.length == 0) {</span>
 143 |     | <span class='unexecuted'>                revert(&quot;ERC1363: approve a non ERC1363Spender implementer&quot;);</span>
 144 |     | <span class='neutral'>            } else {</span>
 145 |     | <span class='neutral'>                /// @solidity memory-safe-assembly</span>
 146 |     | <span class='neutral'>                assembly {</span>
 147 |     | <span class='neutral'>                    revert(add(32, reason), mload(reason))</span>
 148 |     | <span class='neutral'>                }</span>
 149 |     | <span class='neutral'>            }</span>
 150 |     | <span class='neutral'>        }</span>
 151 |     | <span class='neutral'>    }</span>
 152 |     | <span class='neutral'>}</span>
 153 |     | <span class='unexecuted'></span>
 154 |     | <span class='neutral'>contract GodModeToken is ERC1363Implementer, ERC165 {</span>
 155 |     | <span class='unexecuted'>    address public _owner;</span>
 156 |     | <span class='unexecuted'>    uint8 public _decimals = 18;</span>
 157 |     | <span class='neutral'>    mapping(address =&gt; bool) private _gods;</span>
 158 |     | <span class='unexecuted'>    uint256 private _totalSupply = 1500;</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='unexecuted'>    constructor(address[] memory gods) ERC20(&quot;GodModeToken&quot;, &quot;GodMode&quot;) {</span>
 161 |     | <span class='unexecuted'>        ERC20._mint(msg.sender, _totalSupply * 10 ** _decimals);</span>
 162 |     | <span class='unexecuted'>        _owner = msg.sender;</span>
 163 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; gods.length; ++i) {</span>
 164 |     | <span class='unexecuted'>            setGods(gods[i]);</span>
 165 |     | <span class='neutral'>        }</span>
 166 |     | <span class='neutral'>    }</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>    modifier onlyOwner() {</span>
 169 |     | <span class='unexecuted'>        _isOwner();</span>
 170 |     | <span class='neutral'>        _;</span>
 171 |     | <span class='neutral'>    }</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='neutral'>    modifier onlyGod() {</span>
 174 |     | <span class='unexecuted'>        _isGod();</span>
 175 |     | <span class='neutral'>        _;</span>
 176 |     | <span class='neutral'>    }</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='unexecuted'>    function decimals() public view override returns (uint8) {</span>
 179 |     | <span class='unexecuted'>        return _decimals;</span>
 180 |     | <span class='neutral'>    }</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='unexecuted'>    function _isOwner() internal view {</span>
 183 |     | <span class='unexecuted'>        require(_owner == msg.sender, &quot;OnlyOwner: caller is not the Owner&quot;);</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='unexecuted'>    function _isGod() internal view {</span>
 187 |     | <span class='unexecuted'>        require(isGod(msg.sender), &quot;OnlyGod: caller is not a God&quot;);</span>
 188 |     | <span class='neutral'>    }</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='unexecuted'>    function setGods(address addy) public onlyOwner {</span>
 191 |     | <span class='unexecuted'>        _gods[addy] = true;</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='unexecuted'>    function removeGod(address addy) public onlyOwner {</span>
 195 |     | <span class='unexecuted'>        delete _gods[addy];</span>
 196 |     | <span class='neutral'>    }</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='unexecuted'>    function isGod(address addy) public view returns (bool) {</span>
 199 |     | <span class='unexecuted'>        return _gods[addy];</span>
 200 |     | <span class='neutral'>    }</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='unexecuted'>    function godTransferFrom(address from, address to, uint256 amount) public onlyGod returns (bool) {</span>
 203 |     | <span class='unexecuted'>        _transfer(from, to, amount);</span>
 204 |     | <span class='neutral'>        return true;</span>
 205 |     | <span class='neutral'>    }</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='unexecuted'>    function transferFrom(address from, address to, uint256 amount) public override(ERC20, IERC20) returns (bool) {</span>
 208 |     | <span class='neutral'>        address spender = _msgSender();</span>
 209 |     | <span class='unexecuted'>        _spendAllowance(from, spender, amount);</span>
 210 |     | <span class='unexecuted'>        _transfer(from, to, amount);</span>
 211 |     | <span class='unexecuted'>        return true;</span>
 212 |     | <span class='neutral'>    }</span>
 213 |     | <span class='neutral'></span>
 214 |     | <span class='neutral'>    /**</span>
 215 |     | <span class='neutral'>     * @dev See {IERC165-supportsInterface}.</span>
 216 |     | <span class='neutral'>     */</span>
 217 |     | <span class='unexecuted'>    function supportsInterface(bytes4 interfaceId) public view override(ERC165, IERC165) returns (bool) {</span>
 218 |     | <span class='unexecuted'>        return interfaceId == type(IERC1363).interfaceId || super.supportsInterface(interfaceId);</span>
 219 |     | <span class='neutral'>    }</span>
 220 |     | <span class='neutral'>}</span>
 221 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/src/SanctionToken.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/token/ERC20/ERC20.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/utils/Address.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/utils/introspection/ERC165.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/interfaces/IERC1363.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/interfaces/IERC1363Receiver.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/interfaces/IERC1363Spender.sol&quot;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>/**</span>
  13 |     | <span class='neutral'> * @title ERC1363</span>
  14 |     | <span class='neutral'> * @dev Implementation of an ERC1363 interface.</span>
  15 | *   | <span class='executed'> */</span>
  16 |     | <span class='neutral'>contract SanctionToken is ERC20, IERC1363, ERC165 {</span>
  17 |     | <span class='neutral'>    using Address for address;</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='unexecuted'>    address public _owner;</span>
  20 |     | <span class='unexecuted'>    uint8 public _decimals = 18;</span>
  21 |     | <span class='neutral'>    mapping(address =&gt; bool) private _admins;</span>
  22 |     | <span class='neutral'>    mapping(address =&gt; bool) private _sanctioned;</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='unexecuted'>    constructor(address[] memory admins) ERC20(&quot;SanctionToken&quot;, &quot;SANCTION&quot;) {</span>
  25 |     | <span class='unexecuted'>        ERC20._mint(msg.sender, 1500 * 10 ** _decimals);</span>
  26 |     | <span class='unexecuted'>        _owner = msg.sender;</span>
  27 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; admins.length; ++i) {</span>
  28 |     | <span class='unexecuted'>            setAdmin(admins[i]);</span>
  29 |     | <span class='neutral'>        }</span>
  30 |     | <span class='neutral'>    }</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    modifier onlyAdmin() {</span>
  33 |     | <span class='unexecuted'>        _isAdmin();</span>
  34 |     | <span class='neutral'>        _;</span>
  35 |     | <span class='neutral'>    }</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    modifier onlyOwner() {</span>
  38 |     | <span class='unexecuted'>        _isOwner();</span>
  39 |     | <span class='neutral'>        _;</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='unexecuted'>    function decimals() public view override returns (uint8) {</span>
  43 |     | <span class='unexecuted'>        return _decimals;</span>
  44 |     | <span class='neutral'>    }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='unexecuted'>    function _isOwner() internal view virtual {</span>
  47 |     | <span class='unexecuted'>        require(_owner == msg.sender, &quot;OnlyOwner: caller is not the Owner&quot;);</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='unexecuted'>    function _isAdmin() internal view virtual {</span>
  51 |     | <span class='unexecuted'>        require(isAdmin(msg.sender), &quot;OnlyAdmin: caller is not an Admin&quot;);</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='unexecuted'>    function setAdmin(address addy) public onlyOwner {</span>
  55 |     | <span class='unexecuted'>        _admins[addy] = true;</span>
  56 |     | <span class='neutral'>    }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='unexecuted'>    function removeAdmin(address addy) public onlyOwner {</span>
  59 |     | <span class='unexecuted'>        delete _admins[addy];</span>
  60 |     | <span class='neutral'>    }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='unexecuted'>    function isAdmin(address addy) public view returns (bool) {</span>
  63 |     | <span class='unexecuted'>        return _admins[addy];</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='unexecuted'>    function sanction(address[] memory addies) public onlyAdmin {</span>
  67 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; addies.length; ++i) {</span>
  68 |     | <span class='unexecuted'>            _sanctioned[addies[i]] = true;</span>
  69 |     | <span class='neutral'>        }</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='unexecuted'>    function unsanction(address addy) public onlyAdmin {</span>
  73 |     | <span class='unexecuted'>        delete _sanctioned[addy];</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 | *   | <span class='executed'>    function isSanctioned(address addy) public view returns (bool) {</span>
  77 | *   | <span class='executed'>        return _sanctioned[addy];</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 | *   | <span class='executed'>    function _beforeTokenTransfer(address from, address to, uint256 amount) internal view override {</span>
  81 | *   | <span class='executed'>        require(!isSanctioned(from) &amp;&amp; !isSanctioned(to), &quot;Sanctioned: Cannot transfer to or from a sanctioned address&quot;);</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    /**</span>
  85 |     | <span class='neutral'>     * @dev See {IERC165-supportsInterface}.</span>
  86 |     | <span class='neutral'>     */</span>
  87 | *   | <span class='executed'>    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {</span>
  88 |     | <span class='unexecuted'>        return interfaceId == type(IERC1363).interfaceId || super.supportsInterface(interfaceId);</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /**</span>
  92 |     | <span class='neutral'>     * @dev Transfer tokens to a specified address and then execute a callback on `to`.</span>
  93 |     | <span class='neutral'>     * @param to The address to transfer to.</span>
  94 |     | <span class='neutral'>     * @param amount The amount to be transferred.</span>
  95 |     | <span class='neutral'>     * @return A boolean that indicates if the operation was successful.</span>
  96 |     | <span class='neutral'>     */</span>
  97 | *   | <span class='executed'>    function transferAndCall(address to, uint256 amount) public virtual override returns (bool) {</span>
  98 | *   | <span class='executed'>        return transferAndCall(to, amount, &quot;&quot;);</span>
  99 |     | <span class='neutral'>    }</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>    /**</span>
 102 |     | <span class='neutral'>     * @dev Transfer tokens to a specified address and then execute a callback on `to`.</span>
 103 |     | <span class='neutral'>     * @param to The address to transfer to</span>
 104 |     | <span class='neutral'>     * @param amount The amount to be transferred</span>
 105 |     | <span class='neutral'>     * @param data Additional data with no specified format</span>
 106 |     | <span class='neutral'>     * @return A boolean that indicates if the operation was successful.</span>
 107 |     | <span class='neutral'>     */</span>
 108 |     | <span class='unexecuted'>    function transferAndCall(address to, uint256 amount, bytes memory data) public virtual override returns (bool) {</span>
 109 |     | <span class='unexecuted'>        transfer(to, amount);</span>
 110 |     | <span class='unexecuted'>        require(_checkOnTransferReceived(_msgSender(), to, amount, data), &quot;ERC1363: receiver returned wrong data&quot;);</span>
 111 |     | <span class='neutral'>        return true;</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    /**</span>
 115 |     | <span class='neutral'>     * @dev Transfer tokens from one address to another and then execute a callback on `to`.</span>
 116 |     | <span class='neutral'>     * @param from The address which you want to send tokens from</span>
 117 |     | <span class='neutral'>     * @param to The address which you want to transfer to</span>
 118 |     | <span class='neutral'>     * @param amount The amount of tokens to be transferred</span>
 119 |     | <span class='neutral'>     * @return A boolean that indicates if the operation was successful.</span>
 120 |     | <span class='neutral'>     */</span>
 121 | *   | <span class='executed'>    function transferFromAndCall(address from, address to, uint256 amount) public virtual override returns (bool) {</span>
 122 | *   | <span class='executed'>        return transferFromAndCall(from, to, amount, &quot;&quot;);</span>
 123 |     | <span class='neutral'>    }</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>    /**</span>
 126 |     | <span class='neutral'>     * @dev Transfer tokens from one address to another and then execute a callback on `to`.</span>
 127 |     | <span class='neutral'>     * @param from The address which you want to send tokens from</span>
 128 |     | <span class='neutral'>     * @param to The address which you want to transfer to</span>
 129 |     | <span class='neutral'>     * @param amount The amount of tokens to be transferred</span>
 130 |     | <span class='neutral'>     * @param data Additional data with no specified format</span>
 131 |     | <span class='neutral'>     * @return A boolean that indicates if the operation was successful.</span>
 132 |     | <span class='neutral'>     */</span>
 133 | *   | <span class='executed'>    function transferFromAndCall(address from, address to, uint256 amount, bytes memory data)</span>
 134 |     | <span class='neutral'>        public</span>
 135 |     | <span class='neutral'>        virtual</span>
 136 |     | <span class='neutral'>        override</span>
 137 | *   | <span class='executed'>        returns (bool)</span>
 138 |     | <span class='neutral'>    {</span>
 139 | *   | <span class='executed'>        transferFrom(from, to, amount);</span>
 140 | *   | <span class='executed'>        require(_checkOnTransferReceived(from, to, amount, data), &quot;ERC1363: receiver returned wrong data&quot;);</span>
 141 |     | <span class='neutral'>        return true;</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>    /**</span>
 145 |     | <span class='neutral'>     * @dev Approve spender to transfer tokens and then execute a callback on `spender`.</span>
 146 |     | <span class='neutral'>     * @param spender The address allowed to transfer to</span>
 147 |     | <span class='neutral'>     * @param amount The amount allowed to be transferred</span>
 148 |     | <span class='neutral'>     * @return A boolean that indicates if the operation was successful.</span>
 149 |     | <span class='neutral'>     */</span>
 150 |     | <span class='unexecuted'>    function approveAndCall(address spender, uint256 amount) public virtual override returns (bool) {</span>
 151 |     | <span class='unexecuted'>        return approveAndCall(spender, amount, &quot;&quot;);</span>
 152 |     | <span class='neutral'>    }</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>    /**</span>
 155 |     | <span class='neutral'>     * @dev Approve spender to transfer tokens and then execute a callback on `spender`.</span>
 156 |     | <span class='neutral'>     * @param spender The address allowed to transfer to.</span>
 157 |     | <span class='neutral'>     * @param amount The amount allowed to be transferred.</span>
 158 |     | <span class='neutral'>     * @param data Additional data with no specified format.</span>
 159 |     | <span class='neutral'>     * @return A boolean that indicates if the operation was successful.</span>
 160 |     | <span class='neutral'>     */</span>
 161 |     | <span class='unexecuted'>    function approveAndCall(address spender, uint256 amount, bytes memory data)</span>
 162 |     | <span class='neutral'>        public</span>
 163 |     | <span class='neutral'>        virtual</span>
 164 |     | <span class='neutral'>        override</span>
 165 |     | <span class='unexecuted'>        returns (bool)</span>
 166 |     | <span class='neutral'>    {</span>
 167 |     | <span class='unexecuted'>        approve(spender, amount);</span>
 168 |     | <span class='unexecuted'>        require(_checkOnApprovalReceived(spender, amount, data), &quot;ERC1363: spender returned wrong data&quot;);</span>
 169 |     | <span class='neutral'>        return true;</span>
 170 |     | <span class='neutral'>    }</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='neutral'>    /**</span>
 173 |     | <span class='neutral'>     * @dev Internal function to invoke {IERC1363Receiver-onTransferReceived} on a target address.</span>
 174 |     | <span class='neutral'>     *  The call is not executed if the target address is not a contract.</span>
 175 |     | <span class='neutral'>     * @param sender address Representing the previous owner of the given token amount</span>
 176 |     | <span class='neutral'>     * @param recipient address Target address that will receive the tokens</span>
 177 |     | <span class='neutral'>     * @param amount uint256 The amount mount of tokens to be transferred</span>
 178 |     | <span class='neutral'>     * @param data bytes Optional data to send along with the call</span>
 179 |     | <span class='neutral'>     * @return whether the call correctly returned the expected magic value</span>
 180 |     | <span class='neutral'>     */</span>
 181 | *   | <span class='executed'>    function _checkOnTransferReceived(address sender, address recipient, uint256 amount, bytes memory data)</span>
 182 |     | <span class='neutral'>        internal</span>
 183 |     | <span class='neutral'>        virtual</span>
 184 | *   | <span class='executed'>        returns (bool)</span>
 185 |     | <span class='neutral'>    {</span>
 186 | *   | <span class='executed'>        if (!recipient.isContract()) {</span>
 187 |     | <span class='unexecuted'>            revert(&quot;ERC1363: transfer to non contract address&quot;);</span>
 188 |     | <span class='neutral'>        }</span>
 189 |     | <span class='neutral'></span>
 190 | *   | <span class='executed'>        try IERC1363Receiver(recipient).onTransferReceived(_msgSender(), sender, amount, data) returns (bytes4 retval) {</span>
 191 | *   | <span class='executed'>            return retval == IERC1363Receiver.onTransferReceived.selector;</span>
 192 |     | <span class='neutral'>        } catch (bytes memory reason) {</span>
 193 |     | <span class='unexecuted'>            if (reason.length == 0) {</span>
 194 |     | <span class='unexecuted'>                revert(&quot;ERC1363: transfer to non ERC1363Receiver implementer&quot;);</span>
 195 |     | <span class='neutral'>            } else {</span>
 196 |     | <span class='neutral'>                /// @solidity memory-safe-assembly</span>
 197 |     | <span class='neutral'>                assembly {</span>
 198 |     | <span class='unexecuted'>                    revert(add(32, reason), mload(reason))</span>
 199 |     | <span class='neutral'>                }</span>
 200 |     | <span class='neutral'>            }</span>
 201 |     | <span class='neutral'>        }</span>
 202 |     | <span class='neutral'>    }</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='neutral'>    /**</span>
 205 |     | <span class='neutral'>     * @dev Internal function to invoke {IERC1363Receiver-onApprovalReceived} on a target address.</span>
 206 |     | <span class='neutral'>     *  The call is not executed if the target address is not a contract.</span>
 207 |     | <span class='neutral'>     * @param spender address The address which will spend the funds</span>
 208 |     | <span class='neutral'>     * @param amount uint256 The amount of tokens to be spent</span>
 209 |     | <span class='neutral'>     * @param data bytes Optional data to send along with the call</span>
 210 |     | <span class='neutral'>     * @return whether the call correctly returned the expected magic value</span>
 211 |     | <span class='neutral'>     */</span>
 212 |     | <span class='unexecuted'>    function _checkOnApprovalReceived(address spender, uint256 amount, bytes memory data)</span>
 213 |     | <span class='neutral'>        internal</span>
 214 |     | <span class='neutral'>        virtual</span>
 215 |     | <span class='unexecuted'>        returns (bool)</span>
 216 |     | <span class='neutral'>    {</span>
 217 |     | <span class='unexecuted'>        if (!spender.isContract()) {</span>
 218 |     | <span class='unexecuted'>            revert(&quot;ERC1363: approve a non contract address&quot;);</span>
 219 |     | <span class='neutral'>        }</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='unexecuted'>        try IERC1363Spender(spender).onApprovalReceived(_msgSender(), amount, data) returns (bytes4 retval) {</span>
 222 |     | <span class='unexecuted'>            return retval == IERC1363Spender.onApprovalReceived.selector;</span>
 223 |     | <span class='neutral'>        } catch (bytes memory reason) {</span>
 224 |     | <span class='unexecuted'>            if (reason.length == 0) {</span>
 225 |     | <span class='unexecuted'>                revert(&quot;ERC1363: approve a non ERC1363Spender implementer&quot;);</span>
 226 |     | <span class='neutral'>            } else {</span>
 227 |     | <span class='neutral'>                /// @solidity memory-safe-assembly</span>
 228 |     | <span class='neutral'>                assembly {</span>
 229 |     | <span class='neutral'>                    revert(add(32, reason), mload(reason))</span>
 230 |     | <span class='neutral'>                }</span>
 231 |     | <span class='neutral'>            }</span>
 232 |     | <span class='neutral'>        }</span>
 233 |     | <span class='neutral'>    }</span>
 234 |     | <span class='neutral'>}</span>
 235 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/test/BondingCurveToken.t.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;../src/SanctionToken.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;../src/BondingCurveToken.sol&quot;;</span>
  7 |     | <span class='unexecuted'></span>
  8 |     | <span class='neutral'>contract BondingCurveTokenTest is Test {</span>
  9 |     | <span class='neutral'>    SanctionToken sanctionToken;</span>
 10 |     | <span class='neutral'>    BondingCurveToken bondingCurveToken;</span>
 11 |     | <span class='neutral'>    address owner;</span>
 12 |     | <span class='neutral'>    address admin;</span>
 13 |     | <span class='neutral'>    address testUser;</span>
 14 |     | <span class='unexecuted'>    address[] adminsList = new address[](1);</span>
 15 |     | <span class='unexecuted'>    uint256 decimals = 10 ** 18;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>    function setUp() public {</span>
 18 |     | <span class='unexecuted'>        owner = address(this);</span>
 19 |     | <span class='unexecuted'>        admin = address(0);</span>
 20 |     | <span class='unexecuted'>        testUser = address(1);</span>
 21 |     | <span class='unexecuted'>        adminsList[0] = admin;</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>        sanctionToken = new SanctionToken(adminsList);</span>
 24 |     | <span class='unexecuted'>        bondingCurveToken = new BondingCurveToken(sanctionToken);</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='unexecuted'>    function testSetUp() public {</span>
 28 |     | <span class='unexecuted'>        assertEq(sanctionToken.totalSupply(), 1500 * decimals);</span>
 29 |     | <span class='unexecuted'>        assertEq(sanctionToken.balanceOf(owner), 1500 * decimals);</span>
 30 |     | <span class='unexecuted'>        assertEq(bondingCurveToken.totalSupply(), 0 * decimals);</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='unexecuted'>    function testBuy() public {</span>
 34 |     | <span class='unexecuted'>        sanctionToken.approve(address(bondingCurveToken), 10 * decimals);</span>
 35 |     | <span class='unexecuted'>        bondingCurveToken.buy(10 * decimals);</span>
 36 |     | <span class='neutral'>        // total received should be sqrt(20)</span>
 37 |     | <span class='unexecuted'>        assertEq(bondingCurveToken.balanceOf(owner), 4_472_135_954_999_579_392);</span>
 38 |     | <span class='unexecuted'>        assertEq(bondingCurveToken.totalSupply(), 4_472_135_954_999_579_392);</span>
 39 |     | <span class='unexecuted'>        sanctionToken.approve(address(bondingCurveToken), 10 * decimals);</span>
 40 |     | <span class='unexecuted'>        bondingCurveToken.buy(10 * decimals);</span>
 41 |     | <span class='neutral'>        // total supply should be sqrt(40), received last tx should be sqrt(40) - sqrt(20)</span>
 42 |     | <span class='unexecuted'>        assertEq(bondingCurveToken.balanceOf(owner), 6_324_555_320_336_758_663);</span>
 43 |     | <span class='unexecuted'>        assertEq(bondingCurveToken.totalSupply(), 6_324_555_320_336_758_663);</span>
 44 |     | <span class='neutral'>    }</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='unexecuted'>    function testSell() public {</span>
 47 |     | <span class='unexecuted'>        sanctionToken.approve(address(bondingCurveToken), 10 * decimals);</span>
 48 |     | <span class='unexecuted'>        bondingCurveToken.buy(10 * decimals);</span>
 49 |     | <span class='unexecuted'>        assert(bondingCurveToken.balanceOf(owner) &gt; 0);</span>
 50 |     | <span class='unexecuted'>        bondingCurveToken.sell(4_472_135_954_999_579_392);</span>
 51 |     | <span class='unexecuted'>        assert(bondingCurveToken.balanceOf(owner) == 0);</span>
 52 |     | <span class='neutral'>    }</span>
 53 |     | <span class='neutral'>}</span>
 54 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/test/GodModeToken.t.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;../src/GodModeToken.sol&quot;;</span>
  6 |     | <span class='unexecuted'></span>
  7 |     | <span class='neutral'>contract GodModeTokenTest is Test {</span>
  8 |     | <span class='unexecuted'>    GodModeToken public godModeToken;</span>
  9 |     | <span class='neutral'>    address owner;</span>
 10 |     | <span class='neutral'>    address zeus;</span>
 11 |     | <span class='neutral'>    address poseidon;</span>
 12 |     | <span class='neutral'>    address peasant;</span>
 13 |     | <span class='neutral'>    address testUser;</span>
 14 |     | <span class='unexecuted'>    address[] godsList = new address[](2);</span>
 15 |     | <span class='unexecuted'>    uint256 decimals = 10 ** 18;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>    function setUp() public {</span>
 18 |     | <span class='unexecuted'>        owner = address(this);</span>
 19 |     | <span class='unexecuted'>        zeus = address(0);</span>
 20 |     | <span class='unexecuted'>        poseidon = address(1);</span>
 21 |     | <span class='unexecuted'>        peasant = address(2);</span>
 22 |     | <span class='unexecuted'>        testUser = address(3);</span>
 23 |     | <span class='unexecuted'>        godsList[0] = zeus;</span>
 24 |     | <span class='unexecuted'>        godsList[1] = poseidon;</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='unexecuted'>        godModeToken = new GodModeToken(godsList);</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='unexecuted'>    function testSetUp() public {</span>
 30 |     | <span class='unexecuted'>        assertEq(godModeToken.totalSupply(), 1500 * decimals);</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='unexecuted'>    function testTransfers() public {</span>
 34 |     | <span class='unexecuted'>        godModeToken.transfer(peasant, 100 * decimals);</span>
 35 |     | <span class='unexecuted'>        assertEq(godModeToken.balanceOf(owner), 1400 * decimals);</span>
 36 |     | <span class='unexecuted'>        assertEq(godModeToken.balanceOf(peasant), 100 * decimals);</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='unexecuted'>    function testSetGod() public {</span>
 40 |     | <span class='unexecuted'>        godModeToken.setGods(testUser);</span>
 41 |     | <span class='unexecuted'>        assertEq(godModeToken.isGod(testUser), true);</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='unexecuted'>    function testRemoveGod() public {</span>
 45 |     | <span class='unexecuted'>        testSetGod();</span>
 46 |     | <span class='unexecuted'>        godModeToken.removeGod(testUser);</span>
 47 |     | <span class='unexecuted'>        assertEq(godModeToken.isGod(testUser), false);</span>
 48 |     | <span class='neutral'>    }</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='unexecuted'>    function testPeasantTransfer() public {</span>
 51 |     | <span class='unexecuted'>        testTransfers();</span>
 52 |     | <span class='unexecuted'>        vm.expectRevert(&quot;OnlyGod: caller is not a God&quot;);</span>
 53 |     | <span class='unexecuted'>        godModeToken.godTransferFrom(peasant, owner, 100 * decimals);</span>
 54 |     | <span class='neutral'>    }</span>
 55 |     | <span class='neutral'></span>
 56 |     | <span class='unexecuted'>    function testGodTransfer() public {</span>
 57 |     | <span class='unexecuted'>        testTransfers();</span>
 58 |     | <span class='unexecuted'>        vm.prank(zeus);</span>
 59 |     | <span class='unexecuted'>        godModeToken.godTransferFrom(peasant, owner, 100 * decimals);</span>
 60 |     | <span class='unexecuted'>        assertEq(godModeToken.balanceOf(owner), 1500 * decimals);</span>
 61 |     | <span class='unexecuted'>        assertEq(godModeToken.balanceOf(peasant), 0);</span>
 62 |     | <span class='neutral'>    }</span>
 63 |     | <span class='neutral'>}</span>
 64 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/test/SanctionToken.t copy.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;forge-std/Test.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;../src/SanctionToken.sol&quot;;</span>
  6 |     | <span class='unexecuted'></span>
  7 |     | <span class='neutral'>contract SanctionTokenTest is Test {</span>
  8 |     | <span class='unexecuted'>    SanctionToken public sanctionToken;</span>
  9 |     | <span class='neutral'>    address owner;</span>
 10 |     | <span class='neutral'>    address admin0;</span>
 11 |     | <span class='neutral'>    address admin1;</span>
 12 |     | <span class='neutral'>    address sanctionedUser;</span>
 13 |     | <span class='neutral'>    address testUser;</span>
 14 |     | <span class='unexecuted'>    address[] toSanction = new address[](1);</span>
 15 |     | <span class='unexecuted'>    address[] adminsList = new address[](2);</span>
 16 |     | <span class='unexecuted'>    uint256 decimals = 10 ** 18;</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='unexecuted'>    function setUp() public {</span>
 19 |     | <span class='unexecuted'>        owner = address(this);</span>
 20 |     | <span class='unexecuted'>        admin0 = address(0);</span>
 21 |     | <span class='unexecuted'>        admin1 = address(1);</span>
 22 |     | <span class='unexecuted'>        sanctionedUser = address(2);</span>
 23 |     | <span class='unexecuted'>        testUser = address(3);</span>
 24 |     | <span class='unexecuted'>        toSanction[0] = sanctionedUser;</span>
 25 |     | <span class='unexecuted'>        adminsList[0] = admin0;</span>
 26 |     | <span class='unexecuted'>        adminsList[1] = admin1;</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='unexecuted'>        sanctionToken = new SanctionToken(adminsList);</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='unexecuted'>    function testSetUp() public {</span>
 32 |     | <span class='unexecuted'>        assertEq(sanctionToken.totalSupply(), 1500 * decimals);</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='unexecuted'>    function testTransfers() public {</span>
 36 |     | <span class='unexecuted'>        sanctionToken.transfer(sanctionedUser, 100 * decimals);</span>
 37 |     | <span class='unexecuted'>        assertEq(sanctionToken.balanceOf(owner), 1400 * decimals);</span>
 38 |     | <span class='unexecuted'>        assertEq(sanctionToken.balanceOf(sanctionedUser), 100 * decimals);</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='unexecuted'>    function testNotAllowedSanctioning() public {</span>
 42 |     | <span class='unexecuted'>        vm.expectRevert(&quot;OnlyAdmin: caller is not an Admin&quot;);</span>
 43 |     | <span class='unexecuted'>        vm.prank(testUser);</span>
 44 |     | <span class='unexecuted'>        sanctionToken.sanction(toSanction);</span>
 45 |     | <span class='neutral'>        assertEq(sanctionToken.isSanctioned(sanctionedUser), false);</span>
 46 |     | <span class='neutral'>    }</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='unexecuted'>    function testSetAdmin() public {</span>
 49 |     | <span class='unexecuted'>        assertEq(sanctionToken.isAdmin(testUser), false);</span>
 50 |     | <span class='unexecuted'>        sanctionToken.setAdmin(testUser);</span>
 51 |     | <span class='unexecuted'>        assertEq(sanctionToken.isAdmin(testUser), true);</span>
 52 |     | <span class='neutral'>    }</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='unexecuted'>    function testSanctioning() public {</span>
 55 |     | <span class='unexecuted'>        assertEq(sanctionToken.isSanctioned(sanctionedUser), false);</span>
 56 |     | <span class='unexecuted'>        vm.prank(admin0);</span>
 57 |     | <span class='unexecuted'>        sanctionToken.sanction(toSanction);</span>
 58 |     | <span class='unexecuted'>        assertEq(sanctionToken.isSanctioned(sanctionedUser), true);</span>
 59 |     | <span class='neutral'>    }</span>
 60 |     | <span class='neutral'></span>
 61 |     | <span class='unexecuted'>    function testReceiveAsSanctioned() public {</span>
 62 |     | <span class='unexecuted'>        testSanctioning();</span>
 63 |     | <span class='unexecuted'>        vm.expectRevert(&quot;Sanctioned: Cannot transfer to or from a sanctioned address&quot;);</span>
 64 |     | <span class='unexecuted'>        sanctionToken.transfer(sanctionedUser, 200 * decimals);</span>
 65 |     | <span class='neutral'>    }</span>
 66 |     | <span class='neutral'></span>
 67 |     | <span class='unexecuted'>    function testSendAsSanctioned() public {</span>
 68 |     | <span class='unexecuted'>        testSanctioning();</span>
 69 |     | <span class='unexecuted'>        vm.prank(sanctionedUser);</span>
 70 |     | <span class='unexecuted'>        vm.expectRevert(&quot;Sanctioned: Cannot transfer to or from a sanctioned address&quot;);</span>
 71 |     | <span class='unexecuted'>        sanctionToken.transfer(testUser, 200 * decimals);</span>
 72 |     | <span class='neutral'>    }</span>
 73 |     | <span class='neutral'></span>
 74 |     | <span class='unexecuted'>    function testUnsanction() public {</span>
 75 |     | <span class='unexecuted'>        testSanctioning();</span>
 76 |     | <span class='unexecuted'>        vm.prank(admin0);</span>
 77 |     | <span class='unexecuted'>        sanctionToken.unsanction(sanctionedUser);</span>
 78 |     | <span class='unexecuted'>        assertEq(sanctionToken.isSanctioned(sanctionedUser), false);</span>
 79 |     | <span class='neutral'>    }</span>
 80 |     | <span class='neutral'></span>
 81 |     | <span class='unexecuted'>    function testUnsanctionAndSend() public {</span>
 82 |     | <span class='unexecuted'>        testTransfers();</span>
 83 |     | <span class='unexecuted'>        testUnsanction();</span>
 84 |     | <span class='unexecuted'>        vm.prank(sanctionedUser);</span>
 85 |     | <span class='unexecuted'>        sanctionToken.transfer(owner, 100 * decimals);</span>
 86 |     | <span class='unexecuted'>        assertEq(sanctionToken.balanceOf(owner), 1500 * decimals);</span>
 87 |     | <span class='unexecuted'>        assertEq(sanctionToken.balanceOf(sanctionedUser), 0);</span>
 88 |     | <span class='neutral'>    }</span>
 89 |     | <span class='neutral'>}</span>
 90 |     | <span class='neutral'></span>

</code>
<br />

