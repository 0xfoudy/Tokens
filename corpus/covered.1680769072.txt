/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/forge-std/lib/ds-test/src/test.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
   2 |     | 
   3 |     | // This program is free software: you can redistribute it and/or modify
   4 |     | // it under the terms of the GNU General Public License as published by
   5 |     | // the Free Software Foundation, either version 3 of the License, or
   6 |     | // (at your option) any later version.
   7 |     | 
   8 |     | // This program is distributed in the hope that it will be useful,
   9 |     | // but WITHOUT ANY WARRANTY; without even the implied warranty of
  10 |     | // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  11 |     | // GNU General Public License for more details.
  12 |     | 
  13 |     | // You should have received a copy of the GNU General Public License
  14 |     | // along with this program.  If not, see <http://www.gnu.org/licenses/>.
  15 |     | 
  16 |     | pragma solidity >=0.5.0;
  17 |     | 
  18 |     | contract DSTest {
  19 |     |     event log                    (string);
  20 |     |     event logs                   (bytes);
  21 |     | 
  22 |     |     event log_address            (address);
  23 |     |     event log_bytes32            (bytes32);
  24 |     |     event log_int                (int);
  25 |     |     event log_uint               (uint);
  26 |     |     event log_bytes              (bytes);
  27 |     |     event log_string             (string);
  28 |     | 
  29 |     |     event log_named_address      (string key, address val);
  30 |     |     event log_named_bytes32      (string key, bytes32 val);
  31 |     |     event log_named_decimal_int  (string key, int val, uint decimals);
  32 |     |     event log_named_decimal_uint (string key, uint val, uint decimals);
  33 |     |     event log_named_int          (string key, int val);
  34 |     |     event log_named_uint         (string key, uint val);
  35 |     |     event log_named_bytes        (string key, bytes val);
  36 |     |     event log_named_string       (string key, string val);
  37 |     | 
  38 |     |     bool public IS_TEST = true;
  39 |     |     bool private _failed;
  40 |     | 
  41 |     |     address constant HEVM_ADDRESS =
  42 |     |         address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));
  43 |     | 
  44 |     |     modifier mayRevert() { _; }
  45 |     |     modifier testopts(string memory) { _; }
  46 |     | 
  47 |     |     function failed() public returns (bool) {
  48 |     |         if (_failed) {
  49 |     |             return _failed;
  50 |     |         } else {
  51 |     |             bool globalFailed = false;
  52 |     |             if (hasHEVMContext()) {
  53 |     |                 (, bytes memory retdata) = HEVM_ADDRESS.call(
  54 |     |                     abi.encodePacked(
  55 |     |                         bytes4(keccak256("load(address,bytes32)")),
  56 |     |                         abi.encode(HEVM_ADDRESS, bytes32("failed"))
  57 |     |                     )
  58 |     |                 );
  59 |     |                 globalFailed = abi.decode(retdata, (bool));
  60 |     |             }
  61 |     |             return globalFailed;
  62 |     |         }
  63 |     |     }
  64 |     | 
  65 |     |     function fail() internal virtual {
  66 |     |         if (hasHEVMContext()) {
  67 |     |             (bool status, ) = HEVM_ADDRESS.call(
  68 |     |                 abi.encodePacked(
  69 |     |                     bytes4(keccak256("store(address,bytes32,bytes32)")),
  70 |     |                     abi.encode(HEVM_ADDRESS, bytes32("failed"), bytes32(uint256(0x01)))
  71 |     |                 )
  72 |     |             );
  73 |     |             status; // Silence compiler warnings
  74 |     |         }
  75 |     |         _failed = true;
  76 |     |     }
  77 |     | 
  78 |     |     function hasHEVMContext() internal view returns (bool) {
  79 |     |         uint256 hevmCodeSize = 0;
  80 |     |         assembly {
  81 |     |             hevmCodeSize := extcodesize(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)
  82 |     |         }
  83 |     |         return hevmCodeSize > 0;
  84 |     |     }
  85 |     | 
  86 |     |     modifier logs_gas() {
  87 |     |         uint startGas = gasleft();
  88 |     |         _;
  89 |     |         uint endGas = gasleft();
  90 |     |         emit log_named_uint("gas", startGas - endGas);
  91 |     |     }
  92 |     | 
  93 |     |     function assertTrue(bool condition) internal {
  94 |     |         if (!condition) {
  95 |     |             emit log("Error: Assertion Failed");
  96 |     |             fail();
  97 |     |         }
  98 |     |     }
  99 |     | 
 100 |     |     function assertTrue(bool condition, string memory err) internal {
 101 |     |         if (!condition) {
 102 |     |             emit log_named_string("Error", err);
 103 |     |             assertTrue(condition);
 104 |     |         }
 105 |     |     }
 106 |     | 
 107 |     |     function assertEq(address a, address b) internal {
 108 |     |         if (a != b) {
 109 |     |             emit log("Error: a == b not satisfied [address]");
 110 |     |             emit log_named_address("      Left", a);
 111 |     |             emit log_named_address("     Right", b);
 112 |     |             fail();
 113 |     |         }
 114 |     |     }
 115 |     |     function assertEq(address a, address b, string memory err) internal {
 116 |     |         if (a != b) {
 117 |     |             emit log_named_string ("Error", err);
 118 |     |             assertEq(a, b);
 119 |     |         }
 120 |     |     }
 121 |     | 
 122 |     |     function assertEq(bytes32 a, bytes32 b) internal {
 123 |     |         if (a != b) {
 124 |     |             emit log("Error: a == b not satisfied [bytes32]");
 125 |     |             emit log_named_bytes32("      Left", a);
 126 |     |             emit log_named_bytes32("     Right", b);
 127 |     |             fail();
 128 |     |         }
 129 |     |     }
 130 |     |     function assertEq(bytes32 a, bytes32 b, string memory err) internal {
 131 |     |         if (a != b) {
 132 |     |             emit log_named_string ("Error", err);
 133 |     |             assertEq(a, b);
 134 |     |         }
 135 |     |     }
 136 |     |     function assertEq32(bytes32 a, bytes32 b) internal {
 137 |     |         assertEq(a, b);
 138 |     |     }
 139 |     |     function assertEq32(bytes32 a, bytes32 b, string memory err) internal {
 140 |     |         assertEq(a, b, err);
 141 |     |     }
 142 |     | 
 143 |     |     function assertEq(int a, int b) internal {
 144 |     |         if (a != b) {
 145 |     |             emit log("Error: a == b not satisfied [int]");
 146 |     |             emit log_named_int("      Left", a);
 147 |     |             emit log_named_int("     Right", b);
 148 |     |             fail();
 149 |     |         }
 150 |     |     }
 151 |     |     function assertEq(int a, int b, string memory err) internal {
 152 |     |         if (a != b) {
 153 |     |             emit log_named_string("Error", err);
 154 |     |             assertEq(a, b);
 155 |     |         }
 156 |     |     }
 157 |     |     function assertEq(uint a, uint b) internal {
 158 |     |         if (a != b) {
 159 |     |             emit log("Error: a == b not satisfied [uint]");
 160 |     |             emit log_named_uint("      Left", a);
 161 |     |             emit log_named_uint("     Right", b);
 162 |     |             fail();
 163 |     |         }
 164 |     |     }
 165 |     |     function assertEq(uint a, uint b, string memory err) internal {
 166 |     |         if (a != b) {
 167 |     |             emit log_named_string("Error", err);
 168 |     |             assertEq(a, b);
 169 |     |         }
 170 |     |     }
 171 |     |     function assertEqDecimal(int a, int b, uint decimals) internal {
 172 |     |         if (a != b) {
 173 |     |             emit log("Error: a == b not satisfied [decimal int]");
 174 |     |             emit log_named_decimal_int("      Left", a, decimals);
 175 |     |             emit log_named_decimal_int("     Right", b, decimals);
 176 |     |             fail();
 177 |     |         }
 178 |     |     }
 179 |     |     function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {
 180 |     |         if (a != b) {
 181 |     |             emit log_named_string("Error", err);
 182 |     |             assertEqDecimal(a, b, decimals);
 183 |     |         }
 184 |     |     }
 185 |     |     function assertEqDecimal(uint a, uint b, uint decimals) internal {
 186 |     |         if (a != b) {
 187 |     |             emit log("Error: a == b not satisfied [decimal uint]");
 188 |     |             emit log_named_decimal_uint("      Left", a, decimals);
 189 |     |             emit log_named_decimal_uint("     Right", b, decimals);
 190 |     |             fail();
 191 |     |         }
 192 |     |     }
 193 |     |     function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {
 194 |     |         if (a != b) {
 195 |     |             emit log_named_string("Error", err);
 196 |     |             assertEqDecimal(a, b, decimals);
 197 |     |         }
 198 |     |     }
 199 |     | 
 200 |     |     function assertGt(uint a, uint b) internal {
 201 |     |         if (a <= b) {
 202 |     |             emit log("Error: a > b not satisfied [uint]");
 203 |     |             emit log_named_uint("  Value a", a);
 204 |     |             emit log_named_uint("  Value b", b);
 205 |     |             fail();
 206 |     |         }
 207 |     |     }
 208 |     |     function assertGt(uint a, uint b, string memory err) internal {
 209 |     |         if (a <= b) {
 210 |     |             emit log_named_string("Error", err);
 211 |     |             assertGt(a, b);
 212 |     |         }
 213 |     |     }
 214 |     |     function assertGt(int a, int b) internal {
 215 |     |         if (a <= b) {
 216 |     |             emit log("Error: a > b not satisfied [int]");
 217 |     |             emit log_named_int("  Value a", a);
 218 |     |             emit log_named_int("  Value b", b);
 219 |     |             fail();
 220 |     |         }
 221 |     |     }
 222 |     |     function assertGt(int a, int b, string memory err) internal {
 223 |     |         if (a <= b) {
 224 |     |             emit log_named_string("Error", err);
 225 |     |             assertGt(a, b);
 226 |     |         }
 227 |     |     }
 228 |     |     function assertGtDecimal(int a, int b, uint decimals) internal {
 229 |     |         if (a <= b) {
 230 |     |             emit log("Error: a > b not satisfied [decimal int]");
 231 |     |             emit log_named_decimal_int("  Value a", a, decimals);
 232 |     |             emit log_named_decimal_int("  Value b", b, decimals);
 233 |     |             fail();
 234 |     |         }
 235 |     |     }
 236 |     |     function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {
 237 |     |         if (a <= b) {
 238 |     |             emit log_named_string("Error", err);
 239 |     |             assertGtDecimal(a, b, decimals);
 240 |     |         }
 241 |     |     }
 242 |     |     function assertGtDecimal(uint a, uint b, uint decimals) internal {
 243 |     |         if (a <= b) {
 244 |     |             emit log("Error: a > b not satisfied [decimal uint]");
 245 |     |             emit log_named_decimal_uint("  Value a", a, decimals);
 246 |     |             emit log_named_decimal_uint("  Value b", b, decimals);
 247 |     |             fail();
 248 |     |         }
 249 |     |     }
 250 |     |     function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {
 251 |     |         if (a <= b) {
 252 |     |             emit log_named_string("Error", err);
 253 |     |             assertGtDecimal(a, b, decimals);
 254 |     |         }
 255 |     |     }
 256 |     | 
 257 |     |     function assertGe(uint a, uint b) internal {
 258 |     |         if (a < b) {
 259 |     |             emit log("Error: a >= b not satisfied [uint]");
 260 |     |             emit log_named_uint("  Value a", a);
 261 |     |             emit log_named_uint("  Value b", b);
 262 |     |             fail();
 263 |     |         }
 264 |     |     }
 265 |     |     function assertGe(uint a, uint b, string memory err) internal {
 266 |     |         if (a < b) {
 267 |     |             emit log_named_string("Error", err);
 268 |     |             assertGe(a, b);
 269 |     |         }
 270 |     |     }
 271 |     |     function assertGe(int a, int b) internal {
 272 |     |         if (a < b) {
 273 |     |             emit log("Error: a >= b not satisfied [int]");
 274 |     |             emit log_named_int("  Value a", a);
 275 |     |             emit log_named_int("  Value b", b);
 276 |     |             fail();
 277 |     |         }
 278 |     |     }
 279 |     |     function assertGe(int a, int b, string memory err) internal {
 280 |     |         if (a < b) {
 281 |     |             emit log_named_string("Error", err);
 282 |     |             assertGe(a, b);
 283 |     |         }
 284 |     |     }
 285 |     |     function assertGeDecimal(int a, int b, uint decimals) internal {
 286 |     |         if (a < b) {
 287 |     |             emit log("Error: a >= b not satisfied [decimal int]");
 288 |     |             emit log_named_decimal_int("  Value a", a, decimals);
 289 |     |             emit log_named_decimal_int("  Value b", b, decimals);
 290 |     |             fail();
 291 |     |         }
 292 |     |     }
 293 |     |     function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {
 294 |     |         if (a < b) {
 295 |     |             emit log_named_string("Error", err);
 296 |     |             assertGeDecimal(a, b, decimals);
 297 |     |         }
 298 |     |     }
 299 |     |     function assertGeDecimal(uint a, uint b, uint decimals) internal {
 300 |     |         if (a < b) {
 301 |     |             emit log("Error: a >= b not satisfied [decimal uint]");
 302 |     |             emit log_named_decimal_uint("  Value a", a, decimals);
 303 |     |             emit log_named_decimal_uint("  Value b", b, decimals);
 304 |     |             fail();
 305 |     |         }
 306 |     |     }
 307 |     |     function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {
 308 |     |         if (a < b) {
 309 |     |             emit log_named_string("Error", err);
 310 |     |             assertGeDecimal(a, b, decimals);
 311 |     |         }
 312 |     |     }
 313 |     | 
 314 |     |     function assertLt(uint a, uint b) internal {
 315 |     |         if (a >= b) {
 316 |     |             emit log("Error: a < b not satisfied [uint]");
 317 |     |             emit log_named_uint("  Value a", a);
 318 |     |             emit log_named_uint("  Value b", b);
 319 |     |             fail();
 320 |     |         }
 321 |     |     }
 322 |     |     function assertLt(uint a, uint b, string memory err) internal {
 323 |     |         if (a >= b) {
 324 |     |             emit log_named_string("Error", err);
 325 |     |             assertLt(a, b);
 326 |     |         }
 327 |     |     }
 328 |     |     function assertLt(int a, int b) internal {
 329 |     |         if (a >= b) {
 330 |     |             emit log("Error: a < b not satisfied [int]");
 331 |     |             emit log_named_int("  Value a", a);
 332 |     |             emit log_named_int("  Value b", b);
 333 |     |             fail();
 334 |     |         }
 335 |     |     }
 336 |     |     function assertLt(int a, int b, string memory err) internal {
 337 |     |         if (a >= b) {
 338 |     |             emit log_named_string("Error", err);
 339 |     |             assertLt(a, b);
 340 |     |         }
 341 |     |     }
 342 |     |     function assertLtDecimal(int a, int b, uint decimals) internal {
 343 |     |         if (a >= b) {
 344 |     |             emit log("Error: a < b not satisfied [decimal int]");
 345 |     |             emit log_named_decimal_int("  Value a", a, decimals);
 346 |     |             emit log_named_decimal_int("  Value b", b, decimals);
 347 |     |             fail();
 348 |     |         }
 349 |     |     }
 350 |     |     function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {
 351 |     |         if (a >= b) {
 352 |     |             emit log_named_string("Error", err);
 353 |     |             assertLtDecimal(a, b, decimals);
 354 |     |         }
 355 |     |     }
 356 |     |     function assertLtDecimal(uint a, uint b, uint decimals) internal {
 357 |     |         if (a >= b) {
 358 |     |             emit log("Error: a < b not satisfied [decimal uint]");
 359 |     |             emit log_named_decimal_uint("  Value a", a, decimals);
 360 |     |             emit log_named_decimal_uint("  Value b", b, decimals);
 361 |     |             fail();
 362 |     |         }
 363 |     |     }
 364 |     |     function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {
 365 |     |         if (a >= b) {
 366 |     |             emit log_named_string("Error", err);
 367 |     |             assertLtDecimal(a, b, decimals);
 368 |     |         }
 369 |     |     }
 370 |     | 
 371 |     |     function assertLe(uint a, uint b) internal {
 372 |     |         if (a > b) {
 373 |     |             emit log("Error: a <= b not satisfied [uint]");
 374 |     |             emit log_named_uint("  Value a", a);
 375 |     |             emit log_named_uint("  Value b", b);
 376 |     |             fail();
 377 |     |         }
 378 |     |     }
 379 |     |     function assertLe(uint a, uint b, string memory err) internal {
 380 |     |         if (a > b) {
 381 |     |             emit log_named_string("Error", err);
 382 |     |             assertLe(a, b);
 383 |     |         }
 384 |     |     }
 385 |     |     function assertLe(int a, int b) internal {
 386 |     |         if (a > b) {
 387 |     |             emit log("Error: a <= b not satisfied [int]");
 388 |     |             emit log_named_int("  Value a", a);
 389 |     |             emit log_named_int("  Value b", b);
 390 |     |             fail();
 391 |     |         }
 392 |     |     }
 393 |     |     function assertLe(int a, int b, string memory err) internal {
 394 |     |         if (a > b) {
 395 |     |             emit log_named_string("Error", err);
 396 |     |             assertLe(a, b);
 397 |     |         }
 398 |     |     }
 399 |     |     function assertLeDecimal(int a, int b, uint decimals) internal {
 400 |     |         if (a > b) {
 401 |     |             emit log("Error: a <= b not satisfied [decimal int]");
 402 |     |             emit log_named_decimal_int("  Value a", a, decimals);
 403 |     |             emit log_named_decimal_int("  Value b", b, decimals);
 404 |     |             fail();
 405 |     |         }
 406 |     |     }
 407 |     |     function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {
 408 |     |         if (a > b) {
 409 |     |             emit log_named_string("Error", err);
 410 |     |             assertLeDecimal(a, b, decimals);
 411 |     |         }
 412 |     |     }
 413 |     |     function assertLeDecimal(uint a, uint b, uint decimals) internal {
 414 |     |         if (a > b) {
 415 |     |             emit log("Error: a <= b not satisfied [decimal uint]");
 416 |     |             emit log_named_decimal_uint("  Value a", a, decimals);
 417 |     |             emit log_named_decimal_uint("  Value b", b, decimals);
 418 |     |             fail();
 419 |     |         }
 420 |     |     }
 421 |     |     function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {
 422 |     |         if (a > b) {
 423 |     |             emit log_named_string("Error", err);
 424 |     |             assertLeDecimal(a, b, decimals);
 425 |     |         }
 426 |     |     }
 427 |     | 
 428 |     |     function assertEq(string memory a, string memory b) internal {
 429 |     |         if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {
 430 |     |             emit log("Error: a == b not satisfied [string]");
 431 |     |             emit log_named_string("      Left", a);
 432 |     |             emit log_named_string("     Right", b);
 433 |     |             fail();
 434 |     |         }
 435 |     |     }
 436 |     |     function assertEq(string memory a, string memory b, string memory err) internal {
 437 |     |         if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {
 438 |     |             emit log_named_string("Error", err);
 439 |     |             assertEq(a, b);
 440 |     |         }
 441 |     |     }
 442 |     | 
 443 |     |     function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {
 444 |     |         ok = true;
 445 |     |         if (a.length == b.length) {
 446 |     |             for (uint i = 0; i < a.length; i++) {
 447 |     |                 if (a[i] != b[i]) {
 448 |     |                     ok = false;
 449 |     |                 }
 450 |     |             }
 451 |     |         } else {
 452 |     |             ok = false;
 453 |     |         }
 454 |     |     }
 455 |     |     function assertEq0(bytes memory a, bytes memory b) internal {
 456 |     |         if (!checkEq0(a, b)) {
 457 |     |             emit log("Error: a == b not satisfied [bytes]");
 458 |     |             emit log_named_bytes("      Left", a);
 459 |     |             emit log_named_bytes("     Right", b);
 460 |     |             fail();
 461 |     |         }
 462 |     |     }
 463 |     |     function assertEq0(bytes memory a, bytes memory b, string memory err) internal {
 464 |     |         if (!checkEq0(a, b)) {
 465 |     |             emit log_named_string("Error", err);
 466 |     |             assertEq0(a, b);
 467 |     |         }
 468 |     |     }
 469 |     | }
 470 |     | 

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/forge-std/src/Base.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | import {StdStorage} from "./StdStorage.sol";
  5 |     | import {Vm, VmSafe} from "./Vm.sol";
  6 |     | 
  7 |     | abstract contract CommonBase {
  8 |     |     // Cheat code address, 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D.
  9 |     |     address internal constant VM_ADDRESS = address(uint160(uint256(keccak256("hevm cheat code"))));
 10 |     |     // console.sol and console2.sol work by executing a staticcall to this address.
 11 |     |     address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;
 12 |     |     // Default address for tx.origin and msg.sender, 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38.
 13 |     |     address internal constant DEFAULT_SENDER = address(uint160(uint256(keccak256("foundry default caller"))));
 14 |     |     // Address of the test contract, deployed by the DEFAULT_SENDER.
 15 |     |     address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;
 16 |     |     // Deterministic deployment address of the Multicall3 contract.
 17 |     |     address internal constant MULTICALL3_ADDRESS = 0xcA11bde05977b3631167028862bE2a173976CA11;
 18 |     | 
 19 |     |     uint256 internal constant UINT256_MAX =
 20 |     |         115792089237316195423570985008687907853269984665640564039457584007913129639935;
 21 |     | 
 22 |     |     Vm internal constant vm = Vm(VM_ADDRESS);
 23 |     |     StdStorage internal stdstore;
 24 |     | }
 25 |     | 
 26 |     | abstract contract TestBase is CommonBase {}
 27 |     | 
 28 |     | abstract contract ScriptBase is CommonBase {
 29 |     |     // Used when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.
 30 |     |     address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;
 31 |     | 
 32 |     |     VmSafe internal constant vmSafe = VmSafe(VM_ADDRESS);
 33 |     | }
 34 |     | 

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/forge-std/src/Script.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | // 💬 ABOUT
  5 |     | // Standard Library's default Script.
  6 |     | 
  7 |     | // 🧩 MODULES
  8 |     | import {ScriptBase} from "./Base.sol";
  9 |     | import {console} from "./console.sol";
 10 |     | import {console2} from "./console2.sol";
 11 |     | import {StdChains} from "./StdChains.sol";
 12 |     | import {StdCheatsSafe} from "./StdCheats.sol";
 13 |     | import {stdJson} from "./StdJson.sol";
 14 |     | import {stdMath} from "./StdMath.sol";
 15 |     | import {StdStorage, stdStorageSafe} from "./StdStorage.sol";
 16 |     | import {StdUtils} from "./StdUtils.sol";
 17 |     | import {VmSafe} from "./Vm.sol";
 18 |     | 
 19 |     | // 📦 BOILERPLATE
 20 |     | import {ScriptBase} from "./Base.sol";
 21 |     | 
 22 |     | // ⭐️ SCRIPT
 23 |     | abstract contract Script is StdChains, StdCheatsSafe, StdUtils, ScriptBase {
 24 |     |     // Note: IS_SCRIPT() must return true.
 25 |     |     bool public IS_SCRIPT = true;
 26 |     | }
 27 |     | 

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/forge-std/src/StdAssertions.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | import {DSTest} from "ds-test/test.sol";
   5 |     | import {stdMath} from "./StdMath.sol";
   6 |     | 
   7 |     | abstract contract StdAssertions is DSTest {
   8 |     |     event log_array(uint256[] val);
   9 |     |     event log_array(int256[] val);
  10 |     |     event log_array(address[] val);
  11 |     |     event log_named_array(string key, uint256[] val);
  12 |     |     event log_named_array(string key, int256[] val);
  13 |     |     event log_named_array(string key, address[] val);
  14 |     | 
  15 |     |     function fail(string memory err) internal virtual {
  16 |     |         emit log_named_string("Error", err);
  17 |     |         fail();
  18 |     |     }
  19 |     | 
  20 |     |     function assertFalse(bool data) internal virtual {
  21 |     |         assertTrue(!data);
  22 |     |     }
  23 |     | 
  24 |     |     function assertFalse(bool data, string memory err) internal virtual {
  25 |     |         assertTrue(!data, err);
  26 |     |     }
  27 |     | 
  28 |     |     function assertEq(bool a, bool b) internal virtual {
  29 |     |         if (a != b) {
  30 |     |             emit log("Error: a == b not satisfied [bool]");
  31 |     |             emit log_named_string("      Left", a ? "true" : "false");
  32 |     |             emit log_named_string("     Right", b ? "true" : "false");
  33 |     |             fail();
  34 |     |         }
  35 |     |     }
  36 |     | 
  37 |     |     function assertEq(bool a, bool b, string memory err) internal virtual {
  38 |     |         if (a != b) {
  39 |     |             emit log_named_string("Error", err);
  40 |     |             assertEq(a, b);
  41 |     |         }
  42 |     |     }
  43 |     | 
  44 |     |     function assertEq(bytes memory a, bytes memory b) internal virtual {
  45 |     |         assertEq0(a, b);
  46 |     |     }
  47 |     | 
  48 |     |     function assertEq(bytes memory a, bytes memory b, string memory err) internal virtual {
  49 |     |         assertEq0(a, b, err);
  50 |     |     }
  51 |     | 
  52 |     |     function assertEq(uint256[] memory a, uint256[] memory b) internal virtual {
  53 |     |         if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {
  54 |     |             emit log("Error: a == b not satisfied [uint[]]");
  55 |     |             emit log_named_array("      Left", a);
  56 |     |             emit log_named_array("     Right", b);
  57 |     |             fail();
  58 |     |         }
  59 |     |     }
  60 |     | 
  61 |     |     function assertEq(int256[] memory a, int256[] memory b) internal virtual {
  62 |     |         if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {
  63 |     |             emit log("Error: a == b not satisfied [int[]]");
  64 |     |             emit log_named_array("      Left", a);
  65 |     |             emit log_named_array("     Right", b);
  66 |     |             fail();
  67 |     |         }
  68 |     |     }
  69 |     | 
  70 |     |     function assertEq(address[] memory a, address[] memory b) internal virtual {
  71 |     |         if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {
  72 |     |             emit log("Error: a == b not satisfied [address[]]");
  73 |     |             emit log_named_array("      Left", a);
  74 |     |             emit log_named_array("     Right", b);
  75 |     |             fail();
  76 |     |         }
  77 |     |     }
  78 |     | 
  79 |     |     function assertEq(uint256[] memory a, uint256[] memory b, string memory err) internal virtual {
  80 |     |         if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {
  81 |     |             emit log_named_string("Error", err);
  82 |     |             assertEq(a, b);
  83 |     |         }
  84 |     |     }
  85 |     | 
  86 |     |     function assertEq(int256[] memory a, int256[] memory b, string memory err) internal virtual {
  87 |     |         if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {
  88 |     |             emit log_named_string("Error", err);
  89 |     |             assertEq(a, b);
  90 |     |         }
  91 |     |     }
  92 |     | 
  93 |     |     function assertEq(address[] memory a, address[] memory b, string memory err) internal virtual {
  94 |     |         if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {
  95 |     |             emit log_named_string("Error", err);
  96 |     |             assertEq(a, b);
  97 |     |         }
  98 |     |     }
  99 |     | 
 100 |     |     // Legacy helper
 101 |     |     function assertEqUint(uint256 a, uint256 b) internal virtual {
 102 |     |         assertEq(uint256(a), uint256(b));
 103 |     |     }
 104 |     | 
 105 |     |     function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta) internal virtual {
 106 |     |         uint256 delta = stdMath.delta(a, b);
 107 |     | 
 108 |     |         if (delta > maxDelta) {
 109 |     |             emit log("Error: a ~= b not satisfied [uint]");
 110 |     |             emit log_named_uint("      Left", a);
 111 |     |             emit log_named_uint("     Right", b);
 112 |     |             emit log_named_uint(" Max Delta", maxDelta);
 113 |     |             emit log_named_uint("     Delta", delta);
 114 |     |             fail();
 115 |     |         }
 116 |     |     }
 117 |     | 
 118 |     |     function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta, string memory err) internal virtual {
 119 |     |         uint256 delta = stdMath.delta(a, b);
 120 |     | 
 121 |     |         if (delta > maxDelta) {
 122 |     |             emit log_named_string("Error", err);
 123 |     |             assertApproxEqAbs(a, b, maxDelta);
 124 |     |         }
 125 |     |     }
 126 |     | 
 127 |     |     function assertApproxEqAbsDecimal(uint256 a, uint256 b, uint256 maxDelta, uint256 decimals) internal virtual {
 128 |     |         uint256 delta = stdMath.delta(a, b);
 129 |     | 
 130 |     |         if (delta > maxDelta) {
 131 |     |             emit log("Error: a ~= b not satisfied [uint]");
 132 |     |             emit log_named_decimal_uint("      Left", a, decimals);
 133 |     |             emit log_named_decimal_uint("     Right", b, decimals);
 134 |     |             emit log_named_decimal_uint(" Max Delta", maxDelta, decimals);
 135 |     |             emit log_named_decimal_uint("     Delta", delta, decimals);
 136 |     |             fail();
 137 |     |         }
 138 |     |     }
 139 |     | 
 140 |     |     function assertApproxEqAbsDecimal(uint256 a, uint256 b, uint256 maxDelta, uint256 decimals, string memory err)
 141 |     |         internal
 142 |     |         virtual
 143 |     |     {
 144 |     |         uint256 delta = stdMath.delta(a, b);
 145 |     | 
 146 |     |         if (delta > maxDelta) {
 147 |     |             emit log_named_string("Error", err);
 148 |     |             assertApproxEqAbsDecimal(a, b, maxDelta, decimals);
 149 |     |         }
 150 |     |     }
 151 |     | 
 152 |     |     function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta) internal virtual {
 153 |     |         uint256 delta = stdMath.delta(a, b);
 154 |     | 
 155 |     |         if (delta > maxDelta) {
 156 |     |             emit log("Error: a ~= b not satisfied [int]");
 157 |     |             emit log_named_int("       Left", a);
 158 |     |             emit log_named_int("      Right", b);
 159 |     |             emit log_named_uint(" Max Delta", maxDelta);
 160 |     |             emit log_named_uint("     Delta", delta);
 161 |     |             fail();
 162 |     |         }
 163 |     |     }
 164 |     | 
 165 |     |     function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta, string memory err) internal virtual {
 166 |     |         uint256 delta = stdMath.delta(a, b);
 167 |     | 
 168 |     |         if (delta > maxDelta) {
 169 |     |             emit log_named_string("Error", err);
 170 |     |             assertApproxEqAbs(a, b, maxDelta);
 171 |     |         }
 172 |     |     }
 173 |     | 
 174 |     |     function assertApproxEqAbsDecimal(int256 a, int256 b, uint256 maxDelta, uint256 decimals) internal virtual {
 175 |     |         uint256 delta = stdMath.delta(a, b);
 176 |     | 
 177 |     |         if (delta > maxDelta) {
 178 |     |             emit log("Error: a ~= b not satisfied [int]");
 179 |     |             emit log_named_decimal_int("      Left", a, decimals);
 180 |     |             emit log_named_decimal_int("     Right", b, decimals);
 181 |     |             emit log_named_decimal_uint(" Max Delta", maxDelta, decimals);
 182 |     |             emit log_named_decimal_uint("     Delta", delta, decimals);
 183 |     |             fail();
 184 |     |         }
 185 |     |     }
 186 |     | 
 187 |     |     function assertApproxEqAbsDecimal(int256 a, int256 b, uint256 maxDelta, uint256 decimals, string memory err)
 188 |     |         internal
 189 |     |         virtual
 190 |     |     {
 191 |     |         uint256 delta = stdMath.delta(a, b);
 192 |     | 
 193 |     |         if (delta > maxDelta) {
 194 |     |             emit log_named_string("Error", err);
 195 |     |             assertApproxEqAbsDecimal(a, b, maxDelta, decimals);
 196 |     |         }
 197 |     |     }
 198 |     | 
 199 |     |     function assertApproxEqRel(
 200 |     |         uint256 a,
 201 |     |         uint256 b,
 202 |     |         uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%
 203 |     |     ) internal virtual {
 204 |     |         if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.
 205 |     | 
 206 |     |         uint256 percentDelta = stdMath.percentDelta(a, b);
 207 |     | 
 208 |     |         if (percentDelta > maxPercentDelta) {
 209 |     |             emit log("Error: a ~= b not satisfied [uint]");
 210 |     |             emit log_named_uint("        Left", a);
 211 |     |             emit log_named_uint("       Right", b);
 212 |     |             emit log_named_decimal_uint(" Max % Delta", maxPercentDelta, 18);
 213 |     |             emit log_named_decimal_uint("     % Delta", percentDelta, 18);
 214 |     |             fail();
 215 |     |         }
 216 |     |     }
 217 |     | 
 218 |     |     function assertApproxEqRel(
 219 |     |         uint256 a,
 220 |     |         uint256 b,
 221 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 222 |     |         string memory err
 223 |     |     ) internal virtual {
 224 |     |         if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.
 225 |     | 
 226 |     |         uint256 percentDelta = stdMath.percentDelta(a, b);
 227 |     | 
 228 |     |         if (percentDelta > maxPercentDelta) {
 229 |     |             emit log_named_string("Error", err);
 230 |     |             assertApproxEqRel(a, b, maxPercentDelta);
 231 |     |         }
 232 |     |     }
 233 |     | 
 234 |     |     function assertApproxEqRelDecimal(
 235 |     |         uint256 a,
 236 |     |         uint256 b,
 237 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 238 |     |         uint256 decimals
 239 |     |     ) internal virtual {
 240 |     |         if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.
 241 |     | 
 242 |     |         uint256 percentDelta = stdMath.percentDelta(a, b);
 243 |     | 
 244 |     |         if (percentDelta > maxPercentDelta) {
 245 |     |             emit log("Error: a ~= b not satisfied [uint]");
 246 |     |             emit log_named_decimal_uint("        Left", a, decimals);
 247 |     |             emit log_named_decimal_uint("       Right", b, decimals);
 248 |     |             emit log_named_decimal_uint(" Max % Delta", maxPercentDelta, 18);
 249 |     |             emit log_named_decimal_uint("     % Delta", percentDelta, 18);
 250 |     |             fail();
 251 |     |         }
 252 |     |     }
 253 |     | 
 254 |     |     function assertApproxEqRelDecimal(
 255 |     |         uint256 a,
 256 |     |         uint256 b,
 257 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 258 |     |         uint256 decimals,
 259 |     |         string memory err
 260 |     |     ) internal virtual {
 261 |     |         if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.
 262 |     | 
 263 |     |         uint256 percentDelta = stdMath.percentDelta(a, b);
 264 |     | 
 265 |     |         if (percentDelta > maxPercentDelta) {
 266 |     |             emit log_named_string("Error", err);
 267 |     |             assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals);
 268 |     |         }
 269 |     |     }
 270 |     | 
 271 |     |     function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta) internal virtual {
 272 |     |         if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.
 273 |     | 
 274 |     |         uint256 percentDelta = stdMath.percentDelta(a, b);
 275 |     | 
 276 |     |         if (percentDelta > maxPercentDelta) {
 277 |     |             emit log("Error: a ~= b not satisfied [int]");
 278 |     |             emit log_named_int("        Left", a);
 279 |     |             emit log_named_int("       Right", b);
 280 |     |             emit log_named_decimal_uint(" Max % Delta", maxPercentDelta, 18);
 281 |     |             emit log_named_decimal_uint("     % Delta", percentDelta, 18);
 282 |     |             fail();
 283 |     |         }
 284 |     |     }
 285 |     | 
 286 |     |     function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta, string memory err) internal virtual {
 287 |     |         if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.
 288 |     | 
 289 |     |         uint256 percentDelta = stdMath.percentDelta(a, b);
 290 |     | 
 291 |     |         if (percentDelta > maxPercentDelta) {
 292 |     |             emit log_named_string("Error", err);
 293 |     |             assertApproxEqRel(a, b, maxPercentDelta);
 294 |     |         }
 295 |     |     }
 296 |     | 
 297 |     |     function assertApproxEqRelDecimal(int256 a, int256 b, uint256 maxPercentDelta, uint256 decimals) internal virtual {
 298 |     |         if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.
 299 |     | 
 300 |     |         uint256 percentDelta = stdMath.percentDelta(a, b);
 301 |     | 
 302 |     |         if (percentDelta > maxPercentDelta) {
 303 |     |             emit log("Error: a ~= b not satisfied [int]");
 304 |     |             emit log_named_decimal_int("        Left", a, decimals);
 305 |     |             emit log_named_decimal_int("       Right", b, decimals);
 306 |     |             emit log_named_decimal_uint(" Max % Delta", maxPercentDelta, 18);
 307 |     |             emit log_named_decimal_uint("     % Delta", percentDelta, 18);
 308 |     |             fail();
 309 |     |         }
 310 |     |     }
 311 |     | 
 312 |     |     function assertApproxEqRelDecimal(int256 a, int256 b, uint256 maxPercentDelta, uint256 decimals, string memory err)
 313 |     |         internal
 314 |     |         virtual
 315 |     |     {
 316 |     |         if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.
 317 |     | 
 318 |     |         uint256 percentDelta = stdMath.percentDelta(a, b);
 319 |     | 
 320 |     |         if (percentDelta > maxPercentDelta) {
 321 |     |             emit log_named_string("Error", err);
 322 |     |             assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals);
 323 |     |         }
 324 |     |     }
 325 |     | 
 326 |     |     function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB) internal virtual {
 327 |     |         assertEqCall(target, callDataA, target, callDataB, true);
 328 |     |     }
 329 |     | 
 330 |     |     function assertEqCall(address targetA, bytes memory callDataA, address targetB, bytes memory callDataB)
 331 |     |         internal
 332 |     |         virtual
 333 |     |     {
 334 |     |         assertEqCall(targetA, callDataA, targetB, callDataB, true);
 335 |     |     }
 336 |     | 
 337 |     |     function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB, bool strictRevertData)
 338 |     |         internal
 339 |     |         virtual
 340 |     |     {
 341 |     |         assertEqCall(target, callDataA, target, callDataB, strictRevertData);
 342 |     |     }
 343 |     | 
 344 |     |     function assertEqCall(
 345 |     |         address targetA,
 346 |     |         bytes memory callDataA,
 347 |     |         address targetB,
 348 |     |         bytes memory callDataB,
 349 |     |         bool strictRevertData
 350 |     |     ) internal virtual {
 351 |     |         (bool successA, bytes memory returnDataA) = address(targetA).call(callDataA);
 352 |     |         (bool successB, bytes memory returnDataB) = address(targetB).call(callDataB);
 353 |     | 
 354 |     |         if (successA && successB) {
 355 |     |             assertEq(returnDataA, returnDataB, "Call return data does not match");
 356 |     |         }
 357 |     | 
 358 |     |         if (!successA && !successB && strictRevertData) {
 359 |     |             assertEq(returnDataA, returnDataB, "Call revert data does not match");
 360 |     |         }
 361 |     | 
 362 |     |         if (!successA && successB) {
 363 |     |             emit log("Error: Calls were not equal");
 364 |     |             emit log_named_bytes("  Left call revert data", returnDataA);
 365 |     |             emit log_named_bytes(" Right call return data", returnDataB);
 366 |     |             fail();
 367 |     |         }
 368 |     | 
 369 |     |         if (successA && !successB) {
 370 |     |             emit log("Error: Calls were not equal");
 371 |     |             emit log_named_bytes("  Left call return data", returnDataA);
 372 |     |             emit log_named_bytes(" Right call revert data", returnDataB);
 373 |     |             fail();
 374 |     |         }
 375 |     |     }
 376 |     | }
 377 |     | 

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/forge-std/src/StdChains.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | import {VmSafe} from "./Vm.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * StdChains provides information about EVM compatible chains that can be used in scripts/tests.
  10 |     |  * For each chain, the chain's name, chain ID, and a default RPC URL are provided. Chains are
  11 |     |  * identified by their alias, which is the same as the alias in the `[rpc_endpoints]` section of
  12 |     |  * the `foundry.toml` file. For best UX, ensure the alias in the `foundry.toml` file match the
  13 |     |  * alias used in this contract, which can be found as the first argument to the
  14 |     |  * `setChainWithDefaultRpcUrl` call in the `initialize` function.
  15 |     |  *
  16 |     |  * There are two main ways to use this contract:
  17 |     |  *   1. Set a chain with `setChain(string memory chainAlias, ChainData memory chain)` or
  18 |     |  *      `setChain(string memory chainAlias, Chain memory chain)`
  19 |     |  *   2. Get a chain with `getChain(string memory chainAlias)` or `getChain(uint256 chainId)`.
  20 |     |  *
  21 |     |  * The first time either of those are used, chains are initialized with the default set of RPC URLs.
  22 |     |  * This is done in `initialize`, which uses `setChainWithDefaultRpcUrl`. Defaults are recorded in
  23 |     |  * `defaultRpcUrls`.
  24 |     |  *
  25 |     |  * The `setChain` function is straightforward, and it simply saves off the given chain data.
  26 |     |  *
  27 |     |  * The `getChain` methods use `getChainWithUpdatedRpcUrl` to return a chain. For example, let's say
  28 |     |  * we want to retrieve `mainnet`'s RPC URL:
  29 |     |  *   - If you haven't set any mainnet chain info with `setChain`, you haven't specified that
  30 |     |  *     chain in `foundry.toml` and no env var is set, the default data and RPC URL will be returned.
  31 |     |  *   - If you have set a mainnet RPC URL in `foundry.toml` it will return that, if valid (e.g. if
  32 |     |  *     a URL is given or if an environment variable is given and that environment variable exists).
  33 |     |  *     Otherwise, the default data is returned.
  34 |     |  *   - If you specified data with `setChain` it will return that.
  35 |     |  *
  36 |     |  * Summarizing the above, the prioritization hierarchy is `setChain` -> `foundry.toml` -> environment variable -> defaults.
  37 |     |  */
  38 |     | abstract contract StdChains {
  39 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
  40 |     | 
  41 |     |     bool private initialized;
  42 |     | 
  43 |     |     struct ChainData {
  44 |     |         string name;
  45 |     |         uint256 chainId;
  46 |     |         string rpcUrl;
  47 |     |     }
  48 |     | 
  49 |     |     struct Chain {
  50 |     |         // The chain name.
  51 |     |         string name;
  52 |     |         // The chain's Chain ID.
  53 |     |         uint256 chainId;
  54 |     |         // The chain's alias. (i.e. what gets specified in `foundry.toml`).
  55 |     |         string chainAlias;
  56 |     |         // A default RPC endpoint for this chain.
  57 |     |         // NOTE: This default RPC URL is included for convenience to facilitate quick tests and
  58 |     |         // experimentation. Do not use this RPC URL for production test suites, CI, or other heavy
  59 |     |         // usage as you will be throttled and this is a disservice to others who need this endpoint.
  60 |     |         string rpcUrl;
  61 |     |     }
  62 |     | 
  63 |     |     // Maps from the chain's alias (matching the alias in the `foundry.toml` file) to chain data.
  64 |     |     mapping(string => Chain) private chains;
  65 |     |     // Maps from the chain's alias to it's default RPC URL.
  66 |     |     mapping(string => string) private defaultRpcUrls;
  67 |     |     // Maps from a chain ID to it's alias.
  68 |     |     mapping(uint256 => string) private idToAlias;
  69 |     | 
  70 |     |     bool private fallbackToDefaultRpcUrls = true;
  71 |     | 
  72 |     |     // The RPC URL will be fetched from config or defaultRpcUrls if possible.
  73 |     |     function getChain(string memory chainAlias) internal virtual returns (Chain memory chain) {
  74 |     |         require(bytes(chainAlias).length != 0, "StdChains getChain(string): Chain alias cannot be the empty string.");
  75 |     | 
  76 |     |         initialize();
  77 |     |         chain = chains[chainAlias];
  78 |     |         require(
  79 |     |             chain.chainId != 0,
  80 |     |             string(abi.encodePacked("StdChains getChain(string): Chain with alias \"", chainAlias, "\" not found."))
  81 |     |         );
  82 |     | 
  83 |     |         chain = getChainWithUpdatedRpcUrl(chainAlias, chain);
  84 |     |     }
  85 |     | 
  86 |     |     function getChain(uint256 chainId) internal virtual returns (Chain memory chain) {
  87 |     |         require(chainId != 0, "StdChains getChain(uint256): Chain ID cannot be 0.");
  88 |     |         initialize();
  89 |     |         string memory chainAlias = idToAlias[chainId];
  90 |     | 
  91 |     |         chain = chains[chainAlias];
  92 |     | 
  93 |     |         require(
  94 |     |             chain.chainId != 0,
  95 |     |             string(abi.encodePacked("StdChains getChain(uint256): Chain with ID ", vm.toString(chainId), " not found."))
  96 |     |         );
  97 |     | 
  98 |     |         chain = getChainWithUpdatedRpcUrl(chainAlias, chain);
  99 |     |     }
 100 |     | 
 101 |     |     // set chain info, with priority to argument's rpcUrl field.
 102 |     |     function setChain(string memory chainAlias, ChainData memory chain) internal virtual {
 103 |     |         require(
 104 |     |             bytes(chainAlias).length != 0,
 105 |     |             "StdChains setChain(string,ChainData): Chain alias cannot be the empty string."
 106 |     |         );
 107 |     | 
 108 |     |         require(chain.chainId != 0, "StdChains setChain(string,ChainData): Chain ID cannot be 0.");
 109 |     | 
 110 |     |         initialize();
 111 |     |         string memory foundAlias = idToAlias[chain.chainId];
 112 |     | 
 113 |     |         require(
 114 |     |             bytes(foundAlias).length == 0 || keccak256(bytes(foundAlias)) == keccak256(bytes(chainAlias)),
 115 |     |             string(
 116 |     |                 abi.encodePacked(
 117 |     |                     "StdChains setChain(string,ChainData): Chain ID ",
 118 |     |                     vm.toString(chain.chainId),
 119 |     |                     " already used by \"",
 120 |     |                     foundAlias,
 121 |     |                     "\"."
 122 |     |                 )
 123 |     |             )
 124 |     |         );
 125 |     | 
 126 |     |         uint256 oldChainId = chains[chainAlias].chainId;
 127 |     |         delete idToAlias[oldChainId];
 128 |     | 
 129 |     |         chains[chainAlias] =
 130 |     |             Chain({name: chain.name, chainId: chain.chainId, chainAlias: chainAlias, rpcUrl: chain.rpcUrl});
 131 |     |         idToAlias[chain.chainId] = chainAlias;
 132 |     |     }
 133 |     | 
 134 |     |     // set chain info, with priority to argument's rpcUrl field.
 135 |     |     function setChain(string memory chainAlias, Chain memory chain) internal virtual {
 136 |     |         setChain(chainAlias, ChainData({name: chain.name, chainId: chain.chainId, rpcUrl: chain.rpcUrl}));
 137 |     |     }
 138 |     | 
 139 |     |     function _toUpper(string memory str) private pure returns (string memory) {
 140 |     |         bytes memory strb = bytes(str);
 141 |     |         bytes memory copy = new bytes(strb.length);
 142 |     |         for (uint256 i = 0; i < strb.length; i++) {
 143 |     |             bytes1 b = strb[i];
 144 |     |             if (b >= 0x61 && b <= 0x7A) {
 145 |     |                 copy[i] = bytes1(uint8(b) - 32);
 146 |     |             } else {
 147 |     |                 copy[i] = b;
 148 |     |             }
 149 |     |         }
 150 |     |         return string(copy);
 151 |     |     }
 152 |     | 
 153 |     |     // lookup rpcUrl, in descending order of priority:
 154 |     |     // current -> config (foundry.toml) -> environment variable -> default
 155 |     |     function getChainWithUpdatedRpcUrl(string memory chainAlias, Chain memory chain) private returns (Chain memory) {
 156 |     |         if (bytes(chain.rpcUrl).length == 0) {
 157 |     |             try vm.rpcUrl(chainAlias) returns (string memory configRpcUrl) {
 158 |     |                 chain.rpcUrl = configRpcUrl;
 159 |     |             } catch (bytes memory err) {
 160 |     |                 string memory envName = string(abi.encodePacked(_toUpper(chainAlias), "_RPC_URL"));
 161 |     |                 if (fallbackToDefaultRpcUrls) {
 162 |     |                     chain.rpcUrl = vm.envOr(envName, defaultRpcUrls[chainAlias]);
 163 |     |                 } else {
 164 |     |                     chain.rpcUrl = vm.envString(envName);
 165 |     |                 }
 166 |     |                 // distinguish 'not found' from 'cannot read'
 167 |     |                 bytes memory notFoundError =
 168 |     |                     abi.encodeWithSignature("CheatCodeError", string(abi.encodePacked("invalid rpc url ", chainAlias)));
 169 |     |                 if (keccak256(notFoundError) != keccak256(err) || bytes(chain.rpcUrl).length == 0) {
 170 |     |                     /// @solidity memory-safe-assembly
 171 |     |                     assembly {
 172 |     |                         revert(add(32, err), mload(err))
 173 |     |                     }
 174 |     |                 }
 175 |     |             }
 176 |     |         }
 177 |     |         return chain;
 178 |     |     }
 179 |     | 
 180 |     |     function setFallbackToDefaultRpcUrls(bool useDefault) internal {
 181 |     |         fallbackToDefaultRpcUrls = useDefault;
 182 |     |     }
 183 |     | 
 184 |     |     function initialize() private {
 185 |     |         if (initialized) return;
 186 |     | 
 187 |     |         initialized = true;
 188 |     | 
 189 |     |         // If adding an RPC here, make sure to test the default RPC URL in `testRpcs`
 190 |     |         setChainWithDefaultRpcUrl("anvil", ChainData("Anvil", 31337, "http://127.0.0.1:8545"));
 191 |     |         setChainWithDefaultRpcUrl(
 192 |     |             "mainnet", ChainData("Mainnet", 1, "https://mainnet.infura.io/v3/f4a0bdad42674adab5fc0ac077ffab2b")
 193 |     |         );
 194 |     |         setChainWithDefaultRpcUrl(
 195 |     |             "goerli", ChainData("Goerli", 5, "https://goerli.infura.io/v3/f4a0bdad42674adab5fc0ac077ffab2b")
 196 |     |         );
 197 |     |         setChainWithDefaultRpcUrl(
 198 |     |             "sepolia", ChainData("Sepolia", 11155111, "https://sepolia.infura.io/v3/f4a0bdad42674adab5fc0ac077ffab2b")
 199 |     |         );
 200 |     |         setChainWithDefaultRpcUrl("optimism", ChainData("Optimism", 10, "https://mainnet.optimism.io"));
 201 |     |         setChainWithDefaultRpcUrl("optimism_goerli", ChainData("Optimism Goerli", 420, "https://goerli.optimism.io"));
 202 |     |         setChainWithDefaultRpcUrl("arbitrum_one", ChainData("Arbitrum One", 42161, "https://arb1.arbitrum.io/rpc"));
 203 |     |         setChainWithDefaultRpcUrl(
 204 |     |             "arbitrum_one_goerli", ChainData("Arbitrum One Goerli", 421613, "https://goerli-rollup.arbitrum.io/rpc")
 205 |     |         );
 206 |     |         setChainWithDefaultRpcUrl("arbitrum_nova", ChainData("Arbitrum Nova", 42170, "https://nova.arbitrum.io/rpc"));
 207 |     |         setChainWithDefaultRpcUrl("polygon", ChainData("Polygon", 137, "https://polygon-rpc.com"));
 208 |     |         setChainWithDefaultRpcUrl(
 209 |     |             "polygon_mumbai", ChainData("Polygon Mumbai", 80001, "https://rpc-mumbai.maticvigil.com")
 210 |     |         );
 211 |     |         setChainWithDefaultRpcUrl("avalanche", ChainData("Avalanche", 43114, "https://api.avax.network/ext/bc/C/rpc"));
 212 |     |         setChainWithDefaultRpcUrl(
 213 |     |             "avalanche_fuji", ChainData("Avalanche Fuji", 43113, "https://api.avax-test.network/ext/bc/C/rpc")
 214 |     |         );
 215 |     |         setChainWithDefaultRpcUrl(
 216 |     |             "bnb_smart_chain", ChainData("BNB Smart Chain", 56, "https://bsc-dataseed1.binance.org")
 217 |     |         );
 218 |     |         setChainWithDefaultRpcUrl(
 219 |     |             "bnb_smart_chain_testnet",
 220 |     |             ChainData("BNB Smart Chain Testnet", 97, "https://rpc.ankr.com/bsc_testnet_chapel")
 221 |     |         );
 222 |     |         setChainWithDefaultRpcUrl("gnosis_chain", ChainData("Gnosis Chain", 100, "https://rpc.gnosischain.com"));
 223 |     |     }
 224 |     | 
 225 |     |     // set chain info, with priority to chainAlias' rpc url in foundry.toml
 226 |     |     function setChainWithDefaultRpcUrl(string memory chainAlias, ChainData memory chain) private {
 227 |     |         string memory rpcUrl = chain.rpcUrl;
 228 |     |         defaultRpcUrls[chainAlias] = rpcUrl;
 229 |     |         chain.rpcUrl = "";
 230 |     |         setChain(chainAlias, chain);
 231 |     |         chain.rpcUrl = rpcUrl; // restore argument
 232 |     |     }
 233 |     | }
 234 |     | 

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/forge-std/src/StdCheats.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | import {StdStorage, stdStorage} from "./StdStorage.sol";
   7 |     | import {Vm} from "./Vm.sol";
   8 |     | 
   9 |     | abstract contract StdCheatsSafe {
  10 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
  11 |     | 
  12 |     |     bool private gasMeteringOff;
  13 |     | 
  14 |     |     // Data structures to parse Transaction objects from the broadcast artifact
  15 |     |     // that conform to EIP1559. The Raw structs is what is parsed from the JSON
  16 |     |     // and then converted to the one that is used by the user for better UX.
  17 |     | 
  18 |     |     struct RawTx1559 {
  19 |     |         string[] arguments;
  20 |     |         address contractAddress;
  21 |     |         string contractName;
  22 |     |         // json value name = function
  23 |     |         string functionSig;
  24 |     |         bytes32 hash;
  25 |     |         // json value name = tx
  26 |     |         RawTx1559Detail txDetail;
  27 |     |         // json value name = type
  28 |     |         string opcode;
  29 |     |     }
  30 |     | 
  31 |     |     struct RawTx1559Detail {
  32 |     |         AccessList[] accessList;
  33 |     |         bytes data;
  34 |     |         address from;
  35 |     |         bytes gas;
  36 |     |         bytes nonce;
  37 |     |         address to;
  38 |     |         bytes txType;
  39 |     |         bytes value;
  40 |     |     }
  41 |     | 
  42 |     |     struct Tx1559 {
  43 |     |         string[] arguments;
  44 |     |         address contractAddress;
  45 |     |         string contractName;
  46 |     |         string functionSig;
  47 |     |         bytes32 hash;
  48 |     |         Tx1559Detail txDetail;
  49 |     |         string opcode;
  50 |     |     }
  51 |     | 
  52 |     |     struct Tx1559Detail {
  53 |     |         AccessList[] accessList;
  54 |     |         bytes data;
  55 |     |         address from;
  56 |     |         uint256 gas;
  57 |     |         uint256 nonce;
  58 |     |         address to;
  59 |     |         uint256 txType;
  60 |     |         uint256 value;
  61 |     |     }
  62 |     | 
  63 |     |     // Data structures to parse Transaction objects from the broadcast artifact
  64 |     |     // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON
  65 |     |     // and then converted to the one that is used by the user for better UX.
  66 |     | 
  67 |     |     struct TxLegacy {
  68 |     |         string[] arguments;
  69 |     |         address contractAddress;
  70 |     |         string contractName;
  71 |     |         string functionSig;
  72 |     |         string hash;
  73 |     |         string opcode;
  74 |     |         TxDetailLegacy transaction;
  75 |     |     }
  76 |     | 
  77 |     |     struct TxDetailLegacy {
  78 |     |         AccessList[] accessList;
  79 |     |         uint256 chainId;
  80 |     |         bytes data;
  81 |     |         address from;
  82 |     |         uint256 gas;
  83 |     |         uint256 gasPrice;
  84 |     |         bytes32 hash;
  85 |     |         uint256 nonce;
  86 |     |         bytes1 opcode;
  87 |     |         bytes32 r;
  88 |     |         bytes32 s;
  89 |     |         uint256 txType;
  90 |     |         address to;
  91 |     |         uint8 v;
  92 |     |         uint256 value;
  93 |     |     }
  94 |     | 
  95 |     |     struct AccessList {
  96 |     |         address accessAddress;
  97 |     |         bytes32[] storageKeys;
  98 |     |     }
  99 |     | 
 100 |     |     // Data structures to parse Receipt objects from the broadcast artifact.
 101 |     |     // The Raw structs is what is parsed from the JSON
 102 |     |     // and then converted to the one that is used by the user for better UX.
 103 |     | 
 104 |     |     struct RawReceipt {
 105 |     |         bytes32 blockHash;
 106 |     |         bytes blockNumber;
 107 |     |         address contractAddress;
 108 |     |         bytes cumulativeGasUsed;
 109 |     |         bytes effectiveGasPrice;
 110 |     |         address from;
 111 |     |         bytes gasUsed;
 112 |     |         RawReceiptLog[] logs;
 113 |     |         bytes logsBloom;
 114 |     |         bytes status;
 115 |     |         address to;
 116 |     |         bytes32 transactionHash;
 117 |     |         bytes transactionIndex;
 118 |     |     }
 119 |     | 
 120 |     |     struct Receipt {
 121 |     |         bytes32 blockHash;
 122 |     |         uint256 blockNumber;
 123 |     |         address contractAddress;
 124 |     |         uint256 cumulativeGasUsed;
 125 |     |         uint256 effectiveGasPrice;
 126 |     |         address from;
 127 |     |         uint256 gasUsed;
 128 |     |         ReceiptLog[] logs;
 129 |     |         bytes logsBloom;
 130 |     |         uint256 status;
 131 |     |         address to;
 132 |     |         bytes32 transactionHash;
 133 |     |         uint256 transactionIndex;
 134 |     |     }
 135 |     | 
 136 |     |     // Data structures to parse the entire broadcast artifact, assuming the
 137 |     |     // transactions conform to EIP1559.
 138 |     | 
 139 |     |     struct EIP1559ScriptArtifact {
 140 |     |         string[] libraries;
 141 |     |         string path;
 142 |     |         string[] pending;
 143 |     |         Receipt[] receipts;
 144 |     |         uint256 timestamp;
 145 |     |         Tx1559[] transactions;
 146 |     |         TxReturn[] txReturns;
 147 |     |     }
 148 |     | 
 149 |     |     struct RawEIP1559ScriptArtifact {
 150 |     |         string[] libraries;
 151 |     |         string path;
 152 |     |         string[] pending;
 153 |     |         RawReceipt[] receipts;
 154 |     |         TxReturn[] txReturns;
 155 |     |         uint256 timestamp;
 156 |     |         RawTx1559[] transactions;
 157 |     |     }
 158 |     | 
 159 |     |     struct RawReceiptLog {
 160 |     |         // json value = address
 161 |     |         address logAddress;
 162 |     |         bytes32 blockHash;
 163 |     |         bytes blockNumber;
 164 |     |         bytes data;
 165 |     |         bytes logIndex;
 166 |     |         bool removed;
 167 |     |         bytes32[] topics;
 168 |     |         bytes32 transactionHash;
 169 |     |         bytes transactionIndex;
 170 |     |         bytes transactionLogIndex;
 171 |     |     }
 172 |     | 
 173 |     |     struct ReceiptLog {
 174 |     |         // json value = address
 175 |     |         address logAddress;
 176 |     |         bytes32 blockHash;
 177 |     |         uint256 blockNumber;
 178 |     |         bytes data;
 179 |     |         uint256 logIndex;
 180 |     |         bytes32[] topics;
 181 |     |         uint256 transactionIndex;
 182 |     |         uint256 transactionLogIndex;
 183 |     |         bool removed;
 184 |     |     }
 185 |     | 
 186 |     |     struct TxReturn {
 187 |     |         string internalType;
 188 |     |         string value;
 189 |     |     }
 190 |     | 
 191 |     |     function assumeNoPrecompiles(address addr) internal virtual {
 192 |     |         // Assembly required since `block.chainid` was introduced in 0.8.0.
 193 |     |         uint256 chainId;
 194 |     |         assembly {
 195 |     |             chainId := chainid()
 196 |     |         }
 197 |     |         assumeNoPrecompiles(addr, chainId);
 198 |     |     }
 199 |     | 
 200 |     |     function assumeNoPrecompiles(address addr, uint256 chainId) internal pure virtual {
 201 |     |         // Note: For some chains like Optimism these are technically predeploys (i.e. bytecode placed at a specific
 202 |     |         // address), but the same rationale for excluding them applies so we include those too.
 203 |     | 
 204 |     |         // These should be present on all EVM-compatible chains.
 205 |     |         vm.assume(addr < address(0x1) || addr > address(0x9));
 206 |     | 
 207 |     |         // forgefmt: disable-start
 208 |     |         if (chainId == 10 || chainId == 420) {
 209 |     |             // https://github.com/ethereum-optimism/optimism/blob/eaa371a0184b56b7ca6d9eb9cb0a2b78b2ccd864/op-bindings/predeploys/addresses.go#L6-L21
 210 |     |             vm.assume(addr < address(0x4200000000000000000000000000000000000000) || addr > address(0x4200000000000000000000000000000000000800));
 211 |     |         } else if (chainId == 42161 || chainId == 421613) {
 212 |     |             // https://developer.arbitrum.io/useful-addresses#arbitrum-precompiles-l2-same-on-all-arb-chains
 213 |     |             vm.assume(addr < address(0x0000000000000000000000000000000000000064) || addr > address(0x0000000000000000000000000000000000000068));
 214 |     |         } else if (chainId == 43114 || chainId == 43113) {
 215 |     |             // https://github.com/ava-labs/subnet-evm/blob/47c03fd007ecaa6de2c52ea081596e0a88401f58/precompile/params.go#L18-L59
 216 |     |             vm.assume(addr < address(0x0100000000000000000000000000000000000000) || addr > address(0x01000000000000000000000000000000000000ff));
 217 |     |             vm.assume(addr < address(0x0200000000000000000000000000000000000000) || addr > address(0x02000000000000000000000000000000000000FF));
 218 |     |             vm.assume(addr < address(0x0300000000000000000000000000000000000000) || addr > address(0x03000000000000000000000000000000000000Ff));
 219 |     |         }
 220 |     |         // forgefmt: disable-end
 221 |     |     }
 222 |     | 
 223 |     |     function readEIP1559ScriptArtifact(string memory path)
 224 |     |         internal
 225 |     |         view
 226 |     |         virtual
 227 |     |         returns (EIP1559ScriptArtifact memory)
 228 |     |     {
 229 |     |         string memory data = vm.readFile(path);
 230 |     |         bytes memory parsedData = vm.parseJson(data);
 231 |     |         RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));
 232 |     |         EIP1559ScriptArtifact memory artifact;
 233 |     |         artifact.libraries = rawArtifact.libraries;
 234 |     |         artifact.path = rawArtifact.path;
 235 |     |         artifact.timestamp = rawArtifact.timestamp;
 236 |     |         artifact.pending = rawArtifact.pending;
 237 |     |         artifact.txReturns = rawArtifact.txReturns;
 238 |     |         artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);
 239 |     |         artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);
 240 |     |         return artifact;
 241 |     |     }
 242 |     | 
 243 |     |     function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs) internal pure virtual returns (Tx1559[] memory) {
 244 |     |         Tx1559[] memory txs = new Tx1559[](rawTxs.length);
 245 |     |         for (uint256 i; i < rawTxs.length; i++) {
 246 |     |             txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);
 247 |     |         }
 248 |     |         return txs;
 249 |     |     }
 250 |     | 
 251 |     |     function rawToConvertedEIPTx1559(RawTx1559 memory rawTx) internal pure virtual returns (Tx1559 memory) {
 252 |     |         Tx1559 memory transaction;
 253 |     |         transaction.arguments = rawTx.arguments;
 254 |     |         transaction.contractName = rawTx.contractName;
 255 |     |         transaction.functionSig = rawTx.functionSig;
 256 |     |         transaction.hash = rawTx.hash;
 257 |     |         transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);
 258 |     |         transaction.opcode = rawTx.opcode;
 259 |     |         return transaction;
 260 |     |     }
 261 |     | 
 262 |     |     function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)
 263 |     |         internal
 264 |     |         pure
 265 |     |         virtual
 266 |     |         returns (Tx1559Detail memory)
 267 |     |     {
 268 |     |         Tx1559Detail memory txDetail;
 269 |     |         txDetail.data = rawDetail.data;
 270 |     |         txDetail.from = rawDetail.from;
 271 |     |         txDetail.to = rawDetail.to;
 272 |     |         txDetail.nonce = _bytesToUint(rawDetail.nonce);
 273 |     |         txDetail.txType = _bytesToUint(rawDetail.txType);
 274 |     |         txDetail.value = _bytesToUint(rawDetail.value);
 275 |     |         txDetail.gas = _bytesToUint(rawDetail.gas);
 276 |     |         txDetail.accessList = rawDetail.accessList;
 277 |     |         return txDetail;
 278 |     |     }
 279 |     | 
 280 |     |     function readTx1559s(string memory path) internal view virtual returns (Tx1559[] memory) {
 281 |     |         string memory deployData = vm.readFile(path);
 282 |     |         bytes memory parsedDeployData = vm.parseJson(deployData, ".transactions");
 283 |     |         RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));
 284 |     |         return rawToConvertedEIPTx1559s(rawTxs);
 285 |     |     }
 286 |     | 
 287 |     |     function readTx1559(string memory path, uint256 index) internal view virtual returns (Tx1559 memory) {
 288 |     |         string memory deployData = vm.readFile(path);
 289 |     |         string memory key = string(abi.encodePacked(".transactions[", vm.toString(index), "]"));
 290 |     |         bytes memory parsedDeployData = vm.parseJson(deployData, key);
 291 |     |         RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));
 292 |     |         return rawToConvertedEIPTx1559(rawTx);
 293 |     |     }
 294 |     | 
 295 |     |     // Analogous to readTransactions, but for receipts.
 296 |     |     function readReceipts(string memory path) internal view virtual returns (Receipt[] memory) {
 297 |     |         string memory deployData = vm.readFile(path);
 298 |     |         bytes memory parsedDeployData = vm.parseJson(deployData, ".receipts");
 299 |     |         RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));
 300 |     |         return rawToConvertedReceipts(rawReceipts);
 301 |     |     }
 302 |     | 
 303 |     |     function readReceipt(string memory path, uint256 index) internal view virtual returns (Receipt memory) {
 304 |     |         string memory deployData = vm.readFile(path);
 305 |     |         string memory key = string(abi.encodePacked(".receipts[", vm.toString(index), "]"));
 306 |     |         bytes memory parsedDeployData = vm.parseJson(deployData, key);
 307 |     |         RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));
 308 |     |         return rawToConvertedReceipt(rawReceipt);
 309 |     |     }
 310 |     | 
 311 |     |     function rawToConvertedReceipts(RawReceipt[] memory rawReceipts) internal pure virtual returns (Receipt[] memory) {
 312 |     |         Receipt[] memory receipts = new Receipt[](rawReceipts.length);
 313 |     |         for (uint256 i; i < rawReceipts.length; i++) {
 314 |     |             receipts[i] = rawToConvertedReceipt(rawReceipts[i]);
 315 |     |         }
 316 |     |         return receipts;
 317 |     |     }
 318 |     | 
 319 |     |     function rawToConvertedReceipt(RawReceipt memory rawReceipt) internal pure virtual returns (Receipt memory) {
 320 |     |         Receipt memory receipt;
 321 |     |         receipt.blockHash = rawReceipt.blockHash;
 322 |     |         receipt.to = rawReceipt.to;
 323 |     |         receipt.from = rawReceipt.from;
 324 |     |         receipt.contractAddress = rawReceipt.contractAddress;
 325 |     |         receipt.effectiveGasPrice = _bytesToUint(rawReceipt.effectiveGasPrice);
 326 |     |         receipt.cumulativeGasUsed = _bytesToUint(rawReceipt.cumulativeGasUsed);
 327 |     |         receipt.gasUsed = _bytesToUint(rawReceipt.gasUsed);
 328 |     |         receipt.status = _bytesToUint(rawReceipt.status);
 329 |     |         receipt.transactionIndex = _bytesToUint(rawReceipt.transactionIndex);
 330 |     |         receipt.blockNumber = _bytesToUint(rawReceipt.blockNumber);
 331 |     |         receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);
 332 |     |         receipt.logsBloom = rawReceipt.logsBloom;
 333 |     |         receipt.transactionHash = rawReceipt.transactionHash;
 334 |     |         return receipt;
 335 |     |     }
 336 |     | 
 337 |     |     function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)
 338 |     |         internal
 339 |     |         pure
 340 |     |         virtual
 341 |     |         returns (ReceiptLog[] memory)
 342 |     |     {
 343 |     |         ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);
 344 |     |         for (uint256 i; i < rawLogs.length; i++) {
 345 |     |             logs[i].logAddress = rawLogs[i].logAddress;
 346 |     |             logs[i].blockHash = rawLogs[i].blockHash;
 347 |     |             logs[i].blockNumber = _bytesToUint(rawLogs[i].blockNumber);
 348 |     |             logs[i].data = rawLogs[i].data;
 349 |     |             logs[i].logIndex = _bytesToUint(rawLogs[i].logIndex);
 350 |     |             logs[i].topics = rawLogs[i].topics;
 351 |     |             logs[i].transactionIndex = _bytesToUint(rawLogs[i].transactionIndex);
 352 |     |             logs[i].transactionLogIndex = _bytesToUint(rawLogs[i].transactionLogIndex);
 353 |     |             logs[i].removed = rawLogs[i].removed;
 354 |     |         }
 355 |     |         return logs;
 356 |     |     }
 357 |     | 
 358 |     |     // Deploy a contract by fetching the contract bytecode from
 359 |     |     // the artifacts directory
 360 |     |     // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`
 361 |     |     function deployCode(string memory what, bytes memory args) internal virtual returns (address addr) {
 362 |     |         bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);
 363 |     |         /// @solidity memory-safe-assembly
 364 |     |         assembly {
 365 |     |             addr := create(0, add(bytecode, 0x20), mload(bytecode))
 366 |     |         }
 367 |     | 
 368 |     |         require(addr != address(0), "StdCheats deployCode(string,bytes): Deployment failed.");
 369 |     |     }
 370 |     | 
 371 |     |     function deployCode(string memory what) internal virtual returns (address addr) {
 372 |     |         bytes memory bytecode = vm.getCode(what);
 373 |     |         /// @solidity memory-safe-assembly
 374 |     |         assembly {
 375 |     |             addr := create(0, add(bytecode, 0x20), mload(bytecode))
 376 |     |         }
 377 |     | 
 378 |     |         require(addr != address(0), "StdCheats deployCode(string): Deployment failed.");
 379 |     |     }
 380 |     | 
 381 |     |     /// @dev deploy contract with value on construction
 382 |     |     function deployCode(string memory what, bytes memory args, uint256 val) internal virtual returns (address addr) {
 383 |     |         bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);
 384 |     |         /// @solidity memory-safe-assembly
 385 |     |         assembly {
 386 |     |             addr := create(val, add(bytecode, 0x20), mload(bytecode))
 387 |     |         }
 388 |     | 
 389 |     |         require(addr != address(0), "StdCheats deployCode(string,bytes,uint256): Deployment failed.");
 390 |     |     }
 391 |     | 
 392 |     |     function deployCode(string memory what, uint256 val) internal virtual returns (address addr) {
 393 |     |         bytes memory bytecode = vm.getCode(what);
 394 |     |         /// @solidity memory-safe-assembly
 395 |     |         assembly {
 396 |     |             addr := create(val, add(bytecode, 0x20), mload(bytecode))
 397 |     |         }
 398 |     | 
 399 |     |         require(addr != address(0), "StdCheats deployCode(string,uint256): Deployment failed.");
 400 |     |     }
 401 |     | 
 402 |     |     // creates a labeled address and the corresponding private key
 403 |     |     function makeAddrAndKey(string memory name) internal virtual returns (address addr, uint256 privateKey) {
 404 |     |         privateKey = uint256(keccak256(abi.encodePacked(name)));
 405 |     |         addr = vm.addr(privateKey);
 406 |     |         vm.label(addr, name);
 407 |     |     }
 408 |     | 
 409 |     |     // creates a labeled address
 410 |     |     function makeAddr(string memory name) internal virtual returns (address addr) {
 411 |     |         (addr,) = makeAddrAndKey(name);
 412 |     |     }
 413 |     | 
 414 |     |     function deriveRememberKey(string memory mnemonic, uint32 index)
 415 |     |         internal
 416 |     |         virtual
 417 |     |         returns (address who, uint256 privateKey)
 418 |     |     {
 419 |     |         privateKey = vm.deriveKey(mnemonic, index);
 420 |     |         who = vm.rememberKey(privateKey);
 421 |     |     }
 422 |     | 
 423 |     |     function _bytesToUint(bytes memory b) private pure returns (uint256) {
 424 |     |         require(b.length <= 32, "StdCheats _bytesToUint(bytes): Bytes length exceeds 32.");
 425 |     |         return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));
 426 |     |     }
 427 |     | 
 428 |     |     function isFork() internal view virtual returns (bool status) {
 429 |     |         try vm.activeFork() {
 430 |     |             status = true;
 431 |     |         } catch (bytes memory) {}
 432 |     |     }
 433 |     | 
 434 |     |     modifier skipWhenForking() {
 435 |     |         if (!isFork()) {
 436 |     |             _;
 437 |     |         }
 438 |     |     }
 439 |     | 
 440 |     |     modifier skipWhenNotForking() {
 441 |     |         if (isFork()) {
 442 |     |             _;
 443 |     |         }
 444 |     |     }
 445 |     | 
 446 |     |     modifier noGasMetering() {
 447 |     |         vm.pauseGasMetering();
 448 |     |         // To prevent turning gas monitoring back on with nested functions that use this modifier,
 449 |     |         // we check if gasMetering started in the off position. If it did, we don't want to turn
 450 |     |         // it back on until we exit the top level function that used the modifier
 451 |     |         //
 452 |     |         // i.e. funcA() noGasMetering { funcB() }, where funcB has noGasMetering as well.
 453 |     |         // funcA will have `gasStartedOff` as false, funcB will have it as true,
 454 |     |         // so we only turn metering back on at the end of the funcA
 455 |     |         bool gasStartedOff = gasMeteringOff;
 456 |     |         gasMeteringOff = true;
 457 |     | 
 458 |     |         _;
 459 |     | 
 460 |     |         // if gas metering was on when this modifier was called, turn it back on at the end
 461 |     |         if (!gasStartedOff) {
 462 |     |             gasMeteringOff = false;
 463 |     |             vm.resumeGasMetering();
 464 |     |         }
 465 |     |     }
 466 |     | 
 467 |     |     // a cheat for fuzzing addresses that are payable only
 468 |     |     // see https://github.com/foundry-rs/foundry/issues/3631
 469 |     |     function assumePayable(address addr) internal virtual {
 470 |     |         (bool success,) = payable(addr).call{value: 0}("");
 471 |     |         vm.assume(success);
 472 |     |     }
 473 |     | }
 474 |     | 
 475 |     | // Wrappers around cheatcodes to avoid footguns
 476 |     | abstract contract StdCheats is StdCheatsSafe {
 477 |     |     using stdStorage for StdStorage;
 478 |     | 
 479 |     |     StdStorage private stdstore;
 480 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
 481 |     | 
 482 |     |     // Skip forward or rewind time by the specified number of seconds
 483 |     |     function skip(uint256 time) internal virtual {
 484 |     |         vm.warp(block.timestamp + time);
 485 |     |     }
 486 |     | 
 487 |     |     function rewind(uint256 time) internal virtual {
 488 |     |         vm.warp(block.timestamp - time);
 489 |     |     }
 490 |     | 
 491 |     |     // Setup a prank from an address that has some ether
 492 |     |     function hoax(address msgSender) internal virtual {
 493 |     |         vm.deal(msgSender, 1 << 128);
 494 |     |         vm.prank(msgSender);
 495 |     |     }
 496 |     | 
 497 |     |     function hoax(address msgSender, uint256 give) internal virtual {
 498 |     |         vm.deal(msgSender, give);
 499 |     |         vm.prank(msgSender);
 500 |     |     }
 501 |     | 
 502 |     |     function hoax(address msgSender, address origin) internal virtual {
 503 |     |         vm.deal(msgSender, 1 << 128);
 504 |     |         vm.prank(msgSender, origin);
 505 |     |     }
 506 |     | 
 507 |     |     function hoax(address msgSender, address origin, uint256 give) internal virtual {
 508 |     |         vm.deal(msgSender, give);
 509 |     |         vm.prank(msgSender, origin);
 510 |     |     }
 511 |     | 
 512 |     |     // Start perpetual prank from an address that has some ether
 513 |     |     function startHoax(address msgSender) internal virtual {
 514 |     |         vm.deal(msgSender, 1 << 128);
 515 |     |         vm.startPrank(msgSender);
 516 |     |     }
 517 |     | 
 518 |     |     function startHoax(address msgSender, uint256 give) internal virtual {
 519 |     |         vm.deal(msgSender, give);
 520 |     |         vm.startPrank(msgSender);
 521 |     |     }
 522 |     | 
 523 |     |     // Start perpetual prank from an address that has some ether
 524 |     |     // tx.origin is set to the origin parameter
 525 |     |     function startHoax(address msgSender, address origin) internal virtual {
 526 |     |         vm.deal(msgSender, 1 << 128);
 527 |     |         vm.startPrank(msgSender, origin);
 528 |     |     }
 529 |     | 
 530 |     |     function startHoax(address msgSender, address origin, uint256 give) internal virtual {
 531 |     |         vm.deal(msgSender, give);
 532 |     |         vm.startPrank(msgSender, origin);
 533 |     |     }
 534 |     | 
 535 |     |     function changePrank(address msgSender) internal virtual {
 536 |     |         vm.stopPrank();
 537 |     |         vm.startPrank(msgSender);
 538 |     |     }
 539 |     | 
 540 |     |     // The same as Vm's `deal`
 541 |     |     // Use the alternative signature for ERC20 tokens
 542 |     |     function deal(address to, uint256 give) internal virtual {
 543 |     |         vm.deal(to, give);
 544 |     |     }
 545 |     | 
 546 |     |     // Set the balance of an account for any ERC20 token
 547 |     |     // Use the alternative signature to update `totalSupply`
 548 |     |     function deal(address token, address to, uint256 give) internal virtual {
 549 |     |         deal(token, to, give, false);
 550 |     |     }
 551 |     | 
 552 |     |     // Set the balance of an account for any ERC1155 token
 553 |     |     // Use the alternative signature to update `totalSupply`
 554 |     |     function dealERC1155(address token, address to, uint256 id, uint256 give) internal virtual {
 555 |     |         dealERC1155(token, to, id, give, false);
 556 |     |     }
 557 |     | 
 558 |     |     function deal(address token, address to, uint256 give, bool adjust) internal virtual {
 559 |     |         // get current balance
 560 |     |         (, bytes memory balData) = token.call(abi.encodeWithSelector(0x70a08231, to));
 561 |     |         uint256 prevBal = abi.decode(balData, (uint256));
 562 |     | 
 563 |     |         // update balance
 564 |     |         stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(give);
 565 |     | 
 566 |     |         // update total supply
 567 |     |         if (adjust) {
 568 |     |             (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0x18160ddd));
 569 |     |             uint256 totSup = abi.decode(totSupData, (uint256));
 570 |     |             if (give < prevBal) {
 571 |     |                 totSup -= (prevBal - give);
 572 |     |             } else {
 573 |     |                 totSup += (give - prevBal);
 574 |     |             }
 575 |     |             stdstore.target(token).sig(0x18160ddd).checked_write(totSup);
 576 |     |         }
 577 |     |     }
 578 |     | 
 579 |     |     function dealERC1155(address token, address to, uint256 id, uint256 give, bool adjust) internal virtual {
 580 |     |         // get current balance
 581 |     |         (, bytes memory balData) = token.call(abi.encodeWithSelector(0x00fdd58e, to, id));
 582 |     |         uint256 prevBal = abi.decode(balData, (uint256));
 583 |     | 
 584 |     |         // update balance
 585 |     |         stdstore.target(token).sig(0x00fdd58e).with_key(to).with_key(id).checked_write(give);
 586 |     | 
 587 |     |         // update total supply
 588 |     |         if (adjust) {
 589 |     |             (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0xbd85b039, id));
 590 |     |             require(
 591 |     |                 totSupData.length != 0,
 592 |     |                 "StdCheats deal(address,address,uint,uint,bool): target contract is not ERC1155Supply."
 593 |     |             );
 594 |     |             uint256 totSup = abi.decode(totSupData, (uint256));
 595 |     |             if (give < prevBal) {
 596 |     |                 totSup -= (prevBal - give);
 597 |     |             } else {
 598 |     |                 totSup += (give - prevBal);
 599 |     |             }
 600 |     |             stdstore.target(token).sig(0xbd85b039).with_key(id).checked_write(totSup);
 601 |     |         }
 602 |     |     }
 603 |     | 
 604 |     |     function dealERC721(address token, address to, uint256 id) internal virtual {
 605 |     |         // check if token id is already minted and the actual owner.
 606 |     |         (bool successMinted, bytes memory ownerData) = token.staticcall(abi.encodeWithSelector(0x6352211e, id));
 607 |     |         require(successMinted, "StdCheats deal(address,address,uint,bool): id not minted.");
 608 |     | 
 609 |     |         // get owner current balance
 610 |     |         (, bytes memory fromBalData) = token.call(abi.encodeWithSelector(0x70a08231, abi.decode(ownerData, (address))));
 611 |     |         uint256 fromPrevBal = abi.decode(fromBalData, (uint256));
 612 |     | 
 613 |     |         // get new user current balance
 614 |     |         (, bytes memory toBalData) = token.call(abi.encodeWithSelector(0x70a08231, to));
 615 |     |         uint256 toPrevBal = abi.decode(toBalData, (uint256));
 616 |     | 
 617 |     |         // update balances
 618 |     |         stdstore.target(token).sig(0x70a08231).with_key(abi.decode(ownerData, (address))).checked_write(--fromPrevBal);
 619 |     |         stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(++toPrevBal);
 620 |     | 
 621 |     |         // update owner
 622 |     |         stdstore.target(token).sig(0x6352211e).with_key(id).checked_write(to);
 623 |     |     }
 624 |     | }
 625 |     | 

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/forge-std/src/StdError.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // Panics work for versions >=0.8.0, but we lowered the pragma to make this compatible with Test
  3 |     | pragma solidity >=0.6.2 <0.9.0;
  4 |     | 
  5 |     | library stdError {
  6 |     |     bytes public constant assertionError = abi.encodeWithSignature("Panic(uint256)", 0x01);
  7 |     |     bytes public constant arithmeticError = abi.encodeWithSignature("Panic(uint256)", 0x11);
  8 |     |     bytes public constant divisionError = abi.encodeWithSignature("Panic(uint256)", 0x12);
  9 |     |     bytes public constant enumConversionError = abi.encodeWithSignature("Panic(uint256)", 0x21);
 10 |     |     bytes public constant encodeStorageError = abi.encodeWithSignature("Panic(uint256)", 0x22);
 11 |     |     bytes public constant popError = abi.encodeWithSignature("Panic(uint256)", 0x31);
 12 |     |     bytes public constant indexOOBError = abi.encodeWithSignature("Panic(uint256)", 0x32);
 13 |     |     bytes public constant memOverflowError = abi.encodeWithSignature("Panic(uint256)", 0x41);
 14 |     |     bytes public constant zeroVarError = abi.encodeWithSignature("Panic(uint256)", 0x51);
 15 |     | }
 16 |     | 

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/forge-std/src/StdInvariant.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | pragma experimental ABIEncoderV2;
  5 |     | 
  6 |     | contract StdInvariant {
  7 |     |     struct FuzzSelector {
  8 |     |         address addr;
  9 |     |         bytes4[] selectors;
 10 |     |     }
 11 |     | 
 12 |     |     address[] private _excludedContracts;
 13 |     |     address[] private _excludedSenders;
 14 |     |     address[] private _targetedContracts;
 15 |     |     address[] private _targetedSenders;
 16 |     | 
 17 |     |     string[] private _excludedArtifacts;
 18 |     |     string[] private _targetedArtifacts;
 19 |     | 
 20 |     |     FuzzSelector[] private _targetedArtifactSelectors;
 21 |     |     FuzzSelector[] private _targetedSelectors;
 22 |     | 
 23 |     |     // Functions for users:
 24 |     |     // These are intended to be called in tests.
 25 |     | 
 26 |     |     function excludeContract(address newExcludedContract_) internal {
 27 |     |         _excludedContracts.push(newExcludedContract_);
 28 |     |     }
 29 |     | 
 30 |     |     function excludeSender(address newExcludedSender_) internal {
 31 |     |         _excludedSenders.push(newExcludedSender_);
 32 |     |     }
 33 |     | 
 34 |     |     function excludeArtifact(string memory newExcludedArtifact_) internal {
 35 |     |         _excludedArtifacts.push(newExcludedArtifact_);
 36 |     |     }
 37 |     | 
 38 |     |     function targetArtifact(string memory newTargetedArtifact_) internal {
 39 |     |         _targetedArtifacts.push(newTargetedArtifact_);
 40 |     |     }
 41 |     | 
 42 |     |     function targetArtifactSelector(FuzzSelector memory newTargetedArtifactSelector_) internal {
 43 |     |         _targetedArtifactSelectors.push(newTargetedArtifactSelector_);
 44 |     |     }
 45 |     | 
 46 |     |     function targetContract(address newTargetedContract_) internal {
 47 |     |         _targetedContracts.push(newTargetedContract_);
 48 |     |     }
 49 |     | 
 50 |     |     function targetSelector(FuzzSelector memory newTargetedSelector_) internal {
 51 |     |         _targetedSelectors.push(newTargetedSelector_);
 52 |     |     }
 53 |     | 
 54 |     |     function targetSender(address newTargetedSender_) internal {
 55 |     |         _targetedSenders.push(newTargetedSender_);
 56 |     |     }
 57 |     | 
 58 |     |     // Functions for forge:
 59 |     |     // These are called by forge to run invariant tests and don't need to be called in tests.
 60 |     | 
 61 |     |     function excludeArtifacts() public view returns (string[] memory excludedArtifacts_) {
 62 |     |         excludedArtifacts_ = _excludedArtifacts;
 63 |     |     }
 64 |     | 
 65 |     |     function excludeContracts() public view returns (address[] memory excludedContracts_) {
 66 |     |         excludedContracts_ = _excludedContracts;
 67 |     |     }
 68 |     | 
 69 |     |     function excludeSenders() public view returns (address[] memory excludedSenders_) {
 70 |     |         excludedSenders_ = _excludedSenders;
 71 |     |     }
 72 |     | 
 73 |     |     function targetArtifacts() public view returns (string[] memory targetedArtifacts_) {
 74 |     |         targetedArtifacts_ = _targetedArtifacts;
 75 |     |     }
 76 |     | 
 77 |     |     function targetArtifactSelectors() public view returns (FuzzSelector[] memory targetedArtifactSelectors_) {
 78 |     |         targetedArtifactSelectors_ = _targetedArtifactSelectors;
 79 |     |     }
 80 |     | 
 81 |     |     function targetContracts() public view returns (address[] memory targetedContracts_) {
 82 |     |         targetedContracts_ = _targetedContracts;
 83 |     |     }
 84 |     | 
 85 |     |     function targetSelectors() public view returns (FuzzSelector[] memory targetedSelectors_) {
 86 |     |         targetedSelectors_ = _targetedSelectors;
 87 |     |     }
 88 |     | 
 89 |     |     function targetSenders() public view returns (address[] memory targetedSenders_) {
 90 |     |         targetedSenders_ = _targetedSenders;
 91 |     |     }
 92 |     | }
 93 |     | 

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/forge-std/src/StdJson.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.0 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | import {VmSafe} from "./Vm.sol";
   7 |     | 
   8 |     | // Helpers for parsing and writing JSON files
   9 |     | // To parse:
  10 |     | // ```
  11 |     | // using stdJson for string;
  12 |     | // string memory json = vm.readFile("some_peth");
  13 |     | // json.parseUint("<json_path>");
  14 |     | // ```
  15 |     | // To write:
  16 |     | // ```
  17 |     | // using stdJson for string;
  18 |     | // string memory json = "deploymentArtifact";
  19 |     | // Contract contract = new Contract();
  20 |     | // json.serialize("contractAddress", address(contract));
  21 |     | // json = json.serialize("deploymentTimes", uint(1));
  22 |     | // // store the stringified JSON to the 'json' variable we have been using as a key
  23 |     | // // as we won't need it any longer
  24 |     | // string memory json2 = "finalArtifact";
  25 |     | // string memory final = json2.serialize("depArtifact", json);
  26 |     | // final.write("<some_path>");
  27 |     | // ```
  28 |     | 
  29 |     | library stdJson {
  30 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
  31 |     | 
  32 |     |     function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {
  33 |     |         return vm.parseJson(json, key);
  34 |     |     }
  35 |     | 
  36 |     |     function readUint(string memory json, string memory key) internal returns (uint256) {
  37 |     |         return vm.parseJsonUint(json, key);
  38 |     |     }
  39 |     | 
  40 |     |     function readUintArray(string memory json, string memory key) internal returns (uint256[] memory) {
  41 |     |         return vm.parseJsonUintArray(json, key);
  42 |     |     }
  43 |     | 
  44 |     |     function readInt(string memory json, string memory key) internal returns (int256) {
  45 |     |         return vm.parseJsonInt(json, key);
  46 |     |     }
  47 |     | 
  48 |     |     function readIntArray(string memory json, string memory key) internal returns (int256[] memory) {
  49 |     |         return vm.parseJsonIntArray(json, key);
  50 |     |     }
  51 |     | 
  52 |     |     function readBytes32(string memory json, string memory key) internal returns (bytes32) {
  53 |     |         return vm.parseJsonBytes32(json, key);
  54 |     |     }
  55 |     | 
  56 |     |     function readBytes32Array(string memory json, string memory key) internal returns (bytes32[] memory) {
  57 |     |         return vm.parseJsonBytes32Array(json, key);
  58 |     |     }
  59 |     | 
  60 |     |     function readString(string memory json, string memory key) internal returns (string memory) {
  61 |     |         return vm.parseJsonString(json, key);
  62 |     |     }
  63 |     | 
  64 |     |     function readStringArray(string memory json, string memory key) internal returns (string[] memory) {
  65 |     |         return vm.parseJsonStringArray(json, key);
  66 |     |     }
  67 |     | 
  68 |     |     function readAddress(string memory json, string memory key) internal returns (address) {
  69 |     |         return vm.parseJsonAddress(json, key);
  70 |     |     }
  71 |     | 
  72 |     |     function readAddressArray(string memory json, string memory key) internal returns (address[] memory) {
  73 |     |         return vm.parseJsonAddressArray(json, key);
  74 |     |     }
  75 |     | 
  76 |     |     function readBool(string memory json, string memory key) internal returns (bool) {
  77 |     |         return vm.parseJsonBool(json, key);
  78 |     |     }
  79 |     | 
  80 |     |     function readBoolArray(string memory json, string memory key) internal returns (bool[] memory) {
  81 |     |         return vm.parseJsonBoolArray(json, key);
  82 |     |     }
  83 |     | 
  84 |     |     function readBytes(string memory json, string memory key) internal returns (bytes memory) {
  85 |     |         return vm.parseJsonBytes(json, key);
  86 |     |     }
  87 |     | 
  88 |     |     function readBytesArray(string memory json, string memory key) internal returns (bytes[] memory) {
  89 |     |         return vm.parseJsonBytesArray(json, key);
  90 |     |     }
  91 |     | 
  92 |     |     function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {
  93 |     |         return vm.serializeBool(jsonKey, key, value);
  94 |     |     }
  95 |     | 
  96 |     |     function serialize(string memory jsonKey, string memory key, bool[] memory value)
  97 |     |         internal
  98 |     |         returns (string memory)
  99 |     |     {
 100 |     |         return vm.serializeBool(jsonKey, key, value);
 101 |     |     }
 102 |     | 
 103 |     |     function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {
 104 |     |         return vm.serializeUint(jsonKey, key, value);
 105 |     |     }
 106 |     | 
 107 |     |     function serialize(string memory jsonKey, string memory key, uint256[] memory value)
 108 |     |         internal
 109 |     |         returns (string memory)
 110 |     |     {
 111 |     |         return vm.serializeUint(jsonKey, key, value);
 112 |     |     }
 113 |     | 
 114 |     |     function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {
 115 |     |         return vm.serializeInt(jsonKey, key, value);
 116 |     |     }
 117 |     | 
 118 |     |     function serialize(string memory jsonKey, string memory key, int256[] memory value)
 119 |     |         internal
 120 |     |         returns (string memory)
 121 |     |     {
 122 |     |         return vm.serializeInt(jsonKey, key, value);
 123 |     |     }
 124 |     | 
 125 |     |     function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {
 126 |     |         return vm.serializeAddress(jsonKey, key, value);
 127 |     |     }
 128 |     | 
 129 |     |     function serialize(string memory jsonKey, string memory key, address[] memory value)
 130 |     |         internal
 131 |     |         returns (string memory)
 132 |     |     {
 133 |     |         return vm.serializeAddress(jsonKey, key, value);
 134 |     |     }
 135 |     | 
 136 |     |     function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {
 137 |     |         return vm.serializeBytes32(jsonKey, key, value);
 138 |     |     }
 139 |     | 
 140 |     |     function serialize(string memory jsonKey, string memory key, bytes32[] memory value)
 141 |     |         internal
 142 |     |         returns (string memory)
 143 |     |     {
 144 |     |         return vm.serializeBytes32(jsonKey, key, value);
 145 |     |     }
 146 |     | 
 147 |     |     function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {
 148 |     |         return vm.serializeBytes(jsonKey, key, value);
 149 |     |     }
 150 |     | 
 151 |     |     function serialize(string memory jsonKey, string memory key, bytes[] memory value)
 152 |     |         internal
 153 |     |         returns (string memory)
 154 |     |     {
 155 |     |         return vm.serializeBytes(jsonKey, key, value);
 156 |     |     }
 157 |     | 
 158 |     |     function serialize(string memory jsonKey, string memory key, string memory value)
 159 |     |         internal
 160 |     |         returns (string memory)
 161 |     |     {
 162 |     |         return vm.serializeString(jsonKey, key, value);
 163 |     |     }
 164 |     | 
 165 |     |     function serialize(string memory jsonKey, string memory key, string[] memory value)
 166 |     |         internal
 167 |     |         returns (string memory)
 168 |     |     {
 169 |     |         return vm.serializeString(jsonKey, key, value);
 170 |     |     }
 171 |     | 
 172 |     |     function write(string memory jsonKey, string memory path) internal {
 173 |     |         vm.writeJson(jsonKey, path);
 174 |     |     }
 175 |     | 
 176 |     |     function write(string memory jsonKey, string memory path, string memory valueKey) internal {
 177 |     |         vm.writeJson(jsonKey, path, valueKey);
 178 |     |     }
 179 |     | }
 180 |     | 

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/forge-std/src/StdMath.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | library stdMath {
  5 |     |     int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;
  6 |     | 
  7 |     |     function abs(int256 a) internal pure returns (uint256) {
  8 |     |         // Required or it will fail when `a = type(int256).min`
  9 |     |         if (a == INT256_MIN) {
 10 |     |             return 57896044618658097711785492504343953926634992332820282019728792003956564819968;
 11 |     |         }
 12 |     | 
 13 |     |         return uint256(a > 0 ? a : -a);
 14 |     |     }
 15 |     | 
 16 |     |     function delta(uint256 a, uint256 b) internal pure returns (uint256) {
 17 |     |         return a > b ? a - b : b - a;
 18 |     |     }
 19 |     | 
 20 |     |     function delta(int256 a, int256 b) internal pure returns (uint256) {
 21 |     |         // a and b are of the same sign
 22 |     |         // this works thanks to two's complement, the left-most bit is the sign bit
 23 |     |         if ((a ^ b) > -1) {
 24 |     |             return delta(abs(a), abs(b));
 25 |     |         }
 26 |     | 
 27 |     |         // a and b are of opposite signs
 28 |     |         return abs(a) + abs(b);
 29 |     |     }
 30 |     | 
 31 |     |     function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {
 32 |     |         uint256 absDelta = delta(a, b);
 33 |     | 
 34 |     |         return absDelta * 1e18 / b;
 35 |     |     }
 36 |     | 
 37 |     |     function percentDelta(int256 a, int256 b) internal pure returns (uint256) {
 38 |     |         uint256 absDelta = delta(a, b);
 39 |     |         uint256 absB = abs(b);
 40 |     | 
 41 |     |         return absDelta * 1e18 / absB;
 42 |     |     }
 43 |     | }
 44 |     | 

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/forge-std/src/StdStorage.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | import {Vm} from "./Vm.sol";
   5 |     | 
   6 |     | struct StdStorage {
   7 |     |     mapping(address => mapping(bytes4 => mapping(bytes32 => uint256))) slots;
   8 |     |     mapping(address => mapping(bytes4 => mapping(bytes32 => bool))) finds;
   9 |     |     bytes32[] _keys;
  10 |     |     bytes4 _sig;
  11 |     |     uint256 _depth;
  12 |     |     address _target;
  13 |     |     bytes32 _set;
  14 |     | }
  15 |     | 
  16 |     | library stdStorageSafe {
  17 |     |     event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);
  18 |     |     event WARNING_UninitedSlot(address who, uint256 slot);
  19 |     | 
  20 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
  21 |     | 
  22 |     |     function sigs(string memory sigStr) internal pure returns (bytes4) {
  23 |     |         return bytes4(keccak256(bytes(sigStr)));
  24 |     |     }
  25 |     | 
  26 |     |     /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against
  27 |     |     // slot complexity:
  28 |     |     //  if flat, will be bytes32(uint256(uint));
  29 |     |     //  if map, will be keccak256(abi.encode(key, uint(slot)));
  30 |     |     //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));
  31 |     |     //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);
  32 |     |     function find(StdStorage storage self) internal returns (uint256) {
  33 |     |         address who = self._target;
  34 |     |         bytes4 fsig = self._sig;
  35 |     |         uint256 field_depth = self._depth;
  36 |     |         bytes32[] memory ins = self._keys;
  37 |     | 
  38 |     |         // calldata to test against
  39 |     |         if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {
  40 |     |             return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];
  41 |     |         }
  42 |     |         bytes memory cald = abi.encodePacked(fsig, flatten(ins));
  43 |     |         vm.record();
  44 |     |         bytes32 fdat;
  45 |     |         {
  46 |     |             (, bytes memory rdat) = who.staticcall(cald);
  47 |     |             fdat = bytesToBytes32(rdat, 32 * field_depth);
  48 |     |         }
  49 |     | 
  50 |     |         (bytes32[] memory reads,) = vm.accesses(address(who));
  51 |     |         if (reads.length == 1) {
  52 |     |             bytes32 curr = vm.load(who, reads[0]);
  53 |     |             if (curr == bytes32(0)) {
  54 |     |                 emit WARNING_UninitedSlot(who, uint256(reads[0]));
  55 |     |             }
  56 |     |             if (fdat != curr) {
  57 |     |                 require(
  58 |     |                     false,
  59 |     |                     "stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported."
  60 |     |                 );
  61 |     |             }
  62 |     |             emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));
  63 |     |             self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);
  64 |     |             self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;
  65 |     |         } else if (reads.length > 1) {
  66 |     |             for (uint256 i = 0; i < reads.length; i++) {
  67 |     |                 bytes32 prev = vm.load(who, reads[i]);
  68 |     |                 if (prev == bytes32(0)) {
  69 |     |                     emit WARNING_UninitedSlot(who, uint256(reads[i]));
  70 |     |                 }
  71 |     |                 // store
  72 |     |                 vm.store(who, reads[i], bytes32(hex"1337"));
  73 |     |                 bool success;
  74 |     |                 bytes memory rdat;
  75 |     |                 {
  76 |     |                     (success, rdat) = who.staticcall(cald);
  77 |     |                     fdat = bytesToBytes32(rdat, 32 * field_depth);
  78 |     |                 }
  79 |     | 
  80 |     |                 if (success && fdat == bytes32(hex"1337")) {
  81 |     |                     // we found which of the slots is the actual one
  82 |     |                     emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));
  83 |     |                     self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);
  84 |     |                     self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;
  85 |     |                     vm.store(who, reads[i], prev);
  86 |     |                     break;
  87 |     |                 }
  88 |     |                 vm.store(who, reads[i], prev);
  89 |     |             }
  90 |     |         } else {
  91 |     |             revert("stdStorage find(StdStorage): No storage use detected for target.");
  92 |     |         }
  93 |     | 
  94 |     |         require(
  95 |     |             self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))],
  96 |     |             "stdStorage find(StdStorage): Slot(s) not found."
  97 |     |         );
  98 |     | 
  99 |     |         delete self._target;
 100 |     |         delete self._sig;
 101 |     |         delete self._keys;
 102 |     |         delete self._depth;
 103 |     | 
 104 |     |         return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];
 105 |     |     }
 106 |     | 
 107 |     |     function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {
 108 |     |         self._target = _target;
 109 |     |         return self;
 110 |     |     }
 111 |     | 
 112 |     |     function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {
 113 |     |         self._sig = _sig;
 114 |     |         return self;
 115 |     |     }
 116 |     | 
 117 |     |     function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {
 118 |     |         self._sig = sigs(_sig);
 119 |     |         return self;
 120 |     |     }
 121 |     | 
 122 |     |     function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {
 123 |     |         self._keys.push(bytes32(uint256(uint160(who))));
 124 |     |         return self;
 125 |     |     }
 126 |     | 
 127 |     |     function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {
 128 |     |         self._keys.push(bytes32(amt));
 129 |     |         return self;
 130 |     |     }
 131 |     | 
 132 |     |     function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {
 133 |     |         self._keys.push(key);
 134 |     |         return self;
 135 |     |     }
 136 |     | 
 137 |     |     function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {
 138 |     |         self._depth = _depth;
 139 |     |         return self;
 140 |     |     }
 141 |     | 
 142 |     |     function read(StdStorage storage self) private returns (bytes memory) {
 143 |     |         address t = self._target;
 144 |     |         uint256 s = find(self);
 145 |     |         return abi.encode(vm.load(t, bytes32(s)));
 146 |     |     }
 147 |     | 
 148 |     |     function read_bytes32(StdStorage storage self) internal returns (bytes32) {
 149 |     |         return abi.decode(read(self), (bytes32));
 150 |     |     }
 151 |     | 
 152 |     |     function read_bool(StdStorage storage self) internal returns (bool) {
 153 |     |         int256 v = read_int(self);
 154 |     |         if (v == 0) return false;
 155 |     |         if (v == 1) return true;
 156 |     |         revert("stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.");
 157 |     |     }
 158 |     | 
 159 |     |     function read_address(StdStorage storage self) internal returns (address) {
 160 |     |         return abi.decode(read(self), (address));
 161 |     |     }
 162 |     | 
 163 |     |     function read_uint(StdStorage storage self) internal returns (uint256) {
 164 |     |         return abi.decode(read(self), (uint256));
 165 |     |     }
 166 |     | 
 167 |     |     function read_int(StdStorage storage self) internal returns (int256) {
 168 |     |         return abi.decode(read(self), (int256));
 169 |     |     }
 170 |     | 
 171 |     |     function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {
 172 |     |         bytes32 out;
 173 |     | 
 174 |     |         uint256 max = b.length > 32 ? 32 : b.length;
 175 |     |         for (uint256 i = 0; i < max; i++) {
 176 |     |             out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);
 177 |     |         }
 178 |     |         return out;
 179 |     |     }
 180 |     | 
 181 |     |     function flatten(bytes32[] memory b) private pure returns (bytes memory) {
 182 |     |         bytes memory result = new bytes(b.length * 32);
 183 |     |         for (uint256 i = 0; i < b.length; i++) {
 184 |     |             bytes32 k = b[i];
 185 |     |             /// @solidity memory-safe-assembly
 186 |     |             assembly {
 187 |     |                 mstore(add(result, add(32, mul(32, i))), k)
 188 |     |             }
 189 |     |         }
 190 |     | 
 191 |     |         return result;
 192 |     |     }
 193 |     | }
 194 |     | 
 195 |     | library stdStorage {
 196 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
 197 |     | 
 198 |     |     function sigs(string memory sigStr) internal pure returns (bytes4) {
 199 |     |         return stdStorageSafe.sigs(sigStr);
 200 |     |     }
 201 |     | 
 202 |     |     function find(StdStorage storage self) internal returns (uint256) {
 203 |     |         return stdStorageSafe.find(self);
 204 |     |     }
 205 |     | 
 206 |     |     function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {
 207 |     |         return stdStorageSafe.target(self, _target);
 208 |     |     }
 209 |     | 
 210 |     |     function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {
 211 |     |         return stdStorageSafe.sig(self, _sig);
 212 |     |     }
 213 |     | 
 214 |     |     function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {
 215 |     |         return stdStorageSafe.sig(self, _sig);
 216 |     |     }
 217 |     | 
 218 |     |     function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {
 219 |     |         return stdStorageSafe.with_key(self, who);
 220 |     |     }
 221 |     | 
 222 |     |     function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {
 223 |     |         return stdStorageSafe.with_key(self, amt);
 224 |     |     }
 225 |     | 
 226 |     |     function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {
 227 |     |         return stdStorageSafe.with_key(self, key);
 228 |     |     }
 229 |     | 
 230 |     |     function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {
 231 |     |         return stdStorageSafe.depth(self, _depth);
 232 |     |     }
 233 |     | 
 234 |     |     function checked_write(StdStorage storage self, address who) internal {
 235 |     |         checked_write(self, bytes32(uint256(uint160(who))));
 236 |     |     }
 237 |     | 
 238 |     |     function checked_write(StdStorage storage self, uint256 amt) internal {
 239 |     |         checked_write(self, bytes32(amt));
 240 |     |     }
 241 |     | 
 242 |     |     function checked_write(StdStorage storage self, bool write) internal {
 243 |     |         bytes32 t;
 244 |     |         /// @solidity memory-safe-assembly
 245 |     |         assembly {
 246 |     |             t := write
 247 |     |         }
 248 |     |         checked_write(self, t);
 249 |     |     }
 250 |     | 
 251 |     |     function checked_write(StdStorage storage self, bytes32 set) internal {
 252 |     |         address who = self._target;
 253 |     |         bytes4 fsig = self._sig;
 254 |     |         uint256 field_depth = self._depth;
 255 |     |         bytes32[] memory ins = self._keys;
 256 |     | 
 257 |     |         bytes memory cald = abi.encodePacked(fsig, flatten(ins));
 258 |     |         if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {
 259 |     |             find(self);
 260 |     |         }
 261 |     |         bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);
 262 |     | 
 263 |     |         bytes32 fdat;
 264 |     |         {
 265 |     |             (, bytes memory rdat) = who.staticcall(cald);
 266 |     |             fdat = bytesToBytes32(rdat, 32 * field_depth);
 267 |     |         }
 268 |     |         bytes32 curr = vm.load(who, slot);
 269 |     | 
 270 |     |         if (fdat != curr) {
 271 |     |             require(
 272 |     |                 false,
 273 |     |                 "stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported."
 274 |     |             );
 275 |     |         }
 276 |     |         vm.store(who, slot, set);
 277 |     |         delete self._target;
 278 |     |         delete self._sig;
 279 |     |         delete self._keys;
 280 |     |         delete self._depth;
 281 |     |     }
 282 |     | 
 283 |     |     function read_bytes32(StdStorage storage self) internal returns (bytes32) {
 284 |     |         return stdStorageSafe.read_bytes32(self);
 285 |     |     }
 286 |     | 
 287 |     |     function read_bool(StdStorage storage self) internal returns (bool) {
 288 |     |         return stdStorageSafe.read_bool(self);
 289 |     |     }
 290 |     | 
 291 |     |     function read_address(StdStorage storage self) internal returns (address) {
 292 |     |         return stdStorageSafe.read_address(self);
 293 |     |     }
 294 |     | 
 295 |     |     function read_uint(StdStorage storage self) internal returns (uint256) {
 296 |     |         return stdStorageSafe.read_uint(self);
 297 |     |     }
 298 |     | 
 299 |     |     function read_int(StdStorage storage self) internal returns (int256) {
 300 |     |         return stdStorageSafe.read_int(self);
 301 |     |     }
 302 |     | 
 303 |     |     // Private function so needs to be copied over
 304 |     |     function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {
 305 |     |         bytes32 out;
 306 |     | 
 307 |     |         uint256 max = b.length > 32 ? 32 : b.length;
 308 |     |         for (uint256 i = 0; i < max; i++) {
 309 |     |             out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);
 310 |     |         }
 311 |     |         return out;
 312 |     |     }
 313 |     | 
 314 |     |     // Private function so needs to be copied over
 315 |     |     function flatten(bytes32[] memory b) private pure returns (bytes memory) {
 316 |     |         bytes memory result = new bytes(b.length * 32);
 317 |     |         for (uint256 i = 0; i < b.length; i++) {
 318 |     |             bytes32 k = b[i];
 319 |     |             /// @solidity memory-safe-assembly
 320 |     |             assembly {
 321 |     |                 mstore(add(result, add(32, mul(32, i))), k)
 322 |     |             }
 323 |     |         }
 324 |     | 
 325 |     |         return result;
 326 |     |     }
 327 |     | }
 328 |     | 

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/forge-std/src/StdStyle.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.4.22 <0.9.0;
   3 |     | 
   4 |     | import {Vm} from "./Vm.sol";
   5 |     | 
   6 |     | library StdStyle {
   7 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
   8 |     | 
   9 |     |     string constant RED = "\u001b[91m";
  10 |     |     string constant GREEN = "\u001b[92m";
  11 |     |     string constant YELLOW = "\u001b[93m";
  12 |     |     string constant BLUE = "\u001b[94m";
  13 |     |     string constant MAGENTA = "\u001b[95m";
  14 |     |     string constant CYAN = "\u001b[96m";
  15 |     |     string constant BOLD = "\u001b[1m";
  16 |     |     string constant DIM = "\u001b[2m";
  17 |     |     string constant ITALIC = "\u001b[3m";
  18 |     |     string constant UNDERLINE = "\u001b[4m";
  19 |     |     string constant INVERSE = "\u001b[7m";
  20 |     |     string constant RESET = "\u001b[0m";
  21 |     | 
  22 |     |     function styleConcat(string memory style, string memory self) private pure returns (string memory) {
  23 |     |         return string(abi.encodePacked(style, self, RESET));
  24 |     |     }
  25 |     | 
  26 |     |     function red(string memory self) internal pure returns (string memory) {
  27 |     |         return styleConcat(RED, self);
  28 |     |     }
  29 |     | 
  30 |     |     function red(uint256 self) internal pure returns (string memory) {
  31 |     |         return red(vm.toString(self));
  32 |     |     }
  33 |     | 
  34 |     |     function red(int256 self) internal pure returns (string memory) {
  35 |     |         return red(vm.toString(self));
  36 |     |     }
  37 |     | 
  38 |     |     function red(address self) internal pure returns (string memory) {
  39 |     |         return red(vm.toString(self));
  40 |     |     }
  41 |     | 
  42 |     |     function red(bool self) internal pure returns (string memory) {
  43 |     |         return red(vm.toString(self));
  44 |     |     }
  45 |     | 
  46 |     |     function redBytes(bytes memory self) internal pure returns (string memory) {
  47 |     |         return red(vm.toString(self));
  48 |     |     }
  49 |     | 
  50 |     |     function redBytes32(bytes32 self) internal pure returns (string memory) {
  51 |     |         return red(vm.toString(self));
  52 |     |     }
  53 |     | 
  54 |     |     function green(string memory self) internal pure returns (string memory) {
  55 |     |         return styleConcat(GREEN, self);
  56 |     |     }
  57 |     | 
  58 |     |     function green(uint256 self) internal pure returns (string memory) {
  59 |     |         return green(vm.toString(self));
  60 |     |     }
  61 |     | 
  62 |     |     function green(int256 self) internal pure returns (string memory) {
  63 |     |         return green(vm.toString(self));
  64 |     |     }
  65 |     | 
  66 |     |     function green(address self) internal pure returns (string memory) {
  67 |     |         return green(vm.toString(self));
  68 |     |     }
  69 |     | 
  70 |     |     function green(bool self) internal pure returns (string memory) {
  71 |     |         return green(vm.toString(self));
  72 |     |     }
  73 |     | 
  74 |     |     function greenBytes(bytes memory self) internal pure returns (string memory) {
  75 |     |         return green(vm.toString(self));
  76 |     |     }
  77 |     | 
  78 |     |     function greenBytes32(bytes32 self) internal pure returns (string memory) {
  79 |     |         return green(vm.toString(self));
  80 |     |     }
  81 |     | 
  82 |     |     function yellow(string memory self) internal pure returns (string memory) {
  83 |     |         return styleConcat(YELLOW, self);
  84 |     |     }
  85 |     | 
  86 |     |     function yellow(uint256 self) internal pure returns (string memory) {
  87 |     |         return yellow(vm.toString(self));
  88 |     |     }
  89 |     | 
  90 |     |     function yellow(int256 self) internal pure returns (string memory) {
  91 |     |         return yellow(vm.toString(self));
  92 |     |     }
  93 |     | 
  94 |     |     function yellow(address self) internal pure returns (string memory) {
  95 |     |         return yellow(vm.toString(self));
  96 |     |     }
  97 |     | 
  98 |     |     function yellow(bool self) internal pure returns (string memory) {
  99 |     |         return yellow(vm.toString(self));
 100 |     |     }
 101 |     | 
 102 |     |     function yellowBytes(bytes memory self) internal pure returns (string memory) {
 103 |     |         return yellow(vm.toString(self));
 104 |     |     }
 105 |     | 
 106 |     |     function yellowBytes32(bytes32 self) internal pure returns (string memory) {
 107 |     |         return yellow(vm.toString(self));
 108 |     |     }
 109 |     | 
 110 |     |     function blue(string memory self) internal pure returns (string memory) {
 111 |     |         return styleConcat(BLUE, self);
 112 |     |     }
 113 |     | 
 114 |     |     function blue(uint256 self) internal pure returns (string memory) {
 115 |     |         return blue(vm.toString(self));
 116 |     |     }
 117 |     | 
 118 |     |     function blue(int256 self) internal pure returns (string memory) {
 119 |     |         return blue(vm.toString(self));
 120 |     |     }
 121 |     | 
 122 |     |     function blue(address self) internal pure returns (string memory) {
 123 |     |         return blue(vm.toString(self));
 124 |     |     }
 125 |     | 
 126 |     |     function blue(bool self) internal pure returns (string memory) {
 127 |     |         return blue(vm.toString(self));
 128 |     |     }
 129 |     | 
 130 |     |     function blueBytes(bytes memory self) internal pure returns (string memory) {
 131 |     |         return blue(vm.toString(self));
 132 |     |     }
 133 |     | 
 134 |     |     function blueBytes32(bytes32 self) internal pure returns (string memory) {
 135 |     |         return blue(vm.toString(self));
 136 |     |     }
 137 |     | 
 138 |     |     function magenta(string memory self) internal pure returns (string memory) {
 139 |     |         return styleConcat(MAGENTA, self);
 140 |     |     }
 141 |     | 
 142 |     |     function magenta(uint256 self) internal pure returns (string memory) {
 143 |     |         return magenta(vm.toString(self));
 144 |     |     }
 145 |     | 
 146 |     |     function magenta(int256 self) internal pure returns (string memory) {
 147 |     |         return magenta(vm.toString(self));
 148 |     |     }
 149 |     | 
 150 |     |     function magenta(address self) internal pure returns (string memory) {
 151 |     |         return magenta(vm.toString(self));
 152 |     |     }
 153 |     | 
 154 |     |     function magenta(bool self) internal pure returns (string memory) {
 155 |     |         return magenta(vm.toString(self));
 156 |     |     }
 157 |     | 
 158 |     |     function magentaBytes(bytes memory self) internal pure returns (string memory) {
 159 |     |         return magenta(vm.toString(self));
 160 |     |     }
 161 |     | 
 162 |     |     function magentaBytes32(bytes32 self) internal pure returns (string memory) {
 163 |     |         return magenta(vm.toString(self));
 164 |     |     }
 165 |     | 
 166 |     |     function cyan(string memory self) internal pure returns (string memory) {
 167 |     |         return styleConcat(CYAN, self);
 168 |     |     }
 169 |     | 
 170 |     |     function cyan(uint256 self) internal pure returns (string memory) {
 171 |     |         return cyan(vm.toString(self));
 172 |     |     }
 173 |     | 
 174 |     |     function cyan(int256 self) internal pure returns (string memory) {
 175 |     |         return cyan(vm.toString(self));
 176 |     |     }
 177 |     | 
 178 |     |     function cyan(address self) internal pure returns (string memory) {
 179 |     |         return cyan(vm.toString(self));
 180 |     |     }
 181 |     | 
 182 |     |     function cyan(bool self) internal pure returns (string memory) {
 183 |     |         return cyan(vm.toString(self));
 184 |     |     }
 185 |     | 
 186 |     |     function cyanBytes(bytes memory self) internal pure returns (string memory) {
 187 |     |         return cyan(vm.toString(self));
 188 |     |     }
 189 |     | 
 190 |     |     function cyanBytes32(bytes32 self) internal pure returns (string memory) {
 191 |     |         return cyan(vm.toString(self));
 192 |     |     }
 193 |     | 
 194 |     |     function bold(string memory self) internal pure returns (string memory) {
 195 |     |         return styleConcat(BOLD, self);
 196 |     |     }
 197 |     | 
 198 |     |     function bold(uint256 self) internal pure returns (string memory) {
 199 |     |         return bold(vm.toString(self));
 200 |     |     }
 201 |     | 
 202 |     |     function bold(int256 self) internal pure returns (string memory) {
 203 |     |         return bold(vm.toString(self));
 204 |     |     }
 205 |     | 
 206 |     |     function bold(address self) internal pure returns (string memory) {
 207 |     |         return bold(vm.toString(self));
 208 |     |     }
 209 |     | 
 210 |     |     function bold(bool self) internal pure returns (string memory) {
 211 |     |         return bold(vm.toString(self));
 212 |     |     }
 213 |     | 
 214 |     |     function boldBytes(bytes memory self) internal pure returns (string memory) {
 215 |     |         return bold(vm.toString(self));
 216 |     |     }
 217 |     | 
 218 |     |     function boldBytes32(bytes32 self) internal pure returns (string memory) {
 219 |     |         return bold(vm.toString(self));
 220 |     |     }
 221 |     | 
 222 |     |     function dim(string memory self) internal pure returns (string memory) {
 223 |     |         return styleConcat(DIM, self);
 224 |     |     }
 225 |     | 
 226 |     |     function dim(uint256 self) internal pure returns (string memory) {
 227 |     |         return dim(vm.toString(self));
 228 |     |     }
 229 |     | 
 230 |     |     function dim(int256 self) internal pure returns (string memory) {
 231 |     |         return dim(vm.toString(self));
 232 |     |     }
 233 |     | 
 234 |     |     function dim(address self) internal pure returns (string memory) {
 235 |     |         return dim(vm.toString(self));
 236 |     |     }
 237 |     | 
 238 |     |     function dim(bool self) internal pure returns (string memory) {
 239 |     |         return dim(vm.toString(self));
 240 |     |     }
 241 |     | 
 242 |     |     function dimBytes(bytes memory self) internal pure returns (string memory) {
 243 |     |         return dim(vm.toString(self));
 244 |     |     }
 245 |     | 
 246 |     |     function dimBytes32(bytes32 self) internal pure returns (string memory) {
 247 |     |         return dim(vm.toString(self));
 248 |     |     }
 249 |     | 
 250 |     |     function italic(string memory self) internal pure returns (string memory) {
 251 |     |         return styleConcat(ITALIC, self);
 252 |     |     }
 253 |     | 
 254 |     |     function italic(uint256 self) internal pure returns (string memory) {
 255 |     |         return italic(vm.toString(self));
 256 |     |     }
 257 |     | 
 258 |     |     function italic(int256 self) internal pure returns (string memory) {
 259 |     |         return italic(vm.toString(self));
 260 |     |     }
 261 |     | 
 262 |     |     function italic(address self) internal pure returns (string memory) {
 263 |     |         return italic(vm.toString(self));
 264 |     |     }
 265 |     | 
 266 |     |     function italic(bool self) internal pure returns (string memory) {
 267 |     |         return italic(vm.toString(self));
 268 |     |     }
 269 |     | 
 270 |     |     function italicBytes(bytes memory self) internal pure returns (string memory) {
 271 |     |         return italic(vm.toString(self));
 272 |     |     }
 273 |     | 
 274 |     |     function italicBytes32(bytes32 self) internal pure returns (string memory) {
 275 |     |         return italic(vm.toString(self));
 276 |     |     }
 277 |     | 
 278 |     |     function underline(string memory self) internal pure returns (string memory) {
 279 |     |         return styleConcat(UNDERLINE, self);
 280 |     |     }
 281 |     | 
 282 |     |     function underline(uint256 self) internal pure returns (string memory) {
 283 |     |         return underline(vm.toString(self));
 284 |     |     }
 285 |     | 
 286 |     |     function underline(int256 self) internal pure returns (string memory) {
 287 |     |         return underline(vm.toString(self));
 288 |     |     }
 289 |     | 
 290 |     |     function underline(address self) internal pure returns (string memory) {
 291 |     |         return underline(vm.toString(self));
 292 |     |     }
 293 |     | 
 294 |     |     function underline(bool self) internal pure returns (string memory) {
 295 |     |         return underline(vm.toString(self));
 296 |     |     }
 297 |     | 
 298 |     |     function underlineBytes(bytes memory self) internal pure returns (string memory) {
 299 |     |         return underline(vm.toString(self));
 300 |     |     }
 301 |     | 
 302 |     |     function underlineBytes32(bytes32 self) internal pure returns (string memory) {
 303 |     |         return underline(vm.toString(self));
 304 |     |     }
 305 |     | 
 306 |     |     function inverse(string memory self) internal pure returns (string memory) {
 307 |     |         return styleConcat(INVERSE, self);
 308 |     |     }
 309 |     | 
 310 |     |     function inverse(uint256 self) internal pure returns (string memory) {
 311 |     |         return inverse(vm.toString(self));
 312 |     |     }
 313 |     | 
 314 |     |     function inverse(int256 self) internal pure returns (string memory) {
 315 |     |         return inverse(vm.toString(self));
 316 |     |     }
 317 |     | 
 318 |     |     function inverse(address self) internal pure returns (string memory) {
 319 |     |         return inverse(vm.toString(self));
 320 |     |     }
 321 |     | 
 322 |     |     function inverse(bool self) internal pure returns (string memory) {
 323 |     |         return inverse(vm.toString(self));
 324 |     |     }
 325 |     | 
 326 |     |     function inverseBytes(bytes memory self) internal pure returns (string memory) {
 327 |     |         return inverse(vm.toString(self));
 328 |     |     }
 329 |     | 
 330 |     |     function inverseBytes32(bytes32 self) internal pure returns (string memory) {
 331 |     |         return inverse(vm.toString(self));
 332 |     |     }
 333 |     | }
 334 |     | 

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/forge-std/src/StdUtils.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | import {IMulticall3} from "./interfaces/IMulticall3.sol";
   7 |     | // TODO Remove import.
   8 |     | import {VmSafe} from "./Vm.sol";
   9 |     | 
  10 |     | abstract contract StdUtils {
  11 |     |     /*//////////////////////////////////////////////////////////////////////////
  12 |     |                                      CONSTANTS
  13 |     |     //////////////////////////////////////////////////////////////////////////*/
  14 |     | 
  15 |     |     IMulticall3 private constant multicall = IMulticall3(0xcA11bde05977b3631167028862bE2a173976CA11);
  16 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
  17 |     |     address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;
  18 |     |     uint256 private constant INT256_MIN_ABS =
  19 |     |         57896044618658097711785492504343953926634992332820282019728792003956564819968;
  20 |     |     uint256 private constant UINT256_MAX =
  21 |     |         115792089237316195423570985008687907853269984665640564039457584007913129639935;
  22 |     | 
  23 |     |     // Used by default when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.
  24 |     |     address private constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;
  25 |     | 
  26 |     |     /*//////////////////////////////////////////////////////////////////////////
  27 |     |                                  INTERNAL FUNCTIONS
  28 |     |     //////////////////////////////////////////////////////////////////////////*/
  29 |     | 
  30 |     |     function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {
  31 |     |         require(min <= max, "StdUtils bound(uint256,uint256,uint256): Max is less than min.");
  32 |     |         // If x is between min and max, return x directly. This is to ensure that dictionary values
  33 |     |         // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188
  34 |     |         if (x >= min && x <= max) return x;
  35 |     | 
  36 |     |         uint256 size = max - min + 1;
  37 |     | 
  38 |     |         // If the value is 0, 1, 2, 3, warp that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.
  39 |     |         // This helps ensure coverage of the min/max values.
  40 |     |         if (x <= 3 && size > x) return min + x;
  41 |     |         if (x >= UINT256_MAX - 3 && size > UINT256_MAX - x) return max - (UINT256_MAX - x);
  42 |     | 
  43 |     |         // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.
  44 |     |         if (x > max) {
  45 |     |             uint256 diff = x - max;
  46 |     |             uint256 rem = diff % size;
  47 |     |             if (rem == 0) return max;
  48 |     |             result = min + rem - 1;
  49 |     |         } else if (x < min) {
  50 |     |             uint256 diff = min - x;
  51 |     |             uint256 rem = diff % size;
  52 |     |             if (rem == 0) return min;
  53 |     |             result = max - rem + 1;
  54 |     |         }
  55 |     |     }
  56 |     | 
  57 |     |     function bound(uint256 x, uint256 min, uint256 max) internal view virtual returns (uint256 result) {
  58 |     |         result = _bound(x, min, max);
  59 |     |         console2_log("Bound Result", result);
  60 |     |     }
  61 |     | 
  62 |     |     function bound(int256 x, int256 min, int256 max) internal view virtual returns (int256 result) {
  63 |     |         require(min <= max, "StdUtils bound(int256,int256,int256): Max is less than min.");
  64 |     | 
  65 |     |         // Shifting all int256 values to uint256 to use _bound function. The range of two types are:
  66 |     |         // int256 : -(2**255) ~ (2**255 - 1)
  67 |     |         // uint256:     0     ~ (2**256 - 1)
  68 |     |         // So, add 2**255, INT256_MIN_ABS to the integer values.
  69 |     |         //
  70 |     |         // If the given integer value is -2**255, we cannot use `-uint256(-x)` because of the overflow.
  71 |     |         // So, use `~uint256(x) + 1` instead.
  72 |     |         uint256 _x = x < 0 ? (INT256_MIN_ABS - ~uint256(x) - 1) : (uint256(x) + INT256_MIN_ABS);
  73 |     |         uint256 _min = min < 0 ? (INT256_MIN_ABS - ~uint256(min) - 1) : (uint256(min) + INT256_MIN_ABS);
  74 |     |         uint256 _max = max < 0 ? (INT256_MIN_ABS - ~uint256(max) - 1) : (uint256(max) + INT256_MIN_ABS);
  75 |     | 
  76 |     |         uint256 y = _bound(_x, _min, _max);
  77 |     | 
  78 |     |         // To move it back to int256 value, subtract INT256_MIN_ABS at here.
  79 |     |         result = y < INT256_MIN_ABS ? int256(~(INT256_MIN_ABS - y) + 1) : int256(y - INT256_MIN_ABS);
  80 |     |         console2_log("Bound result", vm.toString(result));
  81 |     |     }
  82 |     | 
  83 |     |     function bytesToUint(bytes memory b) internal pure virtual returns (uint256) {
  84 |     |         require(b.length <= 32, "StdUtils bytesToUint(bytes): Bytes length exceeds 32.");
  85 |     |         return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));
  86 |     |     }
  87 |     | 
  88 |     |     /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce
  89 |     |     /// @notice adapted from Solmate implementation (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibRLP.sol)
  90 |     |     function computeCreateAddress(address deployer, uint256 nonce) internal pure virtual returns (address) {
  91 |     |         // forgefmt: disable-start
  92 |     |         // The integer zero is treated as an empty byte string, and as a result it only has a length prefix, 0x80, computed via 0x80 + 0.
  93 |     |         // A one byte integer uses its own value as its length prefix, there is no additional "0x80 + length" prefix that comes before it.
  94 |     |         if (nonce == 0x00)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80))));
  95 |     |         if (nonce <= 0x7f)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce))));
  96 |     | 
  97 |     |         // Nonces greater than 1 byte all follow a consistent encoding scheme, where each value is preceded by a prefix of 0x80 + length.
  98 |     |         if (nonce <= 2**8 - 1)  return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployer, bytes1(0x81), uint8(nonce))));
  99 |     |         if (nonce <= 2**16 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployer, bytes1(0x82), uint16(nonce))));
 100 |     |         if (nonce <= 2**24 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployer, bytes1(0x83), uint24(nonce))));
 101 |     |         // forgefmt: disable-end
 102 |     | 
 103 |     |         // More details about RLP encoding can be found here: https://eth.wiki/fundamentals/rlp
 104 |     |         // 0xda = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x84 ++ nonce)
 105 |     |         // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)
 106 |     |         // 0x84 = 0x80 + 0x04 (0x04 = the bytes length of the nonce, 4 bytes, in hex)
 107 |     |         // We assume nobody can have a nonce large enough to require more than 32 bytes.
 108 |     |         return addressFromLast20Bytes(
 109 |     |             keccak256(abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce)))
 110 |     |         );
 111 |     |     }
 112 |     | 
 113 |     |     function computeCreate2Address(bytes32 salt, bytes32 initcodeHash, address deployer)
 114 |     |         internal
 115 |     |         pure
 116 |     |         virtual
 117 |     |         returns (address)
 118 |     |     {
 119 |     |         return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, initcodeHash)));
 120 |     |     }
 121 |     | 
 122 |     |     /// @dev returns the address of a contract created with CREATE2 using the default CREATE2 deployer
 123 |     |     function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) internal pure returns (address) {
 124 |     |         return computeCreate2Address(salt, initCodeHash, CREATE2_FACTORY);
 125 |     |     }
 126 |     | 
 127 |     |     /// @dev returns the hash of the init code (creation code + no args) used in CREATE2 with no constructor arguments
 128 |     |     /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode
 129 |     |     function hashInitCode(bytes memory creationCode) internal pure returns (bytes32) {
 130 |     |         return hashInitCode(creationCode, "");
 131 |     |     }
 132 |     | 
 133 |     |     /// @dev returns the hash of the init code (creation code + ABI-encoded args) used in CREATE2
 134 |     |     /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode
 135 |     |     /// @param args the ABI-encoded arguments to the constructor of C
 136 |     |     function hashInitCode(bytes memory creationCode, bytes memory args) internal pure returns (bytes32) {
 137 |     |         return keccak256(abi.encodePacked(creationCode, args));
 138 |     |     }
 139 |     | 
 140 |     |     // Performs a single call with Multicall3 to query the ERC-20 token balances of the given addresses.
 141 |     |     function getTokenBalances(address token, address[] memory addresses)
 142 |     |         internal
 143 |     |         virtual
 144 |     |         returns (uint256[] memory balances)
 145 |     |     {
 146 |     |         uint256 tokenCodeSize;
 147 |     |         assembly {
 148 |     |             tokenCodeSize := extcodesize(token)
 149 |     |         }
 150 |     |         require(tokenCodeSize > 0, "StdUtils getTokenBalances(address,address[]): Token address is not a contract.");
 151 |     | 
 152 |     |         // ABI encode the aggregate call to Multicall3.
 153 |     |         uint256 length = addresses.length;
 154 |     |         IMulticall3.Call[] memory calls = new IMulticall3.Call[](length);
 155 |     |         for (uint256 i = 0; i < length; ++i) {
 156 |     |             // 0x70a08231 = bytes4("balanceOf(address)"))
 157 |     |             calls[i] = IMulticall3.Call({target: token, callData: abi.encodeWithSelector(0x70a08231, (addresses[i]))});
 158 |     |         }
 159 |     | 
 160 |     |         // Make the aggregate call.
 161 |     |         (, bytes[] memory returnData) = multicall.aggregate(calls);
 162 |     | 
 163 |     |         // ABI decode the return data and return the balances.
 164 |     |         balances = new uint256[](length);
 165 |     |         for (uint256 i = 0; i < length; ++i) {
 166 |     |             balances[i] = abi.decode(returnData[i], (uint256));
 167 |     |         }
 168 |     |     }
 169 |     | 
 170 |     |     /*//////////////////////////////////////////////////////////////////////////
 171 |     |                                  PRIVATE FUNCTIONS
 172 |     |     //////////////////////////////////////////////////////////////////////////*/
 173 |     | 
 174 |     |     function addressFromLast20Bytes(bytes32 bytesValue) private pure returns (address) {
 175 |     |         return address(uint160(uint256(bytesValue)));
 176 |     |     }
 177 |     | 
 178 |     |     // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.
 179 |     | 
 180 |     |     function console2_log(string memory p0, uint256 p1) private view {
 181 |     |         (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature("log(string,uint256)", p0, p1));
 182 |     |         status;
 183 |     |     }
 184 |     | 
 185 |     |     function console2_log(string memory p0, string memory p1) private view {
 186 |     |         (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature("log(string,string)", p0, p1));
 187 |     |         status;
 188 |     |     }
 189 |     | }
 190 |     | 

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/forge-std/src/Test.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | pragma experimental ABIEncoderV2;
  5 |     | 
  6 |     | // 💬 ABOUT
  7 |     | // Standard Library's default Test
  8 |     | 
  9 |     | // 🧩 MODULES
 10 |     | import {console} from "./console.sol";
 11 |     | import {console2} from "./console2.sol";
 12 |     | import {StdAssertions} from "./StdAssertions.sol";
 13 |     | import {StdChains} from "./StdChains.sol";
 14 |     | import {StdCheats} from "./StdCheats.sol";
 15 |     | import {stdError} from "./StdError.sol";
 16 |     | import {StdInvariant} from "./StdInvariant.sol";
 17 |     | import {stdJson} from "./StdJson.sol";
 18 |     | import {stdMath} from "./StdMath.sol";
 19 |     | import {StdStorage, stdStorage} from "./StdStorage.sol";
 20 |     | import {StdUtils} from "./StdUtils.sol";
 21 |     | import {Vm} from "./Vm.sol";
 22 |     | import {StdStyle} from "./StdStyle.sol";
 23 |     | 
 24 |     | // 📦 BOILERPLATE
 25 |     | import {TestBase} from "./Base.sol";
 26 |     | import {DSTest} from "ds-test/test.sol";
 27 |     | 
 28 |     | // ⭐️ TEST
 29 |     | abstract contract Test is DSTest, StdAssertions, StdChains, StdCheats, StdInvariant, StdUtils, TestBase {
 30 |     | // Note: IS_TEST() must return true.
 31 |     | // Note: Must have failure system, https://github.com/dapphub/ds-test/blob/cd98eff28324bfac652e63a239a60632a761790b/src/test.sol#L39-L76.
 32 |     | }
 33 |     | 

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/forge-std/src/Vm.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | // Cheatcodes are marked as view/pure/none using the following rules:
   7 |     | // 0. A call's observable behaviour includes its return value, logs, reverts and state writes,
   8 |     | // 1. If you can influence a later call's observable behaviour, you're neither `view` nor `pure (you are modifying some state be it the EVM, interpreter, filesystem, etc),
   9 |     | // 2. Otherwise if you can be influenced by an earlier call, or if reading some state, you're `view`,
  10 |     | // 3. Otherwise you're `pure`.
  11 |     | 
  12 |     | interface VmSafe {
  13 |     |     struct Log {
  14 |     |         bytes32[] topics;
  15 |     |         bytes data;
  16 |     |         address emitter;
  17 |     |     }
  18 |     | 
  19 |     |     struct Rpc {
  20 |     |         string key;
  21 |     |         string url;
  22 |     |     }
  23 |     | 
  24 |     |     struct FsMetadata {
  25 |     |         bool isDir;
  26 |     |         bool isSymlink;
  27 |     |         uint256 length;
  28 |     |         bool readOnly;
  29 |     |         uint256 modified;
  30 |     |         uint256 accessed;
  31 |     |         uint256 created;
  32 |     |     }
  33 |     | 
  34 |     |     // Loads a storage slot from an address
  35 |     |     function load(address target, bytes32 slot) external view returns (bytes32 data);
  36 |     |     // Signs data
  37 |     |     function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);
  38 |     |     // Gets the address for a given private key
  39 |     |     function addr(uint256 privateKey) external pure returns (address keyAddr);
  40 |     |     // Gets the nonce of an account
  41 |     |     function getNonce(address account) external view returns (uint64 nonce);
  42 |     |     // Performs a foreign function call via the terminal
  43 |     |     function ffi(string[] calldata commandInput) external returns (bytes memory result);
  44 |     |     // Sets environment variables
  45 |     |     function setEnv(string calldata name, string calldata value) external;
  46 |     |     // Reads environment variables, (name) => (value)
  47 |     |     function envBool(string calldata name) external view returns (bool value);
  48 |     |     function envUint(string calldata name) external view returns (uint256 value);
  49 |     |     function envInt(string calldata name) external view returns (int256 value);
  50 |     |     function envAddress(string calldata name) external view returns (address value);
  51 |     |     function envBytes32(string calldata name) external view returns (bytes32 value);
  52 |     |     function envString(string calldata name) external view returns (string memory value);
  53 |     |     function envBytes(string calldata name) external view returns (bytes memory value);
  54 |     |     // Reads environment variables as arrays
  55 |     |     function envBool(string calldata name, string calldata delim) external view returns (bool[] memory value);
  56 |     |     function envUint(string calldata name, string calldata delim) external view returns (uint256[] memory value);
  57 |     |     function envInt(string calldata name, string calldata delim) external view returns (int256[] memory value);
  58 |     |     function envAddress(string calldata name, string calldata delim) external view returns (address[] memory value);
  59 |     |     function envBytes32(string calldata name, string calldata delim) external view returns (bytes32[] memory value);
  60 |     |     function envString(string calldata name, string calldata delim) external view returns (string[] memory value);
  61 |     |     function envBytes(string calldata name, string calldata delim) external view returns (bytes[] memory value);
  62 |     |     // Read environment variables with default value
  63 |     |     function envOr(string calldata name, bool defaultValue) external returns (bool value);
  64 |     |     function envOr(string calldata name, uint256 defaultValue) external returns (uint256 value);
  65 |     |     function envOr(string calldata name, int256 defaultValue) external returns (int256 value);
  66 |     |     function envOr(string calldata name, address defaultValue) external returns (address value);
  67 |     |     function envOr(string calldata name, bytes32 defaultValue) external returns (bytes32 value);
  68 |     |     function envOr(string calldata name, string calldata defaultValue) external returns (string memory value);
  69 |     |     function envOr(string calldata name, bytes calldata defaultValue) external returns (bytes memory value);
  70 |     |     // Read environment variables as arrays with default value
  71 |     |     function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)
  72 |     |         external
  73 |     |         returns (bool[] memory value);
  74 |     |     function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)
  75 |     |         external
  76 |     |         returns (uint256[] memory value);
  77 |     |     function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)
  78 |     |         external
  79 |     |         returns (int256[] memory value);
  80 |     |     function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)
  81 |     |         external
  82 |     |         returns (address[] memory value);
  83 |     |     function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)
  84 |     |         external
  85 |     |         returns (bytes32[] memory value);
  86 |     |     function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)
  87 |     |         external
  88 |     |         returns (string[] memory value);
  89 |     |     function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)
  90 |     |         external
  91 |     |         returns (bytes[] memory value);
  92 |     |     // Records all storage reads and writes
  93 |     |     function record() external;
  94 |     |     // Gets all accessed reads and write slot from a recording session, for a given address
  95 |     |     function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);
  96 |     |     // Gets the _creation_ bytecode from an artifact file. Takes in the relative path to the json file
  97 |     |     function getCode(string calldata artifactPath) external view returns (bytes memory creationBytecode);
  98 |     |     // Gets the _deployed_ bytecode from an artifact file. Takes in the relative path to the json file
  99 |     |     function getDeployedCode(string calldata artifactPath) external view returns (bytes memory runtimeBytecode);
 100 |     |     // Labels an address in call traces
 101 |     |     function label(address account, string calldata newLabel) external;
 102 |     |     // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain
 103 |     |     function broadcast() external;
 104 |     |     // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain
 105 |     |     function broadcast(address signer) external;
 106 |     |     // Has the next call (at this call depth only) create a transaction with the private key provided as the sender that can later be signed and sent onchain
 107 |     |     function broadcast(uint256 privateKey) external;
 108 |     |     // Using the address that calls the test contract, has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain
 109 |     |     function startBroadcast() external;
 110 |     |     // Has all subsequent calls (at this call depth only) create transactions with the address provided that can later be signed and sent onchain
 111 |     |     function startBroadcast(address signer) external;
 112 |     |     // Has all subsequent calls (at this call depth only) create transactions with the private key provided that can later be signed and sent onchain
 113 |     |     function startBroadcast(uint256 privateKey) external;
 114 |     |     // Stops collecting onchain transactions
 115 |     |     function stopBroadcast() external;
 116 |     |     // Reads the entire content of file to string
 117 |     |     function readFile(string calldata path) external view returns (string memory data);
 118 |     |     // Reads the entire content of file as binary. Path is relative to the project root.
 119 |     |     function readFileBinary(string calldata path) external view returns (bytes memory data);
 120 |     |     // Get the path of the current project root
 121 |     |     function projectRoot() external view returns (string memory path);
 122 |     |     // Get the metadata for a file/directory
 123 |     |     function fsMetadata(string calldata fileOrDir) external returns (FsMetadata memory metadata);
 124 |     |     // Reads next line of file to string
 125 |     |     function readLine(string calldata path) external view returns (string memory line);
 126 |     |     // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.
 127 |     |     function writeFile(string calldata path, string calldata data) external;
 128 |     |     // Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.
 129 |     |     // Path is relative to the project root.
 130 |     |     function writeFileBinary(string calldata path, bytes calldata data) external;
 131 |     |     // Writes line to file, creating a file if it does not exist.
 132 |     |     function writeLine(string calldata path, string calldata data) external;
 133 |     |     // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.
 134 |     |     function closeFile(string calldata path) external;
 135 |     |     // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:
 136 |     |     // - Path points to a directory.
 137 |     |     // - The file doesn't exist.
 138 |     |     // - The user lacks permissions to remove the file.
 139 |     |     function removeFile(string calldata path) external;
 140 |     |     // Convert values to a string
 141 |     |     function toString(address value) external pure returns (string memory stringifiedValue);
 142 |     |     function toString(bytes calldata value) external pure returns (string memory stringifiedValue);
 143 |     |     function toString(bytes32 value) external pure returns (string memory stringifiedValue);
 144 |     |     function toString(bool value) external pure returns (string memory stringifiedValue);
 145 |     |     function toString(uint256 value) external pure returns (string memory stringifiedValue);
 146 |     |     function toString(int256 value) external pure returns (string memory stringifiedValue);
 147 |     |     // Convert values from a string
 148 |     |     function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);
 149 |     |     function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);
 150 |     |     function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);
 151 |     |     function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);
 152 |     |     function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);
 153 |     |     function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);
 154 |     |     // Record all the transaction logs
 155 |     |     function recordLogs() external;
 156 |     |     // Gets all the recorded logs
 157 |     |     function getRecordedLogs() external returns (Log[] memory logs);
 158 |     |     // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}
 159 |     |     function deriveKey(string calldata mnemonic, uint32 index) external pure returns (uint256 privateKey);
 160 |     |     // Derive a private key from a provided mnenomic string (or mnenomic file path) at {derivationPath}{index}
 161 |     |     function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index)
 162 |     |         external
 163 |     |         pure
 164 |     |         returns (uint256 privateKey);
 165 |     |     // Adds a private key to the local forge wallet and returns the address
 166 |     |     function rememberKey(uint256 privateKey) external returns (address keyAddr);
 167 |     |     //
 168 |     |     // parseJson
 169 |     |     //
 170 |     |     // ----
 171 |     |     // In case the returned value is a JSON object, it's encoded as a ABI-encoded tuple. As JSON objects
 172 |     |     // don't have the notion of ordered, but tuples do, they JSON object is encoded with it's fields ordered in
 173 |     |     // ALPHABETICAL order. That means that in order to successfully decode the tuple, we need to define a tuple that
 174 |     |     // encodes the fields in the same order, which is alphabetical. In the case of Solidity structs, they are encoded
 175 |     |     // as tuples, with the attributes in the order in which they are defined.
 176 |     |     // For example: json = { 'a': 1, 'b': 0xa4tb......3xs}
 177 |     |     // a: uint256
 178 |     |     // b: address
 179 |     |     // To decode that json, we need to define a struct or a tuple as follows:
 180 |     |     // struct json = { uint256 a; address b; }
 181 |     |     // If we defined a json struct with the opposite order, meaning placing the address b first, it would try to
 182 |     |     // decode the tuple in that order, and thus fail.
 183 |     |     // ----
 184 |     |     // Given a string of JSON, return it as ABI-encoded
 185 |     |     function parseJson(string calldata json, string calldata key) external pure returns (bytes memory abiEncodedData);
 186 |     |     function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);
 187 |     | 
 188 |     |     // The following parseJson cheatcodes will do type coercion, for the type that they indicate.
 189 |     |     // For example, parseJsonUint will coerce all values to a uint256. That includes stringified numbers '12'
 190 |     |     // and hex numbers '0xEF'.
 191 |     |     // Type coercion works ONLY for discrete values or arrays. That means that the key must return a value or array, not
 192 |     |     // a JSON object.
 193 |     |     function parseJsonUint(string calldata, string calldata) external returns (uint256);
 194 |     |     function parseJsonUintArray(string calldata, string calldata) external returns (uint256[] memory);
 195 |     |     function parseJsonInt(string calldata, string calldata) external returns (int256);
 196 |     |     function parseJsonIntArray(string calldata, string calldata) external returns (int256[] memory);
 197 |     |     function parseJsonBool(string calldata, string calldata) external returns (bool);
 198 |     |     function parseJsonBoolArray(string calldata, string calldata) external returns (bool[] memory);
 199 |     |     function parseJsonAddress(string calldata, string calldata) external returns (address);
 200 |     |     function parseJsonAddressArray(string calldata, string calldata) external returns (address[] memory);
 201 |     |     function parseJsonString(string calldata, string calldata) external returns (string memory);
 202 |     |     function parseJsonStringArray(string calldata, string calldata) external returns (string[] memory);
 203 |     |     function parseJsonBytes(string calldata, string calldata) external returns (bytes memory);
 204 |     |     function parseJsonBytesArray(string calldata, string calldata) external returns (bytes[] memory);
 205 |     |     function parseJsonBytes32(string calldata, string calldata) external returns (bytes32);
 206 |     |     function parseJsonBytes32Array(string calldata, string calldata) external returns (bytes32[] memory);
 207 |     | 
 208 |     |     // Serialize a key and value to a JSON object stored in-memory that can be later written to a file
 209 |     |     // It returns the stringified version of the specific JSON file up to that moment.
 210 |     |     function serializeBool(string calldata objectKey, string calldata valueKey, bool value)
 211 |     |         external
 212 |     |         returns (string memory json);
 213 |     |     function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)
 214 |     |         external
 215 |     |         returns (string memory json);
 216 |     |     function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)
 217 |     |         external
 218 |     |         returns (string memory json);
 219 |     |     function serializeAddress(string calldata objectKey, string calldata valueKey, address value)
 220 |     |         external
 221 |     |         returns (string memory json);
 222 |     |     function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)
 223 |     |         external
 224 |     |         returns (string memory json);
 225 |     |     function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)
 226 |     |         external
 227 |     |         returns (string memory json);
 228 |     |     function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)
 229 |     |         external
 230 |     |         returns (string memory json);
 231 |     | 
 232 |     |     function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)
 233 |     |         external
 234 |     |         returns (string memory json);
 235 |     |     function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)
 236 |     |         external
 237 |     |         returns (string memory json);
 238 |     |     function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)
 239 |     |         external
 240 |     |         returns (string memory json);
 241 |     |     function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)
 242 |     |         external
 243 |     |         returns (string memory json);
 244 |     |     function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)
 245 |     |         external
 246 |     |         returns (string memory json);
 247 |     |     function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)
 248 |     |         external
 249 |     |         returns (string memory json);
 250 |     |     function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)
 251 |     |         external
 252 |     |         returns (string memory json);
 253 |     | 
 254 |     |     //
 255 |     |     // writeJson
 256 |     |     //
 257 |     |     // ----
 258 |     |     // Write a serialized JSON object to a file. If the file exists, it will be overwritten.
 259 |     |     // Let's assume we want to write the following JSON to a file:
 260 |     |     //
 261 |     |     // { "boolean": true, "number": 342, "object": { "title": "finally json serialization" } }
 262 |     |     //
 263 |     |     // ```
 264 |     |     //  string memory json1 = "some key";
 265 |     |     //  vm.serializeBool(json1, "boolean", true);
 266 |     |     //  vm.serializeBool(json1, "number", uint256(342));
 267 |     |     //  json2 = "some other key";
 268 |     |     //  string memory output = vm.serializeString(json2, "title", "finally json serialization");
 269 |     |     //  string memory finalJson = vm.serialize(json1, "object", output);
 270 |     |     //  vm.writeJson(finalJson, "./output/example.json");
 271 |     |     // ```
 272 |     |     // The critical insight is that every invocation of serialization will return the stringified version of the JSON
 273 |     |     // up to that point. That means we can construct arbitrary JSON objects and then use the return stringified version
 274 |     |     // to serialize them as values to another JSON object.
 275 |     |     //
 276 |     |     // json1 and json2 are simply keys used by the backend to keep track of the objects. So vm.serializeJson(json1,..)
 277 |     |     // will find the object in-memory that is keyed by "some key".
 278 |     |     function writeJson(string calldata json, string calldata path) external;
 279 |     |     // Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key>
 280 |     |     // This is useful to replace a specific value of a JSON file, without having to parse the entire thing
 281 |     |     function writeJson(string calldata json, string calldata path, string calldata valueKey) external;
 282 |     |     // Returns the RPC url for the given alias
 283 |     |     function rpcUrl(string calldata rpcAlias) external view returns (string memory json);
 284 |     |     // Returns all rpc urls and their aliases `[alias, url][]`
 285 |     |     function rpcUrls() external view returns (string[2][] memory urls);
 286 |     |     // Returns all rpc urls and their aliases as structs.
 287 |     |     function rpcUrlStructs() external view returns (Rpc[] memory urls);
 288 |     |     // If the condition is false, discard this run's fuzz inputs and generate new ones.
 289 |     |     function assume(bool condition) external pure;
 290 |     |     // Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.
 291 |     |     function pauseGasMetering() external;
 292 |     |     // Resumes gas metering (i.e. gas usage is counted again). Noop if already on.
 293 |     |     function resumeGasMetering() external;
 294 |     | }
 295 |     | 
 296 |     | interface Vm is VmSafe {
 297 |     |     // Sets block.timestamp
 298 |     |     function warp(uint256 newTimestamp) external;
 299 |     |     // Sets block.height
 300 |     |     function roll(uint256 newHeight) external;
 301 |     |     // Sets block.basefee
 302 |     |     function fee(uint256 newBasefee) external;
 303 |     |     // Sets block.difficulty
 304 |     |     function difficulty(uint256 newDifficulty) external;
 305 |     |     // Sets block.chainid
 306 |     |     function chainId(uint256 newChainId) external;
 307 |     |     // Stores a value to an address' storage slot.
 308 |     |     function store(address target, bytes32 slot, bytes32 value) external;
 309 |     |     // Sets the nonce of an account; must be higher than the current nonce of the account
 310 |     |     function setNonce(address account, uint64 newNonce) external;
 311 |     |     // Sets the *next* call's msg.sender to be the input address
 312 |     |     function prank(address msgSender) external;
 313 |     |     // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called
 314 |     |     function startPrank(address msgSender) external;
 315 |     |     // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input
 316 |     |     function prank(address msgSender, address txOrigin) external;
 317 |     |     // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input
 318 |     |     function startPrank(address msgSender, address txOrigin) external;
 319 |     |     // Resets subsequent calls' msg.sender to be `address(this)`
 320 |     |     function stopPrank() external;
 321 |     |     // Sets an address' balance
 322 |     |     function deal(address account, uint256 newBalance) external;
 323 |     |     // Sets an address' code
 324 |     |     function etch(address target, bytes calldata newRuntimeBytecode) external;
 325 |     |     // Expects an error on next call
 326 |     |     function expectRevert(bytes calldata revertData) external;
 327 |     |     function expectRevert(bytes4 revertData) external;
 328 |     |     function expectRevert() external;
 329 |     |     // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).
 330 |     |     // Call this function, then emit an event, then call a function. Internally after the call, we check if
 331 |     |     // logs were emitted in the expected order with the expected topics and data (as specified by the booleans)
 332 |     |     function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData) external;
 333 |     |     function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter)
 334 |     |         external;
 335 |     |     // Mocks a call to an address, returning specified data.
 336 |     |     // Calldata can either be strict or a partial match, e.g. if you only
 337 |     |     // pass a Solidity selector to the expected calldata, then the entire Solidity
 338 |     |     // function will be mocked.
 339 |     |     function mockCall(address callee, bytes calldata data, bytes calldata returnData) external;
 340 |     |     // Mocks a call to an address with a specific msg.value, returning specified data.
 341 |     |     // Calldata match takes precedence over msg.value in case of ambiguity.
 342 |     |     function mockCall(address callee, uint256 msgValue, bytes calldata data, bytes calldata returnData) external;
 343 |     |     // Clears all mocked calls
 344 |     |     function clearMockedCalls() external;
 345 |     |     // Expects a call to an address with the specified calldata.
 346 |     |     // Calldata can either be a strict or a partial match
 347 |     |     function expectCall(address callee, bytes calldata data) external;
 348 |     |     // Expects a call to an address with the specified msg.value and calldata
 349 |     |     function expectCall(address callee, uint256 msgValue, bytes calldata data) external;
 350 |     |     // Expect a call to an address with the specified msg.value, gas, and calldata.
 351 |     |     function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data) external;
 352 |     |     // Expect a call to an address with the specified msg.value and calldata, and a *minimum* amount of gas.
 353 |     |     function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data) external;
 354 |     |     // Sets block.coinbase
 355 |     |     function coinbase(address newCoinbase) external;
 356 |     |     // Snapshot the current state of the evm.
 357 |     |     // Returns the id of the snapshot that was created.
 358 |     |     // To revert a snapshot use `revertTo`
 359 |     |     function snapshot() external returns (uint256 snapshotId);
 360 |     |     // Revert the state of the EVM to a previous snapshot
 361 |     |     // Takes the snapshot id to revert to.
 362 |     |     // This deletes the snapshot and all snapshots taken after the given snapshot id.
 363 |     |     function revertTo(uint256 snapshotId) external returns (bool success);
 364 |     |     // Creates a new fork with the given endpoint and block and returns the identifier of the fork
 365 |     |     function createFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);
 366 |     |     // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork
 367 |     |     function createFork(string calldata urlOrAlias) external returns (uint256 forkId);
 368 |     |     // Creates a new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before the transaction,
 369 |     |     // and returns the identifier of the fork
 370 |     |     function createFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);
 371 |     |     // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork
 372 |     |     function createSelectFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);
 373 |     |     // Creates _and_ also selects new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before
 374 |     |     // the transaction, returns the identifier of the fork
 375 |     |     function createSelectFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);
 376 |     |     // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork
 377 |     |     function createSelectFork(string calldata urlOrAlias) external returns (uint256 forkId);
 378 |     |     // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.
 379 |     |     function selectFork(uint256 forkId) external;
 380 |     |     /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.
 381 |     |     function activeFork() external view returns (uint256 forkId);
 382 |     |     // Updates the currently active fork to given block number
 383 |     |     // This is similar to `roll` but for the currently active fork
 384 |     |     function rollFork(uint256 blockNumber) external;
 385 |     |     // Updates the currently active fork to given transaction
 386 |     |     // this will `rollFork` with the number of the block the transaction was mined in and replays all transaction mined before it in the block
 387 |     |     function rollFork(bytes32 txHash) external;
 388 |     |     // Updates the given fork to given block number
 389 |     |     function rollFork(uint256 forkId, uint256 blockNumber) external;
 390 |     |     // Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block
 391 |     |     function rollFork(uint256 forkId, bytes32 txHash) external;
 392 |     |     // Marks that the account(s) should use persistent storage across fork swaps in a multifork setup
 393 |     |     // Meaning, changes made to the state of this account will be kept when switching forks
 394 |     |     function makePersistent(address account) external;
 395 |     |     function makePersistent(address account0, address account1) external;
 396 |     |     function makePersistent(address account0, address account1, address account2) external;
 397 |     |     function makePersistent(address[] calldata accounts) external;
 398 |     |     // Revokes persistent status from the address, previously added via `makePersistent`
 399 |     |     function revokePersistent(address account) external;
 400 |     |     function revokePersistent(address[] calldata accounts) external;
 401 |     |     // Returns true if the account is marked as persistent
 402 |     |     function isPersistent(address account) external view returns (bool persistent);
 403 |     |     // In forking mode, explicitly grant the given address cheatcode access
 404 |     |     function allowCheatcodes(address account) external;
 405 |     |     // Fetches the given transaction from the active fork and executes it on the current state
 406 |     |     function transact(bytes32 txHash) external;
 407 |     |     // Fetches the given transaction from the given fork and executes it on the current state
 408 |     |     function transact(uint256 forkId, bytes32 txHash) external;
 409 |     | }
 410 |     | 

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/forge-std/src/console.sol
    1 |     | // SPDX-License-Identifier: MIT
    2 |     | pragma solidity >=0.4.22 <0.9.0;
    3 |     | 
    4 |     | library console {
    5 |     |     address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);
    6 |     | 
    7 |     |     function _sendLogPayload(bytes memory payload) private view {
    8 |     |         uint256 payloadLength = payload.length;
    9 |     |         address consoleAddress = CONSOLE_ADDRESS;
   10 |     |         /// @solidity memory-safe-assembly
   11 |     |         assembly {
   12 |     |             let payloadStart := add(payload, 32)
   13 |     |             let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)
   14 |     |         }
   15 |     |     }
   16 |     | 
   17 |     |     function log() internal view {
   18 |     |         _sendLogPayload(abi.encodeWithSignature("log()"));
   19 |     |     }
   20 |     | 
   21 |     |     function logInt(int p0) internal view {
   22 |     |         _sendLogPayload(abi.encodeWithSignature("log(int)", p0));
   23 |     |     }
   24 |     | 
   25 |     |     function logUint(uint p0) internal view {
   26 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint)", p0));
   27 |     |     }
   28 |     | 
   29 |     |     function logString(string memory p0) internal view {
   30 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
   31 |     |     }
   32 |     | 
   33 |     |     function logBool(bool p0) internal view {
   34 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
   35 |     |     }
   36 |     | 
   37 |     |     function logAddress(address p0) internal view {
   38 |     |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
   39 |     |     }
   40 |     | 
   41 |     |     function logBytes(bytes memory p0) internal view {
   42 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes)", p0));
   43 |     |     }
   44 |     | 
   45 |     |     function logBytes1(bytes1 p0) internal view {
   46 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes1)", p0));
   47 |     |     }
   48 |     | 
   49 |     |     function logBytes2(bytes2 p0) internal view {
   50 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes2)", p0));
   51 |     |     }
   52 |     | 
   53 |     |     function logBytes3(bytes3 p0) internal view {
   54 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes3)", p0));
   55 |     |     }
   56 |     | 
   57 |     |     function logBytes4(bytes4 p0) internal view {
   58 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes4)", p0));
   59 |     |     }
   60 |     | 
   61 |     |     function logBytes5(bytes5 p0) internal view {
   62 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes5)", p0));
   63 |     |     }
   64 |     | 
   65 |     |     function logBytes6(bytes6 p0) internal view {
   66 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes6)", p0));
   67 |     |     }
   68 |     | 
   69 |     |     function logBytes7(bytes7 p0) internal view {
   70 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes7)", p0));
   71 |     |     }
   72 |     | 
   73 |     |     function logBytes8(bytes8 p0) internal view {
   74 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes8)", p0));
   75 |     |     }
   76 |     | 
   77 |     |     function logBytes9(bytes9 p0) internal view {
   78 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes9)", p0));
   79 |     |     }
   80 |     | 
   81 |     |     function logBytes10(bytes10 p0) internal view {
   82 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes10)", p0));
   83 |     |     }
   84 |     | 
   85 |     |     function logBytes11(bytes11 p0) internal view {
   86 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes11)", p0));
   87 |     |     }
   88 |     | 
   89 |     |     function logBytes12(bytes12 p0) internal view {
   90 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes12)", p0));
   91 |     |     }
   92 |     | 
   93 |     |     function logBytes13(bytes13 p0) internal view {
   94 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes13)", p0));
   95 |     |     }
   96 |     | 
   97 |     |     function logBytes14(bytes14 p0) internal view {
   98 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes14)", p0));
   99 |     |     }
  100 |     | 
  101 |     |     function logBytes15(bytes15 p0) internal view {
  102 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes15)", p0));
  103 |     |     }
  104 |     | 
  105 |     |     function logBytes16(bytes16 p0) internal view {
  106 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes16)", p0));
  107 |     |     }
  108 |     | 
  109 |     |     function logBytes17(bytes17 p0) internal view {
  110 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes17)", p0));
  111 |     |     }
  112 |     | 
  113 |     |     function logBytes18(bytes18 p0) internal view {
  114 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes18)", p0));
  115 |     |     }
  116 |     | 
  117 |     |     function logBytes19(bytes19 p0) internal view {
  118 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes19)", p0));
  119 |     |     }
  120 |     | 
  121 |     |     function logBytes20(bytes20 p0) internal view {
  122 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes20)", p0));
  123 |     |     }
  124 |     | 
  125 |     |     function logBytes21(bytes21 p0) internal view {
  126 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes21)", p0));
  127 |     |     }
  128 |     | 
  129 |     |     function logBytes22(bytes22 p0) internal view {
  130 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes22)", p0));
  131 |     |     }
  132 |     | 
  133 |     |     function logBytes23(bytes23 p0) internal view {
  134 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes23)", p0));
  135 |     |     }
  136 |     | 
  137 |     |     function logBytes24(bytes24 p0) internal view {
  138 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes24)", p0));
  139 |     |     }
  140 |     | 
  141 |     |     function logBytes25(bytes25 p0) internal view {
  142 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes25)", p0));
  143 |     |     }
  144 |     | 
  145 |     |     function logBytes26(bytes26 p0) internal view {
  146 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes26)", p0));
  147 |     |     }
  148 |     | 
  149 |     |     function logBytes27(bytes27 p0) internal view {
  150 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes27)", p0));
  151 |     |     }
  152 |     | 
  153 |     |     function logBytes28(bytes28 p0) internal view {
  154 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes28)", p0));
  155 |     |     }
  156 |     | 
  157 |     |     function logBytes29(bytes29 p0) internal view {
  158 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes29)", p0));
  159 |     |     }
  160 |     | 
  161 |     |     function logBytes30(bytes30 p0) internal view {
  162 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes30)", p0));
  163 |     |     }
  164 |     | 
  165 |     |     function logBytes31(bytes31 p0) internal view {
  166 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes31)", p0));
  167 |     |     }
  168 |     | 
  169 |     |     function logBytes32(bytes32 p0) internal view {
  170 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes32)", p0));
  171 |     |     }
  172 |     | 
  173 |     |     function log(uint p0) internal view {
  174 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint)", p0));
  175 |     |     }
  176 |     | 
  177 |     |     function log(string memory p0) internal view {
  178 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
  179 |     |     }
  180 |     | 
  181 |     |     function log(bool p0) internal view {
  182 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
  183 |     |     }
  184 |     | 
  185 |     |     function log(address p0) internal view {
  186 |     |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
  187 |     |     }
  188 |     | 
  189 |     |     function log(uint p0, uint p1) internal view {
  190 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint)", p0, p1));
  191 |     |     }
  192 |     | 
  193 |     |     function log(uint p0, string memory p1) internal view {
  194 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string)", p0, p1));
  195 |     |     }
  196 |     | 
  197 |     |     function log(uint p0, bool p1) internal view {
  198 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool)", p0, p1));
  199 |     |     }
  200 |     | 
  201 |     |     function log(uint p0, address p1) internal view {
  202 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address)", p0, p1));
  203 |     |     }
  204 |     | 
  205 |     |     function log(string memory p0, uint p1) internal view {
  206 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint)", p0, p1));
  207 |     |     }
  208 |     | 
  209 |     |     function log(string memory p0, string memory p1) internal view {
  210 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
  211 |     |     }
  212 |     | 
  213 |     |     function log(string memory p0, bool p1) internal view {
  214 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool)", p0, p1));
  215 |     |     }
  216 |     | 
  217 |     |     function log(string memory p0, address p1) internal view {
  218 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address)", p0, p1));
  219 |     |     }
  220 |     | 
  221 |     |     function log(bool p0, uint p1) internal view {
  222 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint)", p0, p1));
  223 |     |     }
  224 |     | 
  225 |     |     function log(bool p0, string memory p1) internal view {
  226 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string)", p0, p1));
  227 |     |     }
  228 |     | 
  229 |     |     function log(bool p0, bool p1) internal view {
  230 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool)", p0, p1));
  231 |     |     }
  232 |     | 
  233 |     |     function log(bool p0, address p1) internal view {
  234 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address)", p0, p1));
  235 |     |     }
  236 |     | 
  237 |     |     function log(address p0, uint p1) internal view {
  238 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint)", p0, p1));
  239 |     |     }
  240 |     | 
  241 |     |     function log(address p0, string memory p1) internal view {
  242 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string)", p0, p1));
  243 |     |     }
  244 |     | 
  245 |     |     function log(address p0, bool p1) internal view {
  246 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool)", p0, p1));
  247 |     |     }
  248 |     | 
  249 |     |     function log(address p0, address p1) internal view {
  250 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address)", p0, p1));
  251 |     |     }
  252 |     | 
  253 |     |     function log(uint p0, uint p1, uint p2) internal view {
  254 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint)", p0, p1, p2));
  255 |     |     }
  256 |     | 
  257 |     |     function log(uint p0, uint p1, string memory p2) internal view {
  258 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string)", p0, p1, p2));
  259 |     |     }
  260 |     | 
  261 |     |     function log(uint p0, uint p1, bool p2) internal view {
  262 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool)", p0, p1, p2));
  263 |     |     }
  264 |     | 
  265 |     |     function log(uint p0, uint p1, address p2) internal view {
  266 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address)", p0, p1, p2));
  267 |     |     }
  268 |     | 
  269 |     |     function log(uint p0, string memory p1, uint p2) internal view {
  270 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint)", p0, p1, p2));
  271 |     |     }
  272 |     | 
  273 |     |     function log(uint p0, string memory p1, string memory p2) internal view {
  274 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string)", p0, p1, p2));
  275 |     |     }
  276 |     | 
  277 |     |     function log(uint p0, string memory p1, bool p2) internal view {
  278 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool)", p0, p1, p2));
  279 |     |     }
  280 |     | 
  281 |     |     function log(uint p0, string memory p1, address p2) internal view {
  282 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address)", p0, p1, p2));
  283 |     |     }
  284 |     | 
  285 |     |     function log(uint p0, bool p1, uint p2) internal view {
  286 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint)", p0, p1, p2));
  287 |     |     }
  288 |     | 
  289 |     |     function log(uint p0, bool p1, string memory p2) internal view {
  290 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string)", p0, p1, p2));
  291 |     |     }
  292 |     | 
  293 |     |     function log(uint p0, bool p1, bool p2) internal view {
  294 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool)", p0, p1, p2));
  295 |     |     }
  296 |     | 
  297 |     |     function log(uint p0, bool p1, address p2) internal view {
  298 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address)", p0, p1, p2));
  299 |     |     }
  300 |     | 
  301 |     |     function log(uint p0, address p1, uint p2) internal view {
  302 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint)", p0, p1, p2));
  303 |     |     }
  304 |     | 
  305 |     |     function log(uint p0, address p1, string memory p2) internal view {
  306 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string)", p0, p1, p2));
  307 |     |     }
  308 |     | 
  309 |     |     function log(uint p0, address p1, bool p2) internal view {
  310 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool)", p0, p1, p2));
  311 |     |     }
  312 |     | 
  313 |     |     function log(uint p0, address p1, address p2) internal view {
  314 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address)", p0, p1, p2));
  315 |     |     }
  316 |     | 
  317 |     |     function log(string memory p0, uint p1, uint p2) internal view {
  318 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint)", p0, p1, p2));
  319 |     |     }
  320 |     | 
  321 |     |     function log(string memory p0, uint p1, string memory p2) internal view {
  322 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string)", p0, p1, p2));
  323 |     |     }
  324 |     | 
  325 |     |     function log(string memory p0, uint p1, bool p2) internal view {
  326 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool)", p0, p1, p2));
  327 |     |     }
  328 |     | 
  329 |     |     function log(string memory p0, uint p1, address p2) internal view {
  330 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address)", p0, p1, p2));
  331 |     |     }
  332 |     | 
  333 |     |     function log(string memory p0, string memory p1, uint p2) internal view {
  334 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint)", p0, p1, p2));
  335 |     |     }
  336 |     | 
  337 |     |     function log(string memory p0, string memory p1, string memory p2) internal view {
  338 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string)", p0, p1, p2));
  339 |     |     }
  340 |     | 
  341 |     |     function log(string memory p0, string memory p1, bool p2) internal view {
  342 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool)", p0, p1, p2));
  343 |     |     }
  344 |     | 
  345 |     |     function log(string memory p0, string memory p1, address p2) internal view {
  346 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address)", p0, p1, p2));
  347 |     |     }
  348 |     | 
  349 |     |     function log(string memory p0, bool p1, uint p2) internal view {
  350 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint)", p0, p1, p2));
  351 |     |     }
  352 |     | 
  353 |     |     function log(string memory p0, bool p1, string memory p2) internal view {
  354 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string)", p0, p1, p2));
  355 |     |     }
  356 |     | 
  357 |     |     function log(string memory p0, bool p1, bool p2) internal view {
  358 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool)", p0, p1, p2));
  359 |     |     }
  360 |     | 
  361 |     |     function log(string memory p0, bool p1, address p2) internal view {
  362 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address)", p0, p1, p2));
  363 |     |     }
  364 |     | 
  365 |     |     function log(string memory p0, address p1, uint p2) internal view {
  366 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint)", p0, p1, p2));
  367 |     |     }
  368 |     | 
  369 |     |     function log(string memory p0, address p1, string memory p2) internal view {
  370 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string)", p0, p1, p2));
  371 |     |     }
  372 |     | 
  373 |     |     function log(string memory p0, address p1, bool p2) internal view {
  374 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool)", p0, p1, p2));
  375 |     |     }
  376 |     | 
  377 |     |     function log(string memory p0, address p1, address p2) internal view {
  378 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address)", p0, p1, p2));
  379 |     |     }
  380 |     | 
  381 |     |     function log(bool p0, uint p1, uint p2) internal view {
  382 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint)", p0, p1, p2));
  383 |     |     }
  384 |     | 
  385 |     |     function log(bool p0, uint p1, string memory p2) internal view {
  386 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string)", p0, p1, p2));
  387 |     |     }
  388 |     | 
  389 |     |     function log(bool p0, uint p1, bool p2) internal view {
  390 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool)", p0, p1, p2));
  391 |     |     }
  392 |     | 
  393 |     |     function log(bool p0, uint p1, address p2) internal view {
  394 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address)", p0, p1, p2));
  395 |     |     }
  396 |     | 
  397 |     |     function log(bool p0, string memory p1, uint p2) internal view {
  398 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint)", p0, p1, p2));
  399 |     |     }
  400 |     | 
  401 |     |     function log(bool p0, string memory p1, string memory p2) internal view {
  402 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string)", p0, p1, p2));
  403 |     |     }
  404 |     | 
  405 |     |     function log(bool p0, string memory p1, bool p2) internal view {
  406 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool)", p0, p1, p2));
  407 |     |     }
  408 |     | 
  409 |     |     function log(bool p0, string memory p1, address p2) internal view {
  410 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address)", p0, p1, p2));
  411 |     |     }
  412 |     | 
  413 |     |     function log(bool p0, bool p1, uint p2) internal view {
  414 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint)", p0, p1, p2));
  415 |     |     }
  416 |     | 
  417 |     |     function log(bool p0, bool p1, string memory p2) internal view {
  418 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string)", p0, p1, p2));
  419 |     |     }
  420 |     | 
  421 |     |     function log(bool p0, bool p1, bool p2) internal view {
  422 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool)", p0, p1, p2));
  423 |     |     }
  424 |     | 
  425 |     |     function log(bool p0, bool p1, address p2) internal view {
  426 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address)", p0, p1, p2));
  427 |     |     }
  428 |     | 
  429 |     |     function log(bool p0, address p1, uint p2) internal view {
  430 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint)", p0, p1, p2));
  431 |     |     }
  432 |     | 
  433 |     |     function log(bool p0, address p1, string memory p2) internal view {
  434 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string)", p0, p1, p2));
  435 |     |     }
  436 |     | 
  437 |     |     function log(bool p0, address p1, bool p2) internal view {
  438 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool)", p0, p1, p2));
  439 |     |     }
  440 |     | 
  441 |     |     function log(bool p0, address p1, address p2) internal view {
  442 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address)", p0, p1, p2));
  443 |     |     }
  444 |     | 
  445 |     |     function log(address p0, uint p1, uint p2) internal view {
  446 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint)", p0, p1, p2));
  447 |     |     }
  448 |     | 
  449 |     |     function log(address p0, uint p1, string memory p2) internal view {
  450 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string)", p0, p1, p2));
  451 |     |     }
  452 |     | 
  453 |     |     function log(address p0, uint p1, bool p2) internal view {
  454 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool)", p0, p1, p2));
  455 |     |     }
  456 |     | 
  457 |     |     function log(address p0, uint p1, address p2) internal view {
  458 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address)", p0, p1, p2));
  459 |     |     }
  460 |     | 
  461 |     |     function log(address p0, string memory p1, uint p2) internal view {
  462 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint)", p0, p1, p2));
  463 |     |     }
  464 |     | 
  465 |     |     function log(address p0, string memory p1, string memory p2) internal view {
  466 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string)", p0, p1, p2));
  467 |     |     }
  468 |     | 
  469 |     |     function log(address p0, string memory p1, bool p2) internal view {
  470 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool)", p0, p1, p2));
  471 |     |     }
  472 |     | 
  473 |     |     function log(address p0, string memory p1, address p2) internal view {
  474 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address)", p0, p1, p2));
  475 |     |     }
  476 |     | 
  477 |     |     function log(address p0, bool p1, uint p2) internal view {
  478 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint)", p0, p1, p2));
  479 |     |     }
  480 |     | 
  481 |     |     function log(address p0, bool p1, string memory p2) internal view {
  482 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string)", p0, p1, p2));
  483 |     |     }
  484 |     | 
  485 |     |     function log(address p0, bool p1, bool p2) internal view {
  486 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool)", p0, p1, p2));
  487 |     |     }
  488 |     | 
  489 |     |     function log(address p0, bool p1, address p2) internal view {
  490 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address)", p0, p1, p2));
  491 |     |     }
  492 |     | 
  493 |     |     function log(address p0, address p1, uint p2) internal view {
  494 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint)", p0, p1, p2));
  495 |     |     }
  496 |     | 
  497 |     |     function log(address p0, address p1, string memory p2) internal view {
  498 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string)", p0, p1, p2));
  499 |     |     }
  500 |     | 
  501 |     |     function log(address p0, address p1, bool p2) internal view {
  502 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool)", p0, p1, p2));
  503 |     |     }
  504 |     | 
  505 |     |     function log(address p0, address p1, address p2) internal view {
  506 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address)", p0, p1, p2));
  507 |     |     }
  508 |     | 
  509 |     |     function log(uint p0, uint p1, uint p2, uint p3) internal view {
  510 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,uint)", p0, p1, p2, p3));
  511 |     |     }
  512 |     | 
  513 |     |     function log(uint p0, uint p1, uint p2, string memory p3) internal view {
  514 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,string)", p0, p1, p2, p3));
  515 |     |     }
  516 |     | 
  517 |     |     function log(uint p0, uint p1, uint p2, bool p3) internal view {
  518 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,bool)", p0, p1, p2, p3));
  519 |     |     }
  520 |     | 
  521 |     |     function log(uint p0, uint p1, uint p2, address p3) internal view {
  522 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,address)", p0, p1, p2, p3));
  523 |     |     }
  524 |     | 
  525 |     |     function log(uint p0, uint p1, string memory p2, uint p3) internal view {
  526 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,uint)", p0, p1, p2, p3));
  527 |     |     }
  528 |     | 
  529 |     |     function log(uint p0, uint p1, string memory p2, string memory p3) internal view {
  530 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,string)", p0, p1, p2, p3));
  531 |     |     }
  532 |     | 
  533 |     |     function log(uint p0, uint p1, string memory p2, bool p3) internal view {
  534 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,bool)", p0, p1, p2, p3));
  535 |     |     }
  536 |     | 
  537 |     |     function log(uint p0, uint p1, string memory p2, address p3) internal view {
  538 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,address)", p0, p1, p2, p3));
  539 |     |     }
  540 |     | 
  541 |     |     function log(uint p0, uint p1, bool p2, uint p3) internal view {
  542 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,uint)", p0, p1, p2, p3));
  543 |     |     }
  544 |     | 
  545 |     |     function log(uint p0, uint p1, bool p2, string memory p3) internal view {
  546 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,string)", p0, p1, p2, p3));
  547 |     |     }
  548 |     | 
  549 |     |     function log(uint p0, uint p1, bool p2, bool p3) internal view {
  550 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,bool)", p0, p1, p2, p3));
  551 |     |     }
  552 |     | 
  553 |     |     function log(uint p0, uint p1, bool p2, address p3) internal view {
  554 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,address)", p0, p1, p2, p3));
  555 |     |     }
  556 |     | 
  557 |     |     function log(uint p0, uint p1, address p2, uint p3) internal view {
  558 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,uint)", p0, p1, p2, p3));
  559 |     |     }
  560 |     | 
  561 |     |     function log(uint p0, uint p1, address p2, string memory p3) internal view {
  562 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,string)", p0, p1, p2, p3));
  563 |     |     }
  564 |     | 
  565 |     |     function log(uint p0, uint p1, address p2, bool p3) internal view {
  566 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,bool)", p0, p1, p2, p3));
  567 |     |     }
  568 |     | 
  569 |     |     function log(uint p0, uint p1, address p2, address p3) internal view {
  570 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,address)", p0, p1, p2, p3));
  571 |     |     }
  572 |     | 
  573 |     |     function log(uint p0, string memory p1, uint p2, uint p3) internal view {
  574 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,uint)", p0, p1, p2, p3));
  575 |     |     }
  576 |     | 
  577 |     |     function log(uint p0, string memory p1, uint p2, string memory p3) internal view {
  578 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,string)", p0, p1, p2, p3));
  579 |     |     }
  580 |     | 
  581 |     |     function log(uint p0, string memory p1, uint p2, bool p3) internal view {
  582 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,bool)", p0, p1, p2, p3));
  583 |     |     }
  584 |     | 
  585 |     |     function log(uint p0, string memory p1, uint p2, address p3) internal view {
  586 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,address)", p0, p1, p2, p3));
  587 |     |     }
  588 |     | 
  589 |     |     function log(uint p0, string memory p1, string memory p2, uint p3) internal view {
  590 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,uint)", p0, p1, p2, p3));
  591 |     |     }
  592 |     | 
  593 |     |     function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {
  594 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,string)", p0, p1, p2, p3));
  595 |     |     }
  596 |     | 
  597 |     |     function log(uint p0, string memory p1, string memory p2, bool p3) internal view {
  598 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,bool)", p0, p1, p2, p3));
  599 |     |     }
  600 |     | 
  601 |     |     function log(uint p0, string memory p1, string memory p2, address p3) internal view {
  602 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,address)", p0, p1, p2, p3));
  603 |     |     }
  604 |     | 
  605 |     |     function log(uint p0, string memory p1, bool p2, uint p3) internal view {
  606 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,uint)", p0, p1, p2, p3));
  607 |     |     }
  608 |     | 
  609 |     |     function log(uint p0, string memory p1, bool p2, string memory p3) internal view {
  610 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,string)", p0, p1, p2, p3));
  611 |     |     }
  612 |     | 
  613 |     |     function log(uint p0, string memory p1, bool p2, bool p3) internal view {
  614 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,bool)", p0, p1, p2, p3));
  615 |     |     }
  616 |     | 
  617 |     |     function log(uint p0, string memory p1, bool p2, address p3) internal view {
  618 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,address)", p0, p1, p2, p3));
  619 |     |     }
  620 |     | 
  621 |     |     function log(uint p0, string memory p1, address p2, uint p3) internal view {
  622 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,uint)", p0, p1, p2, p3));
  623 |     |     }
  624 |     | 
  625 |     |     function log(uint p0, string memory p1, address p2, string memory p3) internal view {
  626 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,string)", p0, p1, p2, p3));
  627 |     |     }
  628 |     | 
  629 |     |     function log(uint p0, string memory p1, address p2, bool p3) internal view {
  630 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,bool)", p0, p1, p2, p3));
  631 |     |     }
  632 |     | 
  633 |     |     function log(uint p0, string memory p1, address p2, address p3) internal view {
  634 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,address)", p0, p1, p2, p3));
  635 |     |     }
  636 |     | 
  637 |     |     function log(uint p0, bool p1, uint p2, uint p3) internal view {
  638 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,uint)", p0, p1, p2, p3));
  639 |     |     }
  640 |     | 
  641 |     |     function log(uint p0, bool p1, uint p2, string memory p3) internal view {
  642 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,string)", p0, p1, p2, p3));
  643 |     |     }
  644 |     | 
  645 |     |     function log(uint p0, bool p1, uint p2, bool p3) internal view {
  646 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,bool)", p0, p1, p2, p3));
  647 |     |     }
  648 |     | 
  649 |     |     function log(uint p0, bool p1, uint p2, address p3) internal view {
  650 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,address)", p0, p1, p2, p3));
  651 |     |     }
  652 |     | 
  653 |     |     function log(uint p0, bool p1, string memory p2, uint p3) internal view {
  654 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,uint)", p0, p1, p2, p3));
  655 |     |     }
  656 |     | 
  657 |     |     function log(uint p0, bool p1, string memory p2, string memory p3) internal view {
  658 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,string)", p0, p1, p2, p3));
  659 |     |     }
  660 |     | 
  661 |     |     function log(uint p0, bool p1, string memory p2, bool p3) internal view {
  662 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,bool)", p0, p1, p2, p3));
  663 |     |     }
  664 |     | 
  665 |     |     function log(uint p0, bool p1, string memory p2, address p3) internal view {
  666 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,address)", p0, p1, p2, p3));
  667 |     |     }
  668 |     | 
  669 |     |     function log(uint p0, bool p1, bool p2, uint p3) internal view {
  670 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,uint)", p0, p1, p2, p3));
  671 |     |     }
  672 |     | 
  673 |     |     function log(uint p0, bool p1, bool p2, string memory p3) internal view {
  674 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,string)", p0, p1, p2, p3));
  675 |     |     }
  676 |     | 
  677 |     |     function log(uint p0, bool p1, bool p2, bool p3) internal view {
  678 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,bool)", p0, p1, p2, p3));
  679 |     |     }
  680 |     | 
  681 |     |     function log(uint p0, bool p1, bool p2, address p3) internal view {
  682 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,address)", p0, p1, p2, p3));
  683 |     |     }
  684 |     | 
  685 |     |     function log(uint p0, bool p1, address p2, uint p3) internal view {
  686 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,uint)", p0, p1, p2, p3));
  687 |     |     }
  688 |     | 
  689 |     |     function log(uint p0, bool p1, address p2, string memory p3) internal view {
  690 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,string)", p0, p1, p2, p3));
  691 |     |     }
  692 |     | 
  693 |     |     function log(uint p0, bool p1, address p2, bool p3) internal view {
  694 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,bool)", p0, p1, p2, p3));
  695 |     |     }
  696 |     | 
  697 |     |     function log(uint p0, bool p1, address p2, address p3) internal view {
  698 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,address)", p0, p1, p2, p3));
  699 |     |     }
  700 |     | 
  701 |     |     function log(uint p0, address p1, uint p2, uint p3) internal view {
  702 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,uint)", p0, p1, p2, p3));
  703 |     |     }
  704 |     | 
  705 |     |     function log(uint p0, address p1, uint p2, string memory p3) internal view {
  706 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,string)", p0, p1, p2, p3));
  707 |     |     }
  708 |     | 
  709 |     |     function log(uint p0, address p1, uint p2, bool p3) internal view {
  710 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,bool)", p0, p1, p2, p3));
  711 |     |     }
  712 |     | 
  713 |     |     function log(uint p0, address p1, uint p2, address p3) internal view {
  714 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,address)", p0, p1, p2, p3));
  715 |     |     }
  716 |     | 
  717 |     |     function log(uint p0, address p1, string memory p2, uint p3) internal view {
  718 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,uint)", p0, p1, p2, p3));
  719 |     |     }
  720 |     | 
  721 |     |     function log(uint p0, address p1, string memory p2, string memory p3) internal view {
  722 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,string)", p0, p1, p2, p3));
  723 |     |     }
  724 |     | 
  725 |     |     function log(uint p0, address p1, string memory p2, bool p3) internal view {
  726 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,bool)", p0, p1, p2, p3));
  727 |     |     }
  728 |     | 
  729 |     |     function log(uint p0, address p1, string memory p2, address p3) internal view {
  730 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,address)", p0, p1, p2, p3));
  731 |     |     }
  732 |     | 
  733 |     |     function log(uint p0, address p1, bool p2, uint p3) internal view {
  734 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,uint)", p0, p1, p2, p3));
  735 |     |     }
  736 |     | 
  737 |     |     function log(uint p0, address p1, bool p2, string memory p3) internal view {
  738 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,string)", p0, p1, p2, p3));
  739 |     |     }
  740 |     | 
  741 |     |     function log(uint p0, address p1, bool p2, bool p3) internal view {
  742 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,bool)", p0, p1, p2, p3));
  743 |     |     }
  744 |     | 
  745 |     |     function log(uint p0, address p1, bool p2, address p3) internal view {
  746 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,address)", p0, p1, p2, p3));
  747 |     |     }
  748 |     | 
  749 |     |     function log(uint p0, address p1, address p2, uint p3) internal view {
  750 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,uint)", p0, p1, p2, p3));
  751 |     |     }
  752 |     | 
  753 |     |     function log(uint p0, address p1, address p2, string memory p3) internal view {
  754 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,string)", p0, p1, p2, p3));
  755 |     |     }
  756 |     | 
  757 |     |     function log(uint p0, address p1, address p2, bool p3) internal view {
  758 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,bool)", p0, p1, p2, p3));
  759 |     |     }
  760 |     | 
  761 |     |     function log(uint p0, address p1, address p2, address p3) internal view {
  762 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,address)", p0, p1, p2, p3));
  763 |     |     }
  764 |     | 
  765 |     |     function log(string memory p0, uint p1, uint p2, uint p3) internal view {
  766 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,uint)", p0, p1, p2, p3));
  767 |     |     }
  768 |     | 
  769 |     |     function log(string memory p0, uint p1, uint p2, string memory p3) internal view {
  770 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,string)", p0, p1, p2, p3));
  771 |     |     }
  772 |     | 
  773 |     |     function log(string memory p0, uint p1, uint p2, bool p3) internal view {
  774 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,bool)", p0, p1, p2, p3));
  775 |     |     }
  776 |     | 
  777 |     |     function log(string memory p0, uint p1, uint p2, address p3) internal view {
  778 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,address)", p0, p1, p2, p3));
  779 |     |     }
  780 |     | 
  781 |     |     function log(string memory p0, uint p1, string memory p2, uint p3) internal view {
  782 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,uint)", p0, p1, p2, p3));
  783 |     |     }
  784 |     | 
  785 |     |     function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {
  786 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,string)", p0, p1, p2, p3));
  787 |     |     }
  788 |     | 
  789 |     |     function log(string memory p0, uint p1, string memory p2, bool p3) internal view {
  790 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,bool)", p0, p1, p2, p3));
  791 |     |     }
  792 |     | 
  793 |     |     function log(string memory p0, uint p1, string memory p2, address p3) internal view {
  794 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,address)", p0, p1, p2, p3));
  795 |     |     }
  796 |     | 
  797 |     |     function log(string memory p0, uint p1, bool p2, uint p3) internal view {
  798 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,uint)", p0, p1, p2, p3));
  799 |     |     }
  800 |     | 
  801 |     |     function log(string memory p0, uint p1, bool p2, string memory p3) internal view {
  802 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,string)", p0, p1, p2, p3));
  803 |     |     }
  804 |     | 
  805 |     |     function log(string memory p0, uint p1, bool p2, bool p3) internal view {
  806 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,bool)", p0, p1, p2, p3));
  807 |     |     }
  808 |     | 
  809 |     |     function log(string memory p0, uint p1, bool p2, address p3) internal view {
  810 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,address)", p0, p1, p2, p3));
  811 |     |     }
  812 |     | 
  813 |     |     function log(string memory p0, uint p1, address p2, uint p3) internal view {
  814 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,uint)", p0, p1, p2, p3));
  815 |     |     }
  816 |     | 
  817 |     |     function log(string memory p0, uint p1, address p2, string memory p3) internal view {
  818 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,string)", p0, p1, p2, p3));
  819 |     |     }
  820 |     | 
  821 |     |     function log(string memory p0, uint p1, address p2, bool p3) internal view {
  822 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,bool)", p0, p1, p2, p3));
  823 |     |     }
  824 |     | 
  825 |     |     function log(string memory p0, uint p1, address p2, address p3) internal view {
  826 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,address)", p0, p1, p2, p3));
  827 |     |     }
  828 |     | 
  829 |     |     function log(string memory p0, string memory p1, uint p2, uint p3) internal view {
  830 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,uint)", p0, p1, p2, p3));
  831 |     |     }
  832 |     | 
  833 |     |     function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {
  834 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,string)", p0, p1, p2, p3));
  835 |     |     }
  836 |     | 
  837 |     |     function log(string memory p0, string memory p1, uint p2, bool p3) internal view {
  838 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,bool)", p0, p1, p2, p3));
  839 |     |     }
  840 |     | 
  841 |     |     function log(string memory p0, string memory p1, uint p2, address p3) internal view {
  842 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,address)", p0, p1, p2, p3));
  843 |     |     }
  844 |     | 
  845 |     |     function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {
  846 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,uint)", p0, p1, p2, p3));
  847 |     |     }
  848 |     | 
  849 |     |     function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {
  850 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,string)", p0, p1, p2, p3));
  851 |     |     }
  852 |     | 
  853 |     |     function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {
  854 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,bool)", p0, p1, p2, p3));
  855 |     |     }
  856 |     | 
  857 |     |     function log(string memory p0, string memory p1, string memory p2, address p3) internal view {
  858 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,address)", p0, p1, p2, p3));
  859 |     |     }
  860 |     | 
  861 |     |     function log(string memory p0, string memory p1, bool p2, uint p3) internal view {
  862 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,uint)", p0, p1, p2, p3));
  863 |     |     }
  864 |     | 
  865 |     |     function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {
  866 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,string)", p0, p1, p2, p3));
  867 |     |     }
  868 |     | 
  869 |     |     function log(string memory p0, string memory p1, bool p2, bool p3) internal view {
  870 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,bool)", p0, p1, p2, p3));
  871 |     |     }
  872 |     | 
  873 |     |     function log(string memory p0, string memory p1, bool p2, address p3) internal view {
  874 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,address)", p0, p1, p2, p3));
  875 |     |     }
  876 |     | 
  877 |     |     function log(string memory p0, string memory p1, address p2, uint p3) internal view {
  878 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,uint)", p0, p1, p2, p3));
  879 |     |     }
  880 |     | 
  881 |     |     function log(string memory p0, string memory p1, address p2, string memory p3) internal view {
  882 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,string)", p0, p1, p2, p3));
  883 |     |     }
  884 |     | 
  885 |     |     function log(string memory p0, string memory p1, address p2, bool p3) internal view {
  886 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,bool)", p0, p1, p2, p3));
  887 |     |     }
  888 |     | 
  889 |     |     function log(string memory p0, string memory p1, address p2, address p3) internal view {
  890 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,address)", p0, p1, p2, p3));
  891 |     |     }
  892 |     | 
  893 |     |     function log(string memory p0, bool p1, uint p2, uint p3) internal view {
  894 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,uint)", p0, p1, p2, p3));
  895 |     |     }
  896 |     | 
  897 |     |     function log(string memory p0, bool p1, uint p2, string memory p3) internal view {
  898 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,string)", p0, p1, p2, p3));
  899 |     |     }
  900 |     | 
  901 |     |     function log(string memory p0, bool p1, uint p2, bool p3) internal view {
  902 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,bool)", p0, p1, p2, p3));
  903 |     |     }
  904 |     | 
  905 |     |     function log(string memory p0, bool p1, uint p2, address p3) internal view {
  906 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,address)", p0, p1, p2, p3));
  907 |     |     }
  908 |     | 
  909 |     |     function log(string memory p0, bool p1, string memory p2, uint p3) internal view {
  910 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,uint)", p0, p1, p2, p3));
  911 |     |     }
  912 |     | 
  913 |     |     function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {
  914 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,string)", p0, p1, p2, p3));
  915 |     |     }
  916 |     | 
  917 |     |     function log(string memory p0, bool p1, string memory p2, bool p3) internal view {
  918 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,bool)", p0, p1, p2, p3));
  919 |     |     }
  920 |     | 
  921 |     |     function log(string memory p0, bool p1, string memory p2, address p3) internal view {
  922 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,address)", p0, p1, p2, p3));
  923 |     |     }
  924 |     | 
  925 |     |     function log(string memory p0, bool p1, bool p2, uint p3) internal view {
  926 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,uint)", p0, p1, p2, p3));
  927 |     |     }
  928 |     | 
  929 |     |     function log(string memory p0, bool p1, bool p2, string memory p3) internal view {
  930 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,string)", p0, p1, p2, p3));
  931 |     |     }
  932 |     | 
  933 |     |     function log(string memory p0, bool p1, bool p2, bool p3) internal view {
  934 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,bool)", p0, p1, p2, p3));
  935 |     |     }
  936 |     | 
  937 |     |     function log(string memory p0, bool p1, bool p2, address p3) internal view {
  938 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,address)", p0, p1, p2, p3));
  939 |     |     }
  940 |     | 
  941 |     |     function log(string memory p0, bool p1, address p2, uint p3) internal view {
  942 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,uint)", p0, p1, p2, p3));
  943 |     |     }
  944 |     | 
  945 |     |     function log(string memory p0, bool p1, address p2, string memory p3) internal view {
  946 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,string)", p0, p1, p2, p3));
  947 |     |     }
  948 |     | 
  949 |     |     function log(string memory p0, bool p1, address p2, bool p3) internal view {
  950 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,bool)", p0, p1, p2, p3));
  951 |     |     }
  952 |     | 
  953 |     |     function log(string memory p0, bool p1, address p2, address p3) internal view {
  954 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,address)", p0, p1, p2, p3));
  955 |     |     }
  956 |     | 
  957 |     |     function log(string memory p0, address p1, uint p2, uint p3) internal view {
  958 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,uint)", p0, p1, p2, p3));
  959 |     |     }
  960 |     | 
  961 |     |     function log(string memory p0, address p1, uint p2, string memory p3) internal view {
  962 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,string)", p0, p1, p2, p3));
  963 |     |     }
  964 |     | 
  965 |     |     function log(string memory p0, address p1, uint p2, bool p3) internal view {
  966 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,bool)", p0, p1, p2, p3));
  967 |     |     }
  968 |     | 
  969 |     |     function log(string memory p0, address p1, uint p2, address p3) internal view {
  970 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,address)", p0, p1, p2, p3));
  971 |     |     }
  972 |     | 
  973 |     |     function log(string memory p0, address p1, string memory p2, uint p3) internal view {
  974 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,uint)", p0, p1, p2, p3));
  975 |     |     }
  976 |     | 
  977 |     |     function log(string memory p0, address p1, string memory p2, string memory p3) internal view {
  978 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,string)", p0, p1, p2, p3));
  979 |     |     }
  980 |     | 
  981 |     |     function log(string memory p0, address p1, string memory p2, bool p3) internal view {
  982 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,bool)", p0, p1, p2, p3));
  983 |     |     }
  984 |     | 
  985 |     |     function log(string memory p0, address p1, string memory p2, address p3) internal view {
  986 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,address)", p0, p1, p2, p3));
  987 |     |     }
  988 |     | 
  989 |     |     function log(string memory p0, address p1, bool p2, uint p3) internal view {
  990 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,uint)", p0, p1, p2, p3));
  991 |     |     }
  992 |     | 
  993 |     |     function log(string memory p0, address p1, bool p2, string memory p3) internal view {
  994 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,string)", p0, p1, p2, p3));
  995 |     |     }
  996 |     | 
  997 |     |     function log(string memory p0, address p1, bool p2, bool p3) internal view {
  998 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,bool)", p0, p1, p2, p3));
  999 |     |     }
 1000 |     | 
 1001 |     |     function log(string memory p0, address p1, bool p2, address p3) internal view {
 1002 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,address)", p0, p1, p2, p3));
 1003 |     |     }
 1004 |     | 
 1005 |     |     function log(string memory p0, address p1, address p2, uint p3) internal view {
 1006 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,uint)", p0, p1, p2, p3));
 1007 |     |     }
 1008 |     | 
 1009 |     |     function log(string memory p0, address p1, address p2, string memory p3) internal view {
 1010 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,string)", p0, p1, p2, p3));
 1011 |     |     }
 1012 |     | 
 1013 |     |     function log(string memory p0, address p1, address p2, bool p3) internal view {
 1014 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,bool)", p0, p1, p2, p3));
 1015 |     |     }
 1016 |     | 
 1017 |     |     function log(string memory p0, address p1, address p2, address p3) internal view {
 1018 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,address)", p0, p1, p2, p3));
 1019 |     |     }
 1020 |     | 
 1021 |     |     function log(bool p0, uint p1, uint p2, uint p3) internal view {
 1022 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,uint)", p0, p1, p2, p3));
 1023 |     |     }
 1024 |     | 
 1025 |     |     function log(bool p0, uint p1, uint p2, string memory p3) internal view {
 1026 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,string)", p0, p1, p2, p3));
 1027 |     |     }
 1028 |     | 
 1029 |     |     function log(bool p0, uint p1, uint p2, bool p3) internal view {
 1030 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,bool)", p0, p1, p2, p3));
 1031 |     |     }
 1032 |     | 
 1033 |     |     function log(bool p0, uint p1, uint p2, address p3) internal view {
 1034 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,address)", p0, p1, p2, p3));
 1035 |     |     }
 1036 |     | 
 1037 |     |     function log(bool p0, uint p1, string memory p2, uint p3) internal view {
 1038 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,uint)", p0, p1, p2, p3));
 1039 |     |     }
 1040 |     | 
 1041 |     |     function log(bool p0, uint p1, string memory p2, string memory p3) internal view {
 1042 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,string)", p0, p1, p2, p3));
 1043 |     |     }
 1044 |     | 
 1045 |     |     function log(bool p0, uint p1, string memory p2, bool p3) internal view {
 1046 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,bool)", p0, p1, p2, p3));
 1047 |     |     }
 1048 |     | 
 1049 |     |     function log(bool p0, uint p1, string memory p2, address p3) internal view {
 1050 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,address)", p0, p1, p2, p3));
 1051 |     |     }
 1052 |     | 
 1053 |     |     function log(bool p0, uint p1, bool p2, uint p3) internal view {
 1054 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,uint)", p0, p1, p2, p3));
 1055 |     |     }
 1056 |     | 
 1057 |     |     function log(bool p0, uint p1, bool p2, string memory p3) internal view {
 1058 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,string)", p0, p1, p2, p3));
 1059 |     |     }
 1060 |     | 
 1061 |     |     function log(bool p0, uint p1, bool p2, bool p3) internal view {
 1062 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,bool)", p0, p1, p2, p3));
 1063 |     |     }
 1064 |     | 
 1065 |     |     function log(bool p0, uint p1, bool p2, address p3) internal view {
 1066 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,address)", p0, p1, p2, p3));
 1067 |     |     }
 1068 |     | 
 1069 |     |     function log(bool p0, uint p1, address p2, uint p3) internal view {
 1070 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,uint)", p0, p1, p2, p3));
 1071 |     |     }
 1072 |     | 
 1073 |     |     function log(bool p0, uint p1, address p2, string memory p3) internal view {
 1074 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,string)", p0, p1, p2, p3));
 1075 |     |     }
 1076 |     | 
 1077 |     |     function log(bool p0, uint p1, address p2, bool p3) internal view {
 1078 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,bool)", p0, p1, p2, p3));
 1079 |     |     }
 1080 |     | 
 1081 |     |     function log(bool p0, uint p1, address p2, address p3) internal view {
 1082 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,address)", p0, p1, p2, p3));
 1083 |     |     }
 1084 |     | 
 1085 |     |     function log(bool p0, string memory p1, uint p2, uint p3) internal view {
 1086 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,uint)", p0, p1, p2, p3));
 1087 |     |     }
 1088 |     | 
 1089 |     |     function log(bool p0, string memory p1, uint p2, string memory p3) internal view {
 1090 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,string)", p0, p1, p2, p3));
 1091 |     |     }
 1092 |     | 
 1093 |     |     function log(bool p0, string memory p1, uint p2, bool p3) internal view {
 1094 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,bool)", p0, p1, p2, p3));
 1095 |     |     }
 1096 |     | 
 1097 |     |     function log(bool p0, string memory p1, uint p2, address p3) internal view {
 1098 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,address)", p0, p1, p2, p3));
 1099 |     |     }
 1100 |     | 
 1101 |     |     function log(bool p0, string memory p1, string memory p2, uint p3) internal view {
 1102 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,uint)", p0, p1, p2, p3));
 1103 |     |     }
 1104 |     | 
 1105 |     |     function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {
 1106 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,string)", p0, p1, p2, p3));
 1107 |     |     }
 1108 |     | 
 1109 |     |     function log(bool p0, string memory p1, string memory p2, bool p3) internal view {
 1110 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,bool)", p0, p1, p2, p3));
 1111 |     |     }
 1112 |     | 
 1113 |     |     function log(bool p0, string memory p1, string memory p2, address p3) internal view {
 1114 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,address)", p0, p1, p2, p3));
 1115 |     |     }
 1116 |     | 
 1117 |     |     function log(bool p0, string memory p1, bool p2, uint p3) internal view {
 1118 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,uint)", p0, p1, p2, p3));
 1119 |     |     }
 1120 |     | 
 1121 |     |     function log(bool p0, string memory p1, bool p2, string memory p3) internal view {
 1122 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,string)", p0, p1, p2, p3));
 1123 |     |     }
 1124 |     | 
 1125 |     |     function log(bool p0, string memory p1, bool p2, bool p3) internal view {
 1126 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,bool)", p0, p1, p2, p3));
 1127 |     |     }
 1128 |     | 
 1129 |     |     function log(bool p0, string memory p1, bool p2, address p3) internal view {
 1130 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,address)", p0, p1, p2, p3));
 1131 |     |     }
 1132 |     | 
 1133 |     |     function log(bool p0, string memory p1, address p2, uint p3) internal view {
 1134 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,uint)", p0, p1, p2, p3));
 1135 |     |     }
 1136 |     | 
 1137 |     |     function log(bool p0, string memory p1, address p2, string memory p3) internal view {
 1138 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,string)", p0, p1, p2, p3));
 1139 |     |     }
 1140 |     | 
 1141 |     |     function log(bool p0, string memory p1, address p2, bool p3) internal view {
 1142 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,bool)", p0, p1, p2, p3));
 1143 |     |     }
 1144 |     | 
 1145 |     |     function log(bool p0, string memory p1, address p2, address p3) internal view {
 1146 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,address)", p0, p1, p2, p3));
 1147 |     |     }
 1148 |     | 
 1149 |     |     function log(bool p0, bool p1, uint p2, uint p3) internal view {
 1150 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,uint)", p0, p1, p2, p3));
 1151 |     |     }
 1152 |     | 
 1153 |     |     function log(bool p0, bool p1, uint p2, string memory p3) internal view {
 1154 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,string)", p0, p1, p2, p3));
 1155 |     |     }
 1156 |     | 
 1157 |     |     function log(bool p0, bool p1, uint p2, bool p3) internal view {
 1158 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,bool)", p0, p1, p2, p3));
 1159 |     |     }
 1160 |     | 
 1161 |     |     function log(bool p0, bool p1, uint p2, address p3) internal view {
 1162 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,address)", p0, p1, p2, p3));
 1163 |     |     }
 1164 |     | 
 1165 |     |     function log(bool p0, bool p1, string memory p2, uint p3) internal view {
 1166 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,uint)", p0, p1, p2, p3));
 1167 |     |     }
 1168 |     | 
 1169 |     |     function log(bool p0, bool p1, string memory p2, string memory p3) internal view {
 1170 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,string)", p0, p1, p2, p3));
 1171 |     |     }
 1172 |     | 
 1173 |     |     function log(bool p0, bool p1, string memory p2, bool p3) internal view {
 1174 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,bool)", p0, p1, p2, p3));
 1175 |     |     }
 1176 |     | 
 1177 |     |     function log(bool p0, bool p1, string memory p2, address p3) internal view {
 1178 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,address)", p0, p1, p2, p3));
 1179 |     |     }
 1180 |     | 
 1181 |     |     function log(bool p0, bool p1, bool p2, uint p3) internal view {
 1182 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,uint)", p0, p1, p2, p3));
 1183 |     |     }
 1184 |     | 
 1185 |     |     function log(bool p0, bool p1, bool p2, string memory p3) internal view {
 1186 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,string)", p0, p1, p2, p3));
 1187 |     |     }
 1188 |     | 
 1189 |     |     function log(bool p0, bool p1, bool p2, bool p3) internal view {
 1190 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,bool)", p0, p1, p2, p3));
 1191 |     |     }
 1192 |     | 
 1193 |     |     function log(bool p0, bool p1, bool p2, address p3) internal view {
 1194 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,address)", p0, p1, p2, p3));
 1195 |     |     }
 1196 |     | 
 1197 |     |     function log(bool p0, bool p1, address p2, uint p3) internal view {
 1198 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,uint)", p0, p1, p2, p3));
 1199 |     |     }
 1200 |     | 
 1201 |     |     function log(bool p0, bool p1, address p2, string memory p3) internal view {
 1202 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,string)", p0, p1, p2, p3));
 1203 |     |     }
 1204 |     | 
 1205 |     |     function log(bool p0, bool p1, address p2, bool p3) internal view {
 1206 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,bool)", p0, p1, p2, p3));
 1207 |     |     }
 1208 |     | 
 1209 |     |     function log(bool p0, bool p1, address p2, address p3) internal view {
 1210 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,address)", p0, p1, p2, p3));
 1211 |     |     }
 1212 |     | 
 1213 |     |     function log(bool p0, address p1, uint p2, uint p3) internal view {
 1214 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,uint)", p0, p1, p2, p3));
 1215 |     |     }
 1216 |     | 
 1217 |     |     function log(bool p0, address p1, uint p2, string memory p3) internal view {
 1218 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,string)", p0, p1, p2, p3));
 1219 |     |     }
 1220 |     | 
 1221 |     |     function log(bool p0, address p1, uint p2, bool p3) internal view {
 1222 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,bool)", p0, p1, p2, p3));
 1223 |     |     }
 1224 |     | 
 1225 |     |     function log(bool p0, address p1, uint p2, address p3) internal view {
 1226 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,address)", p0, p1, p2, p3));
 1227 |     |     }
 1228 |     | 
 1229 |     |     function log(bool p0, address p1, string memory p2, uint p3) internal view {
 1230 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,uint)", p0, p1, p2, p3));
 1231 |     |     }
 1232 |     | 
 1233 |     |     function log(bool p0, address p1, string memory p2, string memory p3) internal view {
 1234 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,string)", p0, p1, p2, p3));
 1235 |     |     }
 1236 |     | 
 1237 |     |     function log(bool p0, address p1, string memory p2, bool p3) internal view {
 1238 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,bool)", p0, p1, p2, p3));
 1239 |     |     }
 1240 |     | 
 1241 |     |     function log(bool p0, address p1, string memory p2, address p3) internal view {
 1242 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,address)", p0, p1, p2, p3));
 1243 |     |     }
 1244 |     | 
 1245 |     |     function log(bool p0, address p1, bool p2, uint p3) internal view {
 1246 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,uint)", p0, p1, p2, p3));
 1247 |     |     }
 1248 |     | 
 1249 |     |     function log(bool p0, address p1, bool p2, string memory p3) internal view {
 1250 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,string)", p0, p1, p2, p3));
 1251 |     |     }
 1252 |     | 
 1253 |     |     function log(bool p0, address p1, bool p2, bool p3) internal view {
 1254 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,bool)", p0, p1, p2, p3));
 1255 |     |     }
 1256 |     | 
 1257 |     |     function log(bool p0, address p1, bool p2, address p3) internal view {
 1258 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,address)", p0, p1, p2, p3));
 1259 |     |     }
 1260 |     | 
 1261 |     |     function log(bool p0, address p1, address p2, uint p3) internal view {
 1262 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,uint)", p0, p1, p2, p3));
 1263 |     |     }
 1264 |     | 
 1265 |     |     function log(bool p0, address p1, address p2, string memory p3) internal view {
 1266 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,string)", p0, p1, p2, p3));
 1267 |     |     }
 1268 |     | 
 1269 |     |     function log(bool p0, address p1, address p2, bool p3) internal view {
 1270 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,bool)", p0, p1, p2, p3));
 1271 |     |     }
 1272 |     | 
 1273 |     |     function log(bool p0, address p1, address p2, address p3) internal view {
 1274 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,address)", p0, p1, p2, p3));
 1275 |     |     }
 1276 |     | 
 1277 |     |     function log(address p0, uint p1, uint p2, uint p3) internal view {
 1278 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,uint)", p0, p1, p2, p3));
 1279 |     |     }
 1280 |     | 
 1281 |     |     function log(address p0, uint p1, uint p2, string memory p3) internal view {
 1282 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,string)", p0, p1, p2, p3));
 1283 |     |     }
 1284 |     | 
 1285 |     |     function log(address p0, uint p1, uint p2, bool p3) internal view {
 1286 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,bool)", p0, p1, p2, p3));
 1287 |     |     }
 1288 |     | 
 1289 |     |     function log(address p0, uint p1, uint p2, address p3) internal view {
 1290 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,address)", p0, p1, p2, p3));
 1291 |     |     }
 1292 |     | 
 1293 |     |     function log(address p0, uint p1, string memory p2, uint p3) internal view {
 1294 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,uint)", p0, p1, p2, p3));
 1295 |     |     }
 1296 |     | 
 1297 |     |     function log(address p0, uint p1, string memory p2, string memory p3) internal view {
 1298 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,string)", p0, p1, p2, p3));
 1299 |     |     }
 1300 |     | 
 1301 |     |     function log(address p0, uint p1, string memory p2, bool p3) internal view {
 1302 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,bool)", p0, p1, p2, p3));
 1303 |     |     }
 1304 |     | 
 1305 |     |     function log(address p0, uint p1, string memory p2, address p3) internal view {
 1306 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,address)", p0, p1, p2, p3));
 1307 |     |     }
 1308 |     | 
 1309 |     |     function log(address p0, uint p1, bool p2, uint p3) internal view {
 1310 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,uint)", p0, p1, p2, p3));
 1311 |     |     }
 1312 |     | 
 1313 |     |     function log(address p0, uint p1, bool p2, string memory p3) internal view {
 1314 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,string)", p0, p1, p2, p3));
 1315 |     |     }
 1316 |     | 
 1317 |     |     function log(address p0, uint p1, bool p2, bool p3) internal view {
 1318 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,bool)", p0, p1, p2, p3));
 1319 |     |     }
 1320 |     | 
 1321 |     |     function log(address p0, uint p1, bool p2, address p3) internal view {
 1322 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,address)", p0, p1, p2, p3));
 1323 |     |     }
 1324 |     | 
 1325 |     |     function log(address p0, uint p1, address p2, uint p3) internal view {
 1326 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,uint)", p0, p1, p2, p3));
 1327 |     |     }
 1328 |     | 
 1329 |     |     function log(address p0, uint p1, address p2, string memory p3) internal view {
 1330 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,string)", p0, p1, p2, p3));
 1331 |     |     }
 1332 |     | 
 1333 |     |     function log(address p0, uint p1, address p2, bool p3) internal view {
 1334 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,bool)", p0, p1, p2, p3));
 1335 |     |     }
 1336 |     | 
 1337 |     |     function log(address p0, uint p1, address p2, address p3) internal view {
 1338 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,address)", p0, p1, p2, p3));
 1339 |     |     }
 1340 |     | 
 1341 |     |     function log(address p0, string memory p1, uint p2, uint p3) internal view {
 1342 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,uint)", p0, p1, p2, p3));
 1343 |     |     }
 1344 |     | 
 1345 |     |     function log(address p0, string memory p1, uint p2, string memory p3) internal view {
 1346 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,string)", p0, p1, p2, p3));
 1347 |     |     }
 1348 |     | 
 1349 |     |     function log(address p0, string memory p1, uint p2, bool p3) internal view {
 1350 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,bool)", p0, p1, p2, p3));
 1351 |     |     }
 1352 |     | 
 1353 |     |     function log(address p0, string memory p1, uint p2, address p3) internal view {
 1354 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,address)", p0, p1, p2, p3));
 1355 |     |     }
 1356 |     | 
 1357 |     |     function log(address p0, string memory p1, string memory p2, uint p3) internal view {
 1358 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,uint)", p0, p1, p2, p3));
 1359 |     |     }
 1360 |     | 
 1361 |     |     function log(address p0, string memory p1, string memory p2, string memory p3) internal view {
 1362 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,string)", p0, p1, p2, p3));
 1363 |     |     }
 1364 |     | 
 1365 |     |     function log(address p0, string memory p1, string memory p2, bool p3) internal view {
 1366 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,bool)", p0, p1, p2, p3));
 1367 |     |     }
 1368 |     | 
 1369 |     |     function log(address p0, string memory p1, string memory p2, address p3) internal view {
 1370 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,address)", p0, p1, p2, p3));
 1371 |     |     }
 1372 |     | 
 1373 |     |     function log(address p0, string memory p1, bool p2, uint p3) internal view {
 1374 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,uint)", p0, p1, p2, p3));
 1375 |     |     }
 1376 |     | 
 1377 |     |     function log(address p0, string memory p1, bool p2, string memory p3) internal view {
 1378 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,string)", p0, p1, p2, p3));
 1379 |     |     }
 1380 |     | 
 1381 |     |     function log(address p0, string memory p1, bool p2, bool p3) internal view {
 1382 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,bool)", p0, p1, p2, p3));
 1383 |     |     }
 1384 |     | 
 1385 |     |     function log(address p0, string memory p1, bool p2, address p3) internal view {
 1386 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,address)", p0, p1, p2, p3));
 1387 |     |     }
 1388 |     | 
 1389 |     |     function log(address p0, string memory p1, address p2, uint p3) internal view {
 1390 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,uint)", p0, p1, p2, p3));
 1391 |     |     }
 1392 |     | 
 1393 |     |     function log(address p0, string memory p1, address p2, string memory p3) internal view {
 1394 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,string)", p0, p1, p2, p3));
 1395 |     |     }
 1396 |     | 
 1397 |     |     function log(address p0, string memory p1, address p2, bool p3) internal view {
 1398 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,bool)", p0, p1, p2, p3));
 1399 |     |     }
 1400 |     | 
 1401 |     |     function log(address p0, string memory p1, address p2, address p3) internal view {
 1402 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,address)", p0, p1, p2, p3));
 1403 |     |     }
 1404 |     | 
 1405 |     |     function log(address p0, bool p1, uint p2, uint p3) internal view {
 1406 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,uint)", p0, p1, p2, p3));
 1407 |     |     }
 1408 |     | 
 1409 |     |     function log(address p0, bool p1, uint p2, string memory p3) internal view {
 1410 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,string)", p0, p1, p2, p3));
 1411 |     |     }
 1412 |     | 
 1413 |     |     function log(address p0, bool p1, uint p2, bool p3) internal view {
 1414 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,bool)", p0, p1, p2, p3));
 1415 |     |     }
 1416 |     | 
 1417 |     |     function log(address p0, bool p1, uint p2, address p3) internal view {
 1418 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,address)", p0, p1, p2, p3));
 1419 |     |     }
 1420 |     | 
 1421 |     |     function log(address p0, bool p1, string memory p2, uint p3) internal view {
 1422 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,uint)", p0, p1, p2, p3));
 1423 |     |     }
 1424 |     | 
 1425 |     |     function log(address p0, bool p1, string memory p2, string memory p3) internal view {
 1426 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,string)", p0, p1, p2, p3));
 1427 |     |     }
 1428 |     | 
 1429 |     |     function log(address p0, bool p1, string memory p2, bool p3) internal view {
 1430 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,bool)", p0, p1, p2, p3));
 1431 |     |     }
 1432 |     | 
 1433 |     |     function log(address p0, bool p1, string memory p2, address p3) internal view {
 1434 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,address)", p0, p1, p2, p3));
 1435 |     |     }
 1436 |     | 
 1437 |     |     function log(address p0, bool p1, bool p2, uint p3) internal view {
 1438 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,uint)", p0, p1, p2, p3));
 1439 |     |     }
 1440 |     | 
 1441 |     |     function log(address p0, bool p1, bool p2, string memory p3) internal view {
 1442 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,string)", p0, p1, p2, p3));
 1443 |     |     }
 1444 |     | 
 1445 |     |     function log(address p0, bool p1, bool p2, bool p3) internal view {
 1446 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,bool)", p0, p1, p2, p3));
 1447 |     |     }
 1448 |     | 
 1449 |     |     function log(address p0, bool p1, bool p2, address p3) internal view {
 1450 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,address)", p0, p1, p2, p3));
 1451 |     |     }
 1452 |     | 
 1453 |     |     function log(address p0, bool p1, address p2, uint p3) internal view {
 1454 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,uint)", p0, p1, p2, p3));
 1455 |     |     }
 1456 |     | 
 1457 |     |     function log(address p0, bool p1, address p2, string memory p3) internal view {
 1458 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,string)", p0, p1, p2, p3));
 1459 |     |     }
 1460 |     | 
 1461 |     |     function log(address p0, bool p1, address p2, bool p3) internal view {
 1462 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,bool)", p0, p1, p2, p3));
 1463 |     |     }
 1464 |     | 
 1465 |     |     function log(address p0, bool p1, address p2, address p3) internal view {
 1466 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,address)", p0, p1, p2, p3));
 1467 |     |     }
 1468 |     | 
 1469 |     |     function log(address p0, address p1, uint p2, uint p3) internal view {
 1470 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,uint)", p0, p1, p2, p3));
 1471 |     |     }
 1472 |     | 
 1473 |     |     function log(address p0, address p1, uint p2, string memory p3) internal view {
 1474 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,string)", p0, p1, p2, p3));
 1475 |     |     }
 1476 |     | 
 1477 |     |     function log(address p0, address p1, uint p2, bool p3) internal view {
 1478 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,bool)", p0, p1, p2, p3));
 1479 |     |     }
 1480 |     | 
 1481 |     |     function log(address p0, address p1, uint p2, address p3) internal view {
 1482 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,address)", p0, p1, p2, p3));
 1483 |     |     }
 1484 |     | 
 1485 |     |     function log(address p0, address p1, string memory p2, uint p3) internal view {
 1486 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,uint)", p0, p1, p2, p3));
 1487 |     |     }
 1488 |     | 
 1489 |     |     function log(address p0, address p1, string memory p2, string memory p3) internal view {
 1490 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,string)", p0, p1, p2, p3));
 1491 |     |     }
 1492 |     | 
 1493 |     |     function log(address p0, address p1, string memory p2, bool p3) internal view {
 1494 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,bool)", p0, p1, p2, p3));
 1495 |     |     }
 1496 |     | 
 1497 |     |     function log(address p0, address p1, string memory p2, address p3) internal view {
 1498 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,address)", p0, p1, p2, p3));
 1499 |     |     }
 1500 |     | 
 1501 |     |     function log(address p0, address p1, bool p2, uint p3) internal view {
 1502 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,uint)", p0, p1, p2, p3));
 1503 |     |     }
 1504 |     | 
 1505 |     |     function log(address p0, address p1, bool p2, string memory p3) internal view {
 1506 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,string)", p0, p1, p2, p3));
 1507 |     |     }
 1508 |     | 
 1509 |     |     function log(address p0, address p1, bool p2, bool p3) internal view {
 1510 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,bool)", p0, p1, p2, p3));
 1511 |     |     }
 1512 |     | 
 1513 |     |     function log(address p0, address p1, bool p2, address p3) internal view {
 1514 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,address)", p0, p1, p2, p3));
 1515 |     |     }
 1516 |     | 
 1517 |     |     function log(address p0, address p1, address p2, uint p3) internal view {
 1518 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,uint)", p0, p1, p2, p3));
 1519 |     |     }
 1520 |     | 
 1521 |     |     function log(address p0, address p1, address p2, string memory p3) internal view {
 1522 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,string)", p0, p1, p2, p3));
 1523 |     |     }
 1524 |     | 
 1525 |     |     function log(address p0, address p1, address p2, bool p3) internal view {
 1526 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,bool)", p0, p1, p2, p3));
 1527 |     |     }
 1528 |     | 
 1529 |     |     function log(address p0, address p1, address p2, address p3) internal view {
 1530 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,address)", p0, p1, p2, p3));
 1531 |     |     }
 1532 |     | 
 1533 |     | }

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/forge-std/src/console2.sol
    1 |     | // SPDX-License-Identifier: MIT
    2 |     | pragma solidity >=0.4.22 <0.9.0;
    3 |     | 
    4 |     | /// @dev The original console.sol uses `int` and `uint` for computing function selectors, but it should
    5 |     | /// use `int256` and `uint256`. This modified version fixes that. This version is recommended
    6 |     | /// over `console.sol` if you don't need compatibility with Hardhat as the logs will show up in
    7 |     | /// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.
    8 |     | /// Reference: https://github.com/NomicFoundation/hardhat/issues/2178
    9 |     | library console2 {
   10 |     |     address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);
   11 |     | 
   12 |     |     function _sendLogPayload(bytes memory payload) private view {
   13 |     |         uint256 payloadLength = payload.length;
   14 |     |         address consoleAddress = CONSOLE_ADDRESS;
   15 |     |         /// @solidity memory-safe-assembly
   16 |     |         assembly {
   17 |     |             let payloadStart := add(payload, 32)
   18 |     |             let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)
   19 |     |         }
   20 |     |     }
   21 |     | 
   22 |     |     function log() internal view {
   23 |     |         _sendLogPayload(abi.encodeWithSignature("log()"));
   24 |     |     }
   25 |     | 
   26 |     |     function logInt(int256 p0) internal view {
   27 |     |         _sendLogPayload(abi.encodeWithSignature("log(int256)", p0));
   28 |     |     }
   29 |     | 
   30 |     |     function logUint(uint256 p0) internal view {
   31 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256)", p0));
   32 |     |     }
   33 |     | 
   34 |     |     function logString(string memory p0) internal view {
   35 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
   36 |     |     }
   37 |     | 
   38 |     |     function logBool(bool p0) internal view {
   39 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
   40 |     |     }
   41 |     | 
   42 |     |     function logAddress(address p0) internal view {
   43 |     |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
   44 |     |     }
   45 |     | 
   46 |     |     function logBytes(bytes memory p0) internal view {
   47 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes)", p0));
   48 |     |     }
   49 |     | 
   50 |     |     function logBytes1(bytes1 p0) internal view {
   51 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes1)", p0));
   52 |     |     }
   53 |     | 
   54 |     |     function logBytes2(bytes2 p0) internal view {
   55 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes2)", p0));
   56 |     |     }
   57 |     | 
   58 |     |     function logBytes3(bytes3 p0) internal view {
   59 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes3)", p0));
   60 |     |     }
   61 |     | 
   62 |     |     function logBytes4(bytes4 p0) internal view {
   63 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes4)", p0));
   64 |     |     }
   65 |     | 
   66 |     |     function logBytes5(bytes5 p0) internal view {
   67 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes5)", p0));
   68 |     |     }
   69 |     | 
   70 |     |     function logBytes6(bytes6 p0) internal view {
   71 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes6)", p0));
   72 |     |     }
   73 |     | 
   74 |     |     function logBytes7(bytes7 p0) internal view {
   75 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes7)", p0));
   76 |     |     }
   77 |     | 
   78 |     |     function logBytes8(bytes8 p0) internal view {
   79 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes8)", p0));
   80 |     |     }
   81 |     | 
   82 |     |     function logBytes9(bytes9 p0) internal view {
   83 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes9)", p0));
   84 |     |     }
   85 |     | 
   86 |     |     function logBytes10(bytes10 p0) internal view {
   87 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes10)", p0));
   88 |     |     }
   89 |     | 
   90 |     |     function logBytes11(bytes11 p0) internal view {
   91 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes11)", p0));
   92 |     |     }
   93 |     | 
   94 |     |     function logBytes12(bytes12 p0) internal view {
   95 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes12)", p0));
   96 |     |     }
   97 |     | 
   98 |     |     function logBytes13(bytes13 p0) internal view {
   99 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes13)", p0));
  100 |     |     }
  101 |     | 
  102 |     |     function logBytes14(bytes14 p0) internal view {
  103 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes14)", p0));
  104 |     |     }
  105 |     | 
  106 |     |     function logBytes15(bytes15 p0) internal view {
  107 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes15)", p0));
  108 |     |     }
  109 |     | 
  110 |     |     function logBytes16(bytes16 p0) internal view {
  111 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes16)", p0));
  112 |     |     }
  113 |     | 
  114 |     |     function logBytes17(bytes17 p0) internal view {
  115 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes17)", p0));
  116 |     |     }
  117 |     | 
  118 |     |     function logBytes18(bytes18 p0) internal view {
  119 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes18)", p0));
  120 |     |     }
  121 |     | 
  122 |     |     function logBytes19(bytes19 p0) internal view {
  123 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes19)", p0));
  124 |     |     }
  125 |     | 
  126 |     |     function logBytes20(bytes20 p0) internal view {
  127 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes20)", p0));
  128 |     |     }
  129 |     | 
  130 |     |     function logBytes21(bytes21 p0) internal view {
  131 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes21)", p0));
  132 |     |     }
  133 |     | 
  134 |     |     function logBytes22(bytes22 p0) internal view {
  135 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes22)", p0));
  136 |     |     }
  137 |     | 
  138 |     |     function logBytes23(bytes23 p0) internal view {
  139 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes23)", p0));
  140 |     |     }
  141 |     | 
  142 |     |     function logBytes24(bytes24 p0) internal view {
  143 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes24)", p0));
  144 |     |     }
  145 |     | 
  146 |     |     function logBytes25(bytes25 p0) internal view {
  147 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes25)", p0));
  148 |     |     }
  149 |     | 
  150 |     |     function logBytes26(bytes26 p0) internal view {
  151 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes26)", p0));
  152 |     |     }
  153 |     | 
  154 |     |     function logBytes27(bytes27 p0) internal view {
  155 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes27)", p0));
  156 |     |     }
  157 |     | 
  158 |     |     function logBytes28(bytes28 p0) internal view {
  159 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes28)", p0));
  160 |     |     }
  161 |     | 
  162 |     |     function logBytes29(bytes29 p0) internal view {
  163 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes29)", p0));
  164 |     |     }
  165 |     | 
  166 |     |     function logBytes30(bytes30 p0) internal view {
  167 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes30)", p0));
  168 |     |     }
  169 |     | 
  170 |     |     function logBytes31(bytes31 p0) internal view {
  171 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes31)", p0));
  172 |     |     }
  173 |     | 
  174 |     |     function logBytes32(bytes32 p0) internal view {
  175 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes32)", p0));
  176 |     |     }
  177 |     | 
  178 |     |     function log(uint256 p0) internal view {
  179 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256)", p0));
  180 |     |     }
  181 |     | 
  182 |     |     function log(int256 p0) internal view {
  183 |     |         _sendLogPayload(abi.encodeWithSignature("log(int256)", p0));
  184 |     |     }
  185 |     | 
  186 |     |     function log(string memory p0) internal view {
  187 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
  188 |     |     }
  189 |     | 
  190 |     |     function log(bool p0) internal view {
  191 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
  192 |     |     }
  193 |     | 
  194 |     |     function log(address p0) internal view {
  195 |     |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
  196 |     |     }
  197 |     | 
  198 |     |     function log(uint256 p0, uint256 p1) internal view {
  199 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256)", p0, p1));
  200 |     |     }
  201 |     | 
  202 |     |     function log(uint256 p0, string memory p1) internal view {
  203 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string)", p0, p1));
  204 |     |     }
  205 |     | 
  206 |     |     function log(uint256 p0, bool p1) internal view {
  207 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool)", p0, p1));
  208 |     |     }
  209 |     | 
  210 |     |     function log(uint256 p0, address p1) internal view {
  211 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address)", p0, p1));
  212 |     |     }
  213 |     | 
  214 |     |     function log(string memory p0, uint256 p1) internal view {
  215 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256)", p0, p1));
  216 |     |     }
  217 |     | 
  218 |     |     function log(string memory p0, int256 p1) internal view {
  219 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,int256)", p0, p1));
  220 |     |     }
  221 |     | 
  222 |     |     function log(string memory p0, string memory p1) internal view {
  223 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
  224 |     |     }
  225 |     | 
  226 |     |     function log(string memory p0, bool p1) internal view {
  227 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool)", p0, p1));
  228 |     |     }
  229 |     | 
  230 |     |     function log(string memory p0, address p1) internal view {
  231 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address)", p0, p1));
  232 |     |     }
  233 |     | 
  234 |     |     function log(bool p0, uint256 p1) internal view {
  235 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256)", p0, p1));
  236 |     |     }
  237 |     | 
  238 |     |     function log(bool p0, string memory p1) internal view {
  239 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string)", p0, p1));
  240 |     |     }
  241 |     | 
  242 |     |     function log(bool p0, bool p1) internal view {
  243 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool)", p0, p1));
  244 |     |     }
  245 |     | 
  246 |     |     function log(bool p0, address p1) internal view {
  247 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address)", p0, p1));
  248 |     |     }
  249 |     | 
  250 |     |     function log(address p0, uint256 p1) internal view {
  251 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256)", p0, p1));
  252 |     |     }
  253 |     | 
  254 |     |     function log(address p0, string memory p1) internal view {
  255 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string)", p0, p1));
  256 |     |     }
  257 |     | 
  258 |     |     function log(address p0, bool p1) internal view {
  259 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool)", p0, p1));
  260 |     |     }
  261 |     | 
  262 |     |     function log(address p0, address p1) internal view {
  263 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address)", p0, p1));
  264 |     |     }
  265 |     | 
  266 |     |     function log(uint256 p0, uint256 p1, uint256 p2) internal view {
  267 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256)", p0, p1, p2));
  268 |     |     }
  269 |     | 
  270 |     |     function log(uint256 p0, uint256 p1, string memory p2) internal view {
  271 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string)", p0, p1, p2));
  272 |     |     }
  273 |     | 
  274 |     |     function log(uint256 p0, uint256 p1, bool p2) internal view {
  275 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool)", p0, p1, p2));
  276 |     |     }
  277 |     | 
  278 |     |     function log(uint256 p0, uint256 p1, address p2) internal view {
  279 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address)", p0, p1, p2));
  280 |     |     }
  281 |     | 
  282 |     |     function log(uint256 p0, string memory p1, uint256 p2) internal view {
  283 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256)", p0, p1, p2));
  284 |     |     }
  285 |     | 
  286 |     |     function log(uint256 p0, string memory p1, string memory p2) internal view {
  287 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string)", p0, p1, p2));
  288 |     |     }
  289 |     | 
  290 |     |     function log(uint256 p0, string memory p1, bool p2) internal view {
  291 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool)", p0, p1, p2));
  292 |     |     }
  293 |     | 
  294 |     |     function log(uint256 p0, string memory p1, address p2) internal view {
  295 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address)", p0, p1, p2));
  296 |     |     }
  297 |     | 
  298 |     |     function log(uint256 p0, bool p1, uint256 p2) internal view {
  299 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256)", p0, p1, p2));
  300 |     |     }
  301 |     | 
  302 |     |     function log(uint256 p0, bool p1, string memory p2) internal view {
  303 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string)", p0, p1, p2));
  304 |     |     }
  305 |     | 
  306 |     |     function log(uint256 p0, bool p1, bool p2) internal view {
  307 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool)", p0, p1, p2));
  308 |     |     }
  309 |     | 
  310 |     |     function log(uint256 p0, bool p1, address p2) internal view {
  311 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address)", p0, p1, p2));
  312 |     |     }
  313 |     | 
  314 |     |     function log(uint256 p0, address p1, uint256 p2) internal view {
  315 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256)", p0, p1, p2));
  316 |     |     }
  317 |     | 
  318 |     |     function log(uint256 p0, address p1, string memory p2) internal view {
  319 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string)", p0, p1, p2));
  320 |     |     }
  321 |     | 
  322 |     |     function log(uint256 p0, address p1, bool p2) internal view {
  323 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool)", p0, p1, p2));
  324 |     |     }
  325 |     | 
  326 |     |     function log(uint256 p0, address p1, address p2) internal view {
  327 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address)", p0, p1, p2));
  328 |     |     }
  329 |     | 
  330 |     |     function log(string memory p0, uint256 p1, uint256 p2) internal view {
  331 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256)", p0, p1, p2));
  332 |     |     }
  333 |     | 
  334 |     |     function log(string memory p0, uint256 p1, string memory p2) internal view {
  335 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string)", p0, p1, p2));
  336 |     |     }
  337 |     | 
  338 |     |     function log(string memory p0, uint256 p1, bool p2) internal view {
  339 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool)", p0, p1, p2));
  340 |     |     }
  341 |     | 
  342 |     |     function log(string memory p0, uint256 p1, address p2) internal view {
  343 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address)", p0, p1, p2));
  344 |     |     }
  345 |     | 
  346 |     |     function log(string memory p0, string memory p1, uint256 p2) internal view {
  347 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256)", p0, p1, p2));
  348 |     |     }
  349 |     | 
  350 |     |     function log(string memory p0, string memory p1, string memory p2) internal view {
  351 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string)", p0, p1, p2));
  352 |     |     }
  353 |     | 
  354 |     |     function log(string memory p0, string memory p1, bool p2) internal view {
  355 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool)", p0, p1, p2));
  356 |     |     }
  357 |     | 
  358 |     |     function log(string memory p0, string memory p1, address p2) internal view {
  359 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address)", p0, p1, p2));
  360 |     |     }
  361 |     | 
  362 |     |     function log(string memory p0, bool p1, uint256 p2) internal view {
  363 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256)", p0, p1, p2));
  364 |     |     }
  365 |     | 
  366 |     |     function log(string memory p0, bool p1, string memory p2) internal view {
  367 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string)", p0, p1, p2));
  368 |     |     }
  369 |     | 
  370 |     |     function log(string memory p0, bool p1, bool p2) internal view {
  371 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool)", p0, p1, p2));
  372 |     |     }
  373 |     | 
  374 |     |     function log(string memory p0, bool p1, address p2) internal view {
  375 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address)", p0, p1, p2));
  376 |     |     }
  377 |     | 
  378 |     |     function log(string memory p0, address p1, uint256 p2) internal view {
  379 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256)", p0, p1, p2));
  380 |     |     }
  381 |     | 
  382 |     |     function log(string memory p0, address p1, string memory p2) internal view {
  383 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string)", p0, p1, p2));
  384 |     |     }
  385 |     | 
  386 |     |     function log(string memory p0, address p1, bool p2) internal view {
  387 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool)", p0, p1, p2));
  388 |     |     }
  389 |     | 
  390 |     |     function log(string memory p0, address p1, address p2) internal view {
  391 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address)", p0, p1, p2));
  392 |     |     }
  393 |     | 
  394 |     |     function log(bool p0, uint256 p1, uint256 p2) internal view {
  395 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256)", p0, p1, p2));
  396 |     |     }
  397 |     | 
  398 |     |     function log(bool p0, uint256 p1, string memory p2) internal view {
  399 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string)", p0, p1, p2));
  400 |     |     }
  401 |     | 
  402 |     |     function log(bool p0, uint256 p1, bool p2) internal view {
  403 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool)", p0, p1, p2));
  404 |     |     }
  405 |     | 
  406 |     |     function log(bool p0, uint256 p1, address p2) internal view {
  407 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address)", p0, p1, p2));
  408 |     |     }
  409 |     | 
  410 |     |     function log(bool p0, string memory p1, uint256 p2) internal view {
  411 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256)", p0, p1, p2));
  412 |     |     }
  413 |     | 
  414 |     |     function log(bool p0, string memory p1, string memory p2) internal view {
  415 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string)", p0, p1, p2));
  416 |     |     }
  417 |     | 
  418 |     |     function log(bool p0, string memory p1, bool p2) internal view {
  419 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool)", p0, p1, p2));
  420 |     |     }
  421 |     | 
  422 |     |     function log(bool p0, string memory p1, address p2) internal view {
  423 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address)", p0, p1, p2));
  424 |     |     }
  425 |     | 
  426 |     |     function log(bool p0, bool p1, uint256 p2) internal view {
  427 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256)", p0, p1, p2));
  428 |     |     }
  429 |     | 
  430 |     |     function log(bool p0, bool p1, string memory p2) internal view {
  431 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string)", p0, p1, p2));
  432 |     |     }
  433 |     | 
  434 |     |     function log(bool p0, bool p1, bool p2) internal view {
  435 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool)", p0, p1, p2));
  436 |     |     }
  437 |     | 
  438 |     |     function log(bool p0, bool p1, address p2) internal view {
  439 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address)", p0, p1, p2));
  440 |     |     }
  441 |     | 
  442 |     |     function log(bool p0, address p1, uint256 p2) internal view {
  443 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256)", p0, p1, p2));
  444 |     |     }
  445 |     | 
  446 |     |     function log(bool p0, address p1, string memory p2) internal view {
  447 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string)", p0, p1, p2));
  448 |     |     }
  449 |     | 
  450 |     |     function log(bool p0, address p1, bool p2) internal view {
  451 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool)", p0, p1, p2));
  452 |     |     }
  453 |     | 
  454 |     |     function log(bool p0, address p1, address p2) internal view {
  455 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address)", p0, p1, p2));
  456 |     |     }
  457 |     | 
  458 |     |     function log(address p0, uint256 p1, uint256 p2) internal view {
  459 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256)", p0, p1, p2));
  460 |     |     }
  461 |     | 
  462 |     |     function log(address p0, uint256 p1, string memory p2) internal view {
  463 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string)", p0, p1, p2));
  464 |     |     }
  465 |     | 
  466 |     |     function log(address p0, uint256 p1, bool p2) internal view {
  467 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool)", p0, p1, p2));
  468 |     |     }
  469 |     | 
  470 |     |     function log(address p0, uint256 p1, address p2) internal view {
  471 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address)", p0, p1, p2));
  472 |     |     }
  473 |     | 
  474 |     |     function log(address p0, string memory p1, uint256 p2) internal view {
  475 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256)", p0, p1, p2));
  476 |     |     }
  477 |     | 
  478 |     |     function log(address p0, string memory p1, string memory p2) internal view {
  479 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string)", p0, p1, p2));
  480 |     |     }
  481 |     | 
  482 |     |     function log(address p0, string memory p1, bool p2) internal view {
  483 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool)", p0, p1, p2));
  484 |     |     }
  485 |     | 
  486 |     |     function log(address p0, string memory p1, address p2) internal view {
  487 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address)", p0, p1, p2));
  488 |     |     }
  489 |     | 
  490 |     |     function log(address p0, bool p1, uint256 p2) internal view {
  491 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256)", p0, p1, p2));
  492 |     |     }
  493 |     | 
  494 |     |     function log(address p0, bool p1, string memory p2) internal view {
  495 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string)", p0, p1, p2));
  496 |     |     }
  497 |     | 
  498 |     |     function log(address p0, bool p1, bool p2) internal view {
  499 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool)", p0, p1, p2));
  500 |     |     }
  501 |     | 
  502 |     |     function log(address p0, bool p1, address p2) internal view {
  503 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address)", p0, p1, p2));
  504 |     |     }
  505 |     | 
  506 |     |     function log(address p0, address p1, uint256 p2) internal view {
  507 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256)", p0, p1, p2));
  508 |     |     }
  509 |     | 
  510 |     |     function log(address p0, address p1, string memory p2) internal view {
  511 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string)", p0, p1, p2));
  512 |     |     }
  513 |     | 
  514 |     |     function log(address p0, address p1, bool p2) internal view {
  515 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool)", p0, p1, p2));
  516 |     |     }
  517 |     | 
  518 |     |     function log(address p0, address p1, address p2) internal view {
  519 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address)", p0, p1, p2));
  520 |     |     }
  521 |     | 
  522 |     |     function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {
  523 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,uint256)", p0, p1, p2, p3));
  524 |     |     }
  525 |     | 
  526 |     |     function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {
  527 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,string)", p0, p1, p2, p3));
  528 |     |     }
  529 |     | 
  530 |     |     function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {
  531 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,bool)", p0, p1, p2, p3));
  532 |     |     }
  533 |     | 
  534 |     |     function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {
  535 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,address)", p0, p1, p2, p3));
  536 |     |     }
  537 |     | 
  538 |     |     function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {
  539 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,uint256)", p0, p1, p2, p3));
  540 |     |     }
  541 |     | 
  542 |     |     function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {
  543 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,string)", p0, p1, p2, p3));
  544 |     |     }
  545 |     | 
  546 |     |     function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {
  547 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,bool)", p0, p1, p2, p3));
  548 |     |     }
  549 |     | 
  550 |     |     function log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {
  551 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,address)", p0, p1, p2, p3));
  552 |     |     }
  553 |     | 
  554 |     |     function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {
  555 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,uint256)", p0, p1, p2, p3));
  556 |     |     }
  557 |     | 
  558 |     |     function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {
  559 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,string)", p0, p1, p2, p3));
  560 |     |     }
  561 |     | 
  562 |     |     function log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {
  563 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,bool)", p0, p1, p2, p3));
  564 |     |     }
  565 |     | 
  566 |     |     function log(uint256 p0, uint256 p1, bool p2, address p3) internal view {
  567 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,address)", p0, p1, p2, p3));
  568 |     |     }
  569 |     | 
  570 |     |     function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {
  571 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,uint256)", p0, p1, p2, p3));
  572 |     |     }
  573 |     | 
  574 |     |     function log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {
  575 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,string)", p0, p1, p2, p3));
  576 |     |     }
  577 |     | 
  578 |     |     function log(uint256 p0, uint256 p1, address p2, bool p3) internal view {
  579 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,bool)", p0, p1, p2, p3));
  580 |     |     }
  581 |     | 
  582 |     |     function log(uint256 p0, uint256 p1, address p2, address p3) internal view {
  583 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,address)", p0, p1, p2, p3));
  584 |     |     }
  585 |     | 
  586 |     |     function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {
  587 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,uint256)", p0, p1, p2, p3));
  588 |     |     }
  589 |     | 
  590 |     |     function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {
  591 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,string)", p0, p1, p2, p3));
  592 |     |     }
  593 |     | 
  594 |     |     function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {
  595 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,bool)", p0, p1, p2, p3));
  596 |     |     }
  597 |     | 
  598 |     |     function log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {
  599 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,address)", p0, p1, p2, p3));
  600 |     |     }
  601 |     | 
  602 |     |     function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {
  603 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,uint256)", p0, p1, p2, p3));
  604 |     |     }
  605 |     | 
  606 |     |     function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {
  607 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,string)", p0, p1, p2, p3));
  608 |     |     }
  609 |     | 
  610 |     |     function log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {
  611 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,bool)", p0, p1, p2, p3));
  612 |     |     }
  613 |     | 
  614 |     |     function log(uint256 p0, string memory p1, string memory p2, address p3) internal view {
  615 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,address)", p0, p1, p2, p3));
  616 |     |     }
  617 |     | 
  618 |     |     function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {
  619 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,uint256)", p0, p1, p2, p3));
  620 |     |     }
  621 |     | 
  622 |     |     function log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {
  623 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,string)", p0, p1, p2, p3));
  624 |     |     }
  625 |     | 
  626 |     |     function log(uint256 p0, string memory p1, bool p2, bool p3) internal view {
  627 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,bool)", p0, p1, p2, p3));
  628 |     |     }
  629 |     | 
  630 |     |     function log(uint256 p0, string memory p1, bool p2, address p3) internal view {
  631 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,address)", p0, p1, p2, p3));
  632 |     |     }
  633 |     | 
  634 |     |     function log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {
  635 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,uint256)", p0, p1, p2, p3));
  636 |     |     }
  637 |     | 
  638 |     |     function log(uint256 p0, string memory p1, address p2, string memory p3) internal view {
  639 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,string)", p0, p1, p2, p3));
  640 |     |     }
  641 |     | 
  642 |     |     function log(uint256 p0, string memory p1, address p2, bool p3) internal view {
  643 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,bool)", p0, p1, p2, p3));
  644 |     |     }
  645 |     | 
  646 |     |     function log(uint256 p0, string memory p1, address p2, address p3) internal view {
  647 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,address)", p0, p1, p2, p3));
  648 |     |     }
  649 |     | 
  650 |     |     function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {
  651 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,uint256)", p0, p1, p2, p3));
  652 |     |     }
  653 |     | 
  654 |     |     function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {
  655 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,string)", p0, p1, p2, p3));
  656 |     |     }
  657 |     | 
  658 |     |     function log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {
  659 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,bool)", p0, p1, p2, p3));
  660 |     |     }
  661 |     | 
  662 |     |     function log(uint256 p0, bool p1, uint256 p2, address p3) internal view {
  663 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,address)", p0, p1, p2, p3));
  664 |     |     }
  665 |     | 
  666 |     |     function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {
  667 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,uint256)", p0, p1, p2, p3));
  668 |     |     }
  669 |     | 
  670 |     |     function log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {
  671 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,string)", p0, p1, p2, p3));
  672 |     |     }
  673 |     | 
  674 |     |     function log(uint256 p0, bool p1, string memory p2, bool p3) internal view {
  675 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,bool)", p0, p1, p2, p3));
  676 |     |     }
  677 |     | 
  678 |     |     function log(uint256 p0, bool p1, string memory p2, address p3) internal view {
  679 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,address)", p0, p1, p2, p3));
  680 |     |     }
  681 |     | 
  682 |     |     function log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {
  683 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,uint256)", p0, p1, p2, p3));
  684 |     |     }
  685 |     | 
  686 |     |     function log(uint256 p0, bool p1, bool p2, string memory p3) internal view {
  687 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,string)", p0, p1, p2, p3));
  688 |     |     }
  689 |     | 
  690 |     |     function log(uint256 p0, bool p1, bool p2, bool p3) internal view {
  691 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,bool)", p0, p1, p2, p3));
  692 |     |     }
  693 |     | 
  694 |     |     function log(uint256 p0, bool p1, bool p2, address p3) internal view {
  695 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,address)", p0, p1, p2, p3));
  696 |     |     }
  697 |     | 
  698 |     |     function log(uint256 p0, bool p1, address p2, uint256 p3) internal view {
  699 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,uint256)", p0, p1, p2, p3));
  700 |     |     }
  701 |     | 
  702 |     |     function log(uint256 p0, bool p1, address p2, string memory p3) internal view {
  703 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,string)", p0, p1, p2, p3));
  704 |     |     }
  705 |     | 
  706 |     |     function log(uint256 p0, bool p1, address p2, bool p3) internal view {
  707 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,bool)", p0, p1, p2, p3));
  708 |     |     }
  709 |     | 
  710 |     |     function log(uint256 p0, bool p1, address p2, address p3) internal view {
  711 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,address)", p0, p1, p2, p3));
  712 |     |     }
  713 |     | 
  714 |     |     function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {
  715 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,uint256)", p0, p1, p2, p3));
  716 |     |     }
  717 |     | 
  718 |     |     function log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {
  719 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,string)", p0, p1, p2, p3));
  720 |     |     }
  721 |     | 
  722 |     |     function log(uint256 p0, address p1, uint256 p2, bool p3) internal view {
  723 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,bool)", p0, p1, p2, p3));
  724 |     |     }
  725 |     | 
  726 |     |     function log(uint256 p0, address p1, uint256 p2, address p3) internal view {
  727 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,address)", p0, p1, p2, p3));
  728 |     |     }
  729 |     | 
  730 |     |     function log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {
  731 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,uint256)", p0, p1, p2, p3));
  732 |     |     }
  733 |     | 
  734 |     |     function log(uint256 p0, address p1, string memory p2, string memory p3) internal view {
  735 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,string)", p0, p1, p2, p3));
  736 |     |     }
  737 |     | 
  738 |     |     function log(uint256 p0, address p1, string memory p2, bool p3) internal view {
  739 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,bool)", p0, p1, p2, p3));
  740 |     |     }
  741 |     | 
  742 |     |     function log(uint256 p0, address p1, string memory p2, address p3) internal view {
  743 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,address)", p0, p1, p2, p3));
  744 |     |     }
  745 |     | 
  746 |     |     function log(uint256 p0, address p1, bool p2, uint256 p3) internal view {
  747 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,uint256)", p0, p1, p2, p3));
  748 |     |     }
  749 |     | 
  750 |     |     function log(uint256 p0, address p1, bool p2, string memory p3) internal view {
  751 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,string)", p0, p1, p2, p3));
  752 |     |     }
  753 |     | 
  754 |     |     function log(uint256 p0, address p1, bool p2, bool p3) internal view {
  755 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,bool)", p0, p1, p2, p3));
  756 |     |     }
  757 |     | 
  758 |     |     function log(uint256 p0, address p1, bool p2, address p3) internal view {
  759 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,address)", p0, p1, p2, p3));
  760 |     |     }
  761 |     | 
  762 |     |     function log(uint256 p0, address p1, address p2, uint256 p3) internal view {
  763 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,uint256)", p0, p1, p2, p3));
  764 |     |     }
  765 |     | 
  766 |     |     function log(uint256 p0, address p1, address p2, string memory p3) internal view {
  767 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,string)", p0, p1, p2, p3));
  768 |     |     }
  769 |     | 
  770 |     |     function log(uint256 p0, address p1, address p2, bool p3) internal view {
  771 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,bool)", p0, p1, p2, p3));
  772 |     |     }
  773 |     | 
  774 |     |     function log(uint256 p0, address p1, address p2, address p3) internal view {
  775 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,address)", p0, p1, p2, p3));
  776 |     |     }
  777 |     | 
  778 |     |     function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {
  779 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,uint256)", p0, p1, p2, p3));
  780 |     |     }
  781 |     | 
  782 |     |     function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {
  783 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,string)", p0, p1, p2, p3));
  784 |     |     }
  785 |     | 
  786 |     |     function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {
  787 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,bool)", p0, p1, p2, p3));
  788 |     |     }
  789 |     | 
  790 |     |     function log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {
  791 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,address)", p0, p1, p2, p3));
  792 |     |     }
  793 |     | 
  794 |     |     function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {
  795 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,uint256)", p0, p1, p2, p3));
  796 |     |     }
  797 |     | 
  798 |     |     function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {
  799 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,string)", p0, p1, p2, p3));
  800 |     |     }
  801 |     | 
  802 |     |     function log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {
  803 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,bool)", p0, p1, p2, p3));
  804 |     |     }
  805 |     | 
  806 |     |     function log(string memory p0, uint256 p1, string memory p2, address p3) internal view {
  807 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,address)", p0, p1, p2, p3));
  808 |     |     }
  809 |     | 
  810 |     |     function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {
  811 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,uint256)", p0, p1, p2, p3));
  812 |     |     }
  813 |     | 
  814 |     |     function log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {
  815 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,string)", p0, p1, p2, p3));
  816 |     |     }
  817 |     | 
  818 |     |     function log(string memory p0, uint256 p1, bool p2, bool p3) internal view {
  819 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,bool)", p0, p1, p2, p3));
  820 |     |     }
  821 |     | 
  822 |     |     function log(string memory p0, uint256 p1, bool p2, address p3) internal view {
  823 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,address)", p0, p1, p2, p3));
  824 |     |     }
  825 |     | 
  826 |     |     function log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {
  827 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,uint256)", p0, p1, p2, p3));
  828 |     |     }
  829 |     | 
  830 |     |     function log(string memory p0, uint256 p1, address p2, string memory p3) internal view {
  831 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,string)", p0, p1, p2, p3));
  832 |     |     }
  833 |     | 
  834 |     |     function log(string memory p0, uint256 p1, address p2, bool p3) internal view {
  835 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,bool)", p0, p1, p2, p3));
  836 |     |     }
  837 |     | 
  838 |     |     function log(string memory p0, uint256 p1, address p2, address p3) internal view {
  839 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,address)", p0, p1, p2, p3));
  840 |     |     }
  841 |     | 
  842 |     |     function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {
  843 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,uint256)", p0, p1, p2, p3));
  844 |     |     }
  845 |     | 
  846 |     |     function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {
  847 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,string)", p0, p1, p2, p3));
  848 |     |     }
  849 |     | 
  850 |     |     function log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {
  851 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,bool)", p0, p1, p2, p3));
  852 |     |     }
  853 |     | 
  854 |     |     function log(string memory p0, string memory p1, uint256 p2, address p3) internal view {
  855 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,address)", p0, p1, p2, p3));
  856 |     |     }
  857 |     | 
  858 |     |     function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {
  859 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,uint256)", p0, p1, p2, p3));
  860 |     |     }
  861 |     | 
  862 |     |     function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {
  863 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,string)", p0, p1, p2, p3));
  864 |     |     }
  865 |     | 
  866 |     |     function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {
  867 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,bool)", p0, p1, p2, p3));
  868 |     |     }
  869 |     | 
  870 |     |     function log(string memory p0, string memory p1, string memory p2, address p3) internal view {
  871 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,address)", p0, p1, p2, p3));
  872 |     |     }
  873 |     | 
  874 |     |     function log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {
  875 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,uint256)", p0, p1, p2, p3));
  876 |     |     }
  877 |     | 
  878 |     |     function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {
  879 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,string)", p0, p1, p2, p3));
  880 |     |     }
  881 |     | 
  882 |     |     function log(string memory p0, string memory p1, bool p2, bool p3) internal view {
  883 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,bool)", p0, p1, p2, p3));
  884 |     |     }
  885 |     | 
  886 |     |     function log(string memory p0, string memory p1, bool p2, address p3) internal view {
  887 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,address)", p0, p1, p2, p3));
  888 |     |     }
  889 |     | 
  890 |     |     function log(string memory p0, string memory p1, address p2, uint256 p3) internal view {
  891 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,uint256)", p0, p1, p2, p3));
  892 |     |     }
  893 |     | 
  894 |     |     function log(string memory p0, string memory p1, address p2, string memory p3) internal view {
  895 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,string)", p0, p1, p2, p3));
  896 |     |     }
  897 |     | 
  898 |     |     function log(string memory p0, string memory p1, address p2, bool p3) internal view {
  899 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,bool)", p0, p1, p2, p3));
  900 |     |     }
  901 |     | 
  902 |     |     function log(string memory p0, string memory p1, address p2, address p3) internal view {
  903 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,address)", p0, p1, p2, p3));
  904 |     |     }
  905 |     | 
  906 |     |     function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {
  907 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,uint256)", p0, p1, p2, p3));
  908 |     |     }
  909 |     | 
  910 |     |     function log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {
  911 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,string)", p0, p1, p2, p3));
  912 |     |     }
  913 |     | 
  914 |     |     function log(string memory p0, bool p1, uint256 p2, bool p3) internal view {
  915 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,bool)", p0, p1, p2, p3));
  916 |     |     }
  917 |     | 
  918 |     |     function log(string memory p0, bool p1, uint256 p2, address p3) internal view {
  919 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,address)", p0, p1, p2, p3));
  920 |     |     }
  921 |     | 
  922 |     |     function log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {
  923 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,uint256)", p0, p1, p2, p3));
  924 |     |     }
  925 |     | 
  926 |     |     function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {
  927 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,string)", p0, p1, p2, p3));
  928 |     |     }
  929 |     | 
  930 |     |     function log(string memory p0, bool p1, string memory p2, bool p3) internal view {
  931 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,bool)", p0, p1, p2, p3));
  932 |     |     }
  933 |     | 
  934 |     |     function log(string memory p0, bool p1, string memory p2, address p3) internal view {
  935 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,address)", p0, p1, p2, p3));
  936 |     |     }
  937 |     | 
  938 |     |     function log(string memory p0, bool p1, bool p2, uint256 p3) internal view {
  939 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,uint256)", p0, p1, p2, p3));
  940 |     |     }
  941 |     | 
  942 |     |     function log(string memory p0, bool p1, bool p2, string memory p3) internal view {
  943 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,string)", p0, p1, p2, p3));
  944 |     |     }
  945 |     | 
  946 |     |     function log(string memory p0, bool p1, bool p2, bool p3) internal view {
  947 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,bool)", p0, p1, p2, p3));
  948 |     |     }
  949 |     | 
  950 |     |     function log(string memory p0, bool p1, bool p2, address p3) internal view {
  951 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,address)", p0, p1, p2, p3));
  952 |     |     }
  953 |     | 
  954 |     |     function log(string memory p0, bool p1, address p2, uint256 p3) internal view {
  955 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,uint256)", p0, p1, p2, p3));
  956 |     |     }
  957 |     | 
  958 |     |     function log(string memory p0, bool p1, address p2, string memory p3) internal view {
  959 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,string)", p0, p1, p2, p3));
  960 |     |     }
  961 |     | 
  962 |     |     function log(string memory p0, bool p1, address p2, bool p3) internal view {
  963 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,bool)", p0, p1, p2, p3));
  964 |     |     }
  965 |     | 
  966 |     |     function log(string memory p0, bool p1, address p2, address p3) internal view {
  967 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,address)", p0, p1, p2, p3));
  968 |     |     }
  969 |     | 
  970 |     |     function log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {
  971 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,uint256)", p0, p1, p2, p3));
  972 |     |     }
  973 |     | 
  974 |     |     function log(string memory p0, address p1, uint256 p2, string memory p3) internal view {
  975 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,string)", p0, p1, p2, p3));
  976 |     |     }
  977 |     | 
  978 |     |     function log(string memory p0, address p1, uint256 p2, bool p3) internal view {
  979 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,bool)", p0, p1, p2, p3));
  980 |     |     }
  981 |     | 
  982 |     |     function log(string memory p0, address p1, uint256 p2, address p3) internal view {
  983 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,address)", p0, p1, p2, p3));
  984 |     |     }
  985 |     | 
  986 |     |     function log(string memory p0, address p1, string memory p2, uint256 p3) internal view {
  987 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,uint256)", p0, p1, p2, p3));
  988 |     |     }
  989 |     | 
  990 |     |     function log(string memory p0, address p1, string memory p2, string memory p3) internal view {
  991 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,string)", p0, p1, p2, p3));
  992 |     |     }
  993 |     | 
  994 |     |     function log(string memory p0, address p1, string memory p2, bool p3) internal view {
  995 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,bool)", p0, p1, p2, p3));
  996 |     |     }
  997 |     | 
  998 |     |     function log(string memory p0, address p1, string memory p2, address p3) internal view {
  999 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,address)", p0, p1, p2, p3));
 1000 |     |     }
 1001 |     | 
 1002 |     |     function log(string memory p0, address p1, bool p2, uint256 p3) internal view {
 1003 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,uint256)", p0, p1, p2, p3));
 1004 |     |     }
 1005 |     | 
 1006 |     |     function log(string memory p0, address p1, bool p2, string memory p3) internal view {
 1007 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,string)", p0, p1, p2, p3));
 1008 |     |     }
 1009 |     | 
 1010 |     |     function log(string memory p0, address p1, bool p2, bool p3) internal view {
 1011 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,bool)", p0, p1, p2, p3));
 1012 |     |     }
 1013 |     | 
 1014 |     |     function log(string memory p0, address p1, bool p2, address p3) internal view {
 1015 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,address)", p0, p1, p2, p3));
 1016 |     |     }
 1017 |     | 
 1018 |     |     function log(string memory p0, address p1, address p2, uint256 p3) internal view {
 1019 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,uint256)", p0, p1, p2, p3));
 1020 |     |     }
 1021 |     | 
 1022 |     |     function log(string memory p0, address p1, address p2, string memory p3) internal view {
 1023 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,string)", p0, p1, p2, p3));
 1024 |     |     }
 1025 |     | 
 1026 |     |     function log(string memory p0, address p1, address p2, bool p3) internal view {
 1027 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,bool)", p0, p1, p2, p3));
 1028 |     |     }
 1029 |     | 
 1030 |     |     function log(string memory p0, address p1, address p2, address p3) internal view {
 1031 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,address)", p0, p1, p2, p3));
 1032 |     |     }
 1033 |     | 
 1034 |     |     function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {
 1035 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,uint256)", p0, p1, p2, p3));
 1036 |     |     }
 1037 |     | 
 1038 |     |     function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {
 1039 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,string)", p0, p1, p2, p3));
 1040 |     |     }
 1041 |     | 
 1042 |     |     function log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {
 1043 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,bool)", p0, p1, p2, p3));
 1044 |     |     }
 1045 |     | 
 1046 |     |     function log(bool p0, uint256 p1, uint256 p2, address p3) internal view {
 1047 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,address)", p0, p1, p2, p3));
 1048 |     |     }
 1049 |     | 
 1050 |     |     function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {
 1051 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,uint256)", p0, p1, p2, p3));
 1052 |     |     }
 1053 |     | 
 1054 |     |     function log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {
 1055 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,string)", p0, p1, p2, p3));
 1056 |     |     }
 1057 |     | 
 1058 |     |     function log(bool p0, uint256 p1, string memory p2, bool p3) internal view {
 1059 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,bool)", p0, p1, p2, p3));
 1060 |     |     }
 1061 |     | 
 1062 |     |     function log(bool p0, uint256 p1, string memory p2, address p3) internal view {
 1063 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,address)", p0, p1, p2, p3));
 1064 |     |     }
 1065 |     | 
 1066 |     |     function log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {
 1067 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,uint256)", p0, p1, p2, p3));
 1068 |     |     }
 1069 |     | 
 1070 |     |     function log(bool p0, uint256 p1, bool p2, string memory p3) internal view {
 1071 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,string)", p0, p1, p2, p3));
 1072 |     |     }
 1073 |     | 
 1074 |     |     function log(bool p0, uint256 p1, bool p2, bool p3) internal view {
 1075 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,bool)", p0, p1, p2, p3));
 1076 |     |     }
 1077 |     | 
 1078 |     |     function log(bool p0, uint256 p1, bool p2, address p3) internal view {
 1079 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,address)", p0, p1, p2, p3));
 1080 |     |     }
 1081 |     | 
 1082 |     |     function log(bool p0, uint256 p1, address p2, uint256 p3) internal view {
 1083 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,uint256)", p0, p1, p2, p3));
 1084 |     |     }
 1085 |     | 
 1086 |     |     function log(bool p0, uint256 p1, address p2, string memory p3) internal view {
 1087 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,string)", p0, p1, p2, p3));
 1088 |     |     }
 1089 |     | 
 1090 |     |     function log(bool p0, uint256 p1, address p2, bool p3) internal view {
 1091 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,bool)", p0, p1, p2, p3));
 1092 |     |     }
 1093 |     | 
 1094 |     |     function log(bool p0, uint256 p1, address p2, address p3) internal view {
 1095 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,address)", p0, p1, p2, p3));
 1096 |     |     }
 1097 |     | 
 1098 |     |     function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {
 1099 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,uint256)", p0, p1, p2, p3));
 1100 |     |     }
 1101 |     | 
 1102 |     |     function log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {
 1103 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,string)", p0, p1, p2, p3));
 1104 |     |     }
 1105 |     | 
 1106 |     |     function log(bool p0, string memory p1, uint256 p2, bool p3) internal view {
 1107 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,bool)", p0, p1, p2, p3));
 1108 |     |     }
 1109 |     | 
 1110 |     |     function log(bool p0, string memory p1, uint256 p2, address p3) internal view {
 1111 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,address)", p0, p1, p2, p3));
 1112 |     |     }
 1113 |     | 
 1114 |     |     function log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {
 1115 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,uint256)", p0, p1, p2, p3));
 1116 |     |     }
 1117 |     | 
 1118 |     |     function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {
 1119 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,string)", p0, p1, p2, p3));
 1120 |     |     }
 1121 |     | 
 1122 |     |     function log(bool p0, string memory p1, string memory p2, bool p3) internal view {
 1123 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,bool)", p0, p1, p2, p3));
 1124 |     |     }
 1125 |     | 
 1126 |     |     function log(bool p0, string memory p1, string memory p2, address p3) internal view {
 1127 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,address)", p0, p1, p2, p3));
 1128 |     |     }
 1129 |     | 
 1130 |     |     function log(bool p0, string memory p1, bool p2, uint256 p3) internal view {
 1131 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,uint256)", p0, p1, p2, p3));
 1132 |     |     }
 1133 |     | 
 1134 |     |     function log(bool p0, string memory p1, bool p2, string memory p3) internal view {
 1135 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,string)", p0, p1, p2, p3));
 1136 |     |     }
 1137 |     | 
 1138 |     |     function log(bool p0, string memory p1, bool p2, bool p3) internal view {
 1139 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,bool)", p0, p1, p2, p3));
 1140 |     |     }
 1141 |     | 
 1142 |     |     function log(bool p0, string memory p1, bool p2, address p3) internal view {
 1143 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,address)", p0, p1, p2, p3));
 1144 |     |     }
 1145 |     | 
 1146 |     |     function log(bool p0, string memory p1, address p2, uint256 p3) internal view {
 1147 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,uint256)", p0, p1, p2, p3));
 1148 |     |     }
 1149 |     | 
 1150 |     |     function log(bool p0, string memory p1, address p2, string memory p3) internal view {
 1151 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,string)", p0, p1, p2, p3));
 1152 |     |     }
 1153 |     | 
 1154 |     |     function log(bool p0, string memory p1, address p2, bool p3) internal view {
 1155 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,bool)", p0, p1, p2, p3));
 1156 |     |     }
 1157 |     | 
 1158 |     |     function log(bool p0, string memory p1, address p2, address p3) internal view {
 1159 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,address)", p0, p1, p2, p3));
 1160 |     |     }
 1161 |     | 
 1162 |     |     function log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {
 1163 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,uint256)", p0, p1, p2, p3));
 1164 |     |     }
 1165 |     | 
 1166 |     |     function log(bool p0, bool p1, uint256 p2, string memory p3) internal view {
 1167 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,string)", p0, p1, p2, p3));
 1168 |     |     }
 1169 |     | 
 1170 |     |     function log(bool p0, bool p1, uint256 p2, bool p3) internal view {
 1171 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,bool)", p0, p1, p2, p3));
 1172 |     |     }
 1173 |     | 
 1174 |     |     function log(bool p0, bool p1, uint256 p2, address p3) internal view {
 1175 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,address)", p0, p1, p2, p3));
 1176 |     |     }
 1177 |     | 
 1178 |     |     function log(bool p0, bool p1, string memory p2, uint256 p3) internal view {
 1179 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,uint256)", p0, p1, p2, p3));
 1180 |     |     }
 1181 |     | 
 1182 |     |     function log(bool p0, bool p1, string memory p2, string memory p3) internal view {
 1183 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,string)", p0, p1, p2, p3));
 1184 |     |     }
 1185 |     | 
 1186 |     |     function log(bool p0, bool p1, string memory p2, bool p3) internal view {
 1187 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,bool)", p0, p1, p2, p3));
 1188 |     |     }
 1189 |     | 
 1190 |     |     function log(bool p0, bool p1, string memory p2, address p3) internal view {
 1191 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,address)", p0, p1, p2, p3));
 1192 |     |     }
 1193 |     | 
 1194 |     |     function log(bool p0, bool p1, bool p2, uint256 p3) internal view {
 1195 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,uint256)", p0, p1, p2, p3));
 1196 |     |     }
 1197 |     | 
 1198 |     |     function log(bool p0, bool p1, bool p2, string memory p3) internal view {
 1199 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,string)", p0, p1, p2, p3));
 1200 |     |     }
 1201 |     | 
 1202 |     |     function log(bool p0, bool p1, bool p2, bool p3) internal view {
 1203 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,bool)", p0, p1, p2, p3));
 1204 |     |     }
 1205 |     | 
 1206 |     |     function log(bool p0, bool p1, bool p2, address p3) internal view {
 1207 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,address)", p0, p1, p2, p3));
 1208 |     |     }
 1209 |     | 
 1210 |     |     function log(bool p0, bool p1, address p2, uint256 p3) internal view {
 1211 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,uint256)", p0, p1, p2, p3));
 1212 |     |     }
 1213 |     | 
 1214 |     |     function log(bool p0, bool p1, address p2, string memory p3) internal view {
 1215 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,string)", p0, p1, p2, p3));
 1216 |     |     }
 1217 |     | 
 1218 |     |     function log(bool p0, bool p1, address p2, bool p3) internal view {
 1219 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,bool)", p0, p1, p2, p3));
 1220 |     |     }
 1221 |     | 
 1222 |     |     function log(bool p0, bool p1, address p2, address p3) internal view {
 1223 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,address)", p0, p1, p2, p3));
 1224 |     |     }
 1225 |     | 
 1226 |     |     function log(bool p0, address p1, uint256 p2, uint256 p3) internal view {
 1227 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,uint256)", p0, p1, p2, p3));
 1228 |     |     }
 1229 |     | 
 1230 |     |     function log(bool p0, address p1, uint256 p2, string memory p3) internal view {
 1231 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,string)", p0, p1, p2, p3));
 1232 |     |     }
 1233 |     | 
 1234 |     |     function log(bool p0, address p1, uint256 p2, bool p3) internal view {
 1235 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,bool)", p0, p1, p2, p3));
 1236 |     |     }
 1237 |     | 
 1238 |     |     function log(bool p0, address p1, uint256 p2, address p3) internal view {
 1239 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,address)", p0, p1, p2, p3));
 1240 |     |     }
 1241 |     | 
 1242 |     |     function log(bool p0, address p1, string memory p2, uint256 p3) internal view {
 1243 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,uint256)", p0, p1, p2, p3));
 1244 |     |     }
 1245 |     | 
 1246 |     |     function log(bool p0, address p1, string memory p2, string memory p3) internal view {
 1247 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,string)", p0, p1, p2, p3));
 1248 |     |     }
 1249 |     | 
 1250 |     |     function log(bool p0, address p1, string memory p2, bool p3) internal view {
 1251 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,bool)", p0, p1, p2, p3));
 1252 |     |     }
 1253 |     | 
 1254 |     |     function log(bool p0, address p1, string memory p2, address p3) internal view {
 1255 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,address)", p0, p1, p2, p3));
 1256 |     |     }
 1257 |     | 
 1258 |     |     function log(bool p0, address p1, bool p2, uint256 p3) internal view {
 1259 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,uint256)", p0, p1, p2, p3));
 1260 |     |     }
 1261 |     | 
 1262 |     |     function log(bool p0, address p1, bool p2, string memory p3) internal view {
 1263 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,string)", p0, p1, p2, p3));
 1264 |     |     }
 1265 |     | 
 1266 |     |     function log(bool p0, address p1, bool p2, bool p3) internal view {
 1267 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,bool)", p0, p1, p2, p3));
 1268 |     |     }
 1269 |     | 
 1270 |     |     function log(bool p0, address p1, bool p2, address p3) internal view {
 1271 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,address)", p0, p1, p2, p3));
 1272 |     |     }
 1273 |     | 
 1274 |     |     function log(bool p0, address p1, address p2, uint256 p3) internal view {
 1275 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,uint256)", p0, p1, p2, p3));
 1276 |     |     }
 1277 |     | 
 1278 |     |     function log(bool p0, address p1, address p2, string memory p3) internal view {
 1279 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,string)", p0, p1, p2, p3));
 1280 |     |     }
 1281 |     | 
 1282 |     |     function log(bool p0, address p1, address p2, bool p3) internal view {
 1283 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,bool)", p0, p1, p2, p3));
 1284 |     |     }
 1285 |     | 
 1286 |     |     function log(bool p0, address p1, address p2, address p3) internal view {
 1287 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,address)", p0, p1, p2, p3));
 1288 |     |     }
 1289 |     | 
 1290 |     |     function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {
 1291 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,uint256)", p0, p1, p2, p3));
 1292 |     |     }
 1293 |     | 
 1294 |     |     function log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {
 1295 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,string)", p0, p1, p2, p3));
 1296 |     |     }
 1297 |     | 
 1298 |     |     function log(address p0, uint256 p1, uint256 p2, bool p3) internal view {
 1299 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,bool)", p0, p1, p2, p3));
 1300 |     |     }
 1301 |     | 
 1302 |     |     function log(address p0, uint256 p1, uint256 p2, address p3) internal view {
 1303 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,address)", p0, p1, p2, p3));
 1304 |     |     }
 1305 |     | 
 1306 |     |     function log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {
 1307 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,uint256)", p0, p1, p2, p3));
 1308 |     |     }
 1309 |     | 
 1310 |     |     function log(address p0, uint256 p1, string memory p2, string memory p3) internal view {
 1311 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,string)", p0, p1, p2, p3));
 1312 |     |     }
 1313 |     | 
 1314 |     |     function log(address p0, uint256 p1, string memory p2, bool p3) internal view {
 1315 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,bool)", p0, p1, p2, p3));
 1316 |     |     }
 1317 |     | 
 1318 |     |     function log(address p0, uint256 p1, string memory p2, address p3) internal view {
 1319 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,address)", p0, p1, p2, p3));
 1320 |     |     }
 1321 |     | 
 1322 |     |     function log(address p0, uint256 p1, bool p2, uint256 p3) internal view {
 1323 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,uint256)", p0, p1, p2, p3));
 1324 |     |     }
 1325 |     | 
 1326 |     |     function log(address p0, uint256 p1, bool p2, string memory p3) internal view {
 1327 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,string)", p0, p1, p2, p3));
 1328 |     |     }
 1329 |     | 
 1330 |     |     function log(address p0, uint256 p1, bool p2, bool p3) internal view {
 1331 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,bool)", p0, p1, p2, p3));
 1332 |     |     }
 1333 |     | 
 1334 |     |     function log(address p0, uint256 p1, bool p2, address p3) internal view {
 1335 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,address)", p0, p1, p2, p3));
 1336 |     |     }
 1337 |     | 
 1338 |     |     function log(address p0, uint256 p1, address p2, uint256 p3) internal view {
 1339 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,uint256)", p0, p1, p2, p3));
 1340 |     |     }
 1341 |     | 
 1342 |     |     function log(address p0, uint256 p1, address p2, string memory p3) internal view {
 1343 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,string)", p0, p1, p2, p3));
 1344 |     |     }
 1345 |     | 
 1346 |     |     function log(address p0, uint256 p1, address p2, bool p3) internal view {
 1347 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,bool)", p0, p1, p2, p3));
 1348 |     |     }
 1349 |     | 
 1350 |     |     function log(address p0, uint256 p1, address p2, address p3) internal view {
 1351 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,address)", p0, p1, p2, p3));
 1352 |     |     }
 1353 |     | 
 1354 |     |     function log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {
 1355 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,uint256)", p0, p1, p2, p3));
 1356 |     |     }
 1357 |     | 
 1358 |     |     function log(address p0, string memory p1, uint256 p2, string memory p3) internal view {
 1359 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,string)", p0, p1, p2, p3));
 1360 |     |     }
 1361 |     | 
 1362 |     |     function log(address p0, string memory p1, uint256 p2, bool p3) internal view {
 1363 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,bool)", p0, p1, p2, p3));
 1364 |     |     }
 1365 |     | 
 1366 |     |     function log(address p0, string memory p1, uint256 p2, address p3) internal view {
 1367 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,address)", p0, p1, p2, p3));
 1368 |     |     }
 1369 |     | 
 1370 |     |     function log(address p0, string memory p1, string memory p2, uint256 p3) internal view {
 1371 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,uint256)", p0, p1, p2, p3));
 1372 |     |     }
 1373 |     | 
 1374 |     |     function log(address p0, string memory p1, string memory p2, string memory p3) internal view {
 1375 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,string)", p0, p1, p2, p3));
 1376 |     |     }
 1377 |     | 
 1378 |     |     function log(address p0, string memory p1, string memory p2, bool p3) internal view {
 1379 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,bool)", p0, p1, p2, p3));
 1380 |     |     }
 1381 |     | 
 1382 |     |     function log(address p0, string memory p1, string memory p2, address p3) internal view {
 1383 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,address)", p0, p1, p2, p3));
 1384 |     |     }
 1385 |     | 
 1386 |     |     function log(address p0, string memory p1, bool p2, uint256 p3) internal view {
 1387 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,uint256)", p0, p1, p2, p3));
 1388 |     |     }
 1389 |     | 
 1390 |     |     function log(address p0, string memory p1, bool p2, string memory p3) internal view {
 1391 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,string)", p0, p1, p2, p3));
 1392 |     |     }
 1393 |     | 
 1394 |     |     function log(address p0, string memory p1, bool p2, bool p3) internal view {
 1395 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,bool)", p0, p1, p2, p3));
 1396 |     |     }
 1397 |     | 
 1398 |     |     function log(address p0, string memory p1, bool p2, address p3) internal view {
 1399 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,address)", p0, p1, p2, p3));
 1400 |     |     }
 1401 |     | 
 1402 |     |     function log(address p0, string memory p1, address p2, uint256 p3) internal view {
 1403 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,uint256)", p0, p1, p2, p3));
 1404 |     |     }
 1405 |     | 
 1406 |     |     function log(address p0, string memory p1, address p2, string memory p3) internal view {
 1407 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,string)", p0, p1, p2, p3));
 1408 |     |     }
 1409 |     | 
 1410 |     |     function log(address p0, string memory p1, address p2, bool p3) internal view {
 1411 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,bool)", p0, p1, p2, p3));
 1412 |     |     }
 1413 |     | 
 1414 |     |     function log(address p0, string memory p1, address p2, address p3) internal view {
 1415 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,address)", p0, p1, p2, p3));
 1416 |     |     }
 1417 |     | 
 1418 |     |     function log(address p0, bool p1, uint256 p2, uint256 p3) internal view {
 1419 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,uint256)", p0, p1, p2, p3));
 1420 |     |     }
 1421 |     | 
 1422 |     |     function log(address p0, bool p1, uint256 p2, string memory p3) internal view {
 1423 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,string)", p0, p1, p2, p3));
 1424 |     |     }
 1425 |     | 
 1426 |     |     function log(address p0, bool p1, uint256 p2, bool p3) internal view {
 1427 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,bool)", p0, p1, p2, p3));
 1428 |     |     }
 1429 |     | 
 1430 |     |     function log(address p0, bool p1, uint256 p2, address p3) internal view {
 1431 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,address)", p0, p1, p2, p3));
 1432 |     |     }
 1433 |     | 
 1434 |     |     function log(address p0, bool p1, string memory p2, uint256 p3) internal view {
 1435 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,uint256)", p0, p1, p2, p3));
 1436 |     |     }
 1437 |     | 
 1438 |     |     function log(address p0, bool p1, string memory p2, string memory p3) internal view {
 1439 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,string)", p0, p1, p2, p3));
 1440 |     |     }
 1441 |     | 
 1442 |     |     function log(address p0, bool p1, string memory p2, bool p3) internal view {
 1443 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,bool)", p0, p1, p2, p3));
 1444 |     |     }
 1445 |     | 
 1446 |     |     function log(address p0, bool p1, string memory p2, address p3) internal view {
 1447 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,address)", p0, p1, p2, p3));
 1448 |     |     }
 1449 |     | 
 1450 |     |     function log(address p0, bool p1, bool p2, uint256 p3) internal view {
 1451 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,uint256)", p0, p1, p2, p3));
 1452 |     |     }
 1453 |     | 
 1454 |     |     function log(address p0, bool p1, bool p2, string memory p3) internal view {
 1455 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,string)", p0, p1, p2, p3));
 1456 |     |     }
 1457 |     | 
 1458 |     |     function log(address p0, bool p1, bool p2, bool p3) internal view {
 1459 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,bool)", p0, p1, p2, p3));
 1460 |     |     }
 1461 |     | 
 1462 |     |     function log(address p0, bool p1, bool p2, address p3) internal view {
 1463 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,address)", p0, p1, p2, p3));
 1464 |     |     }
 1465 |     | 
 1466 |     |     function log(address p0, bool p1, address p2, uint256 p3) internal view {
 1467 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,uint256)", p0, p1, p2, p3));
 1468 |     |     }
 1469 |     | 
 1470 |     |     function log(address p0, bool p1, address p2, string memory p3) internal view {
 1471 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,string)", p0, p1, p2, p3));
 1472 |     |     }
 1473 |     | 
 1474 |     |     function log(address p0, bool p1, address p2, bool p3) internal view {
 1475 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,bool)", p0, p1, p2, p3));
 1476 |     |     }
 1477 |     | 
 1478 |     |     function log(address p0, bool p1, address p2, address p3) internal view {
 1479 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,address)", p0, p1, p2, p3));
 1480 |     |     }
 1481 |     | 
 1482 |     |     function log(address p0, address p1, uint256 p2, uint256 p3) internal view {
 1483 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,uint256)", p0, p1, p2, p3));
 1484 |     |     }
 1485 |     | 
 1486 |     |     function log(address p0, address p1, uint256 p2, string memory p3) internal view {
 1487 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,string)", p0, p1, p2, p3));
 1488 |     |     }
 1489 |     | 
 1490 |     |     function log(address p0, address p1, uint256 p2, bool p3) internal view {
 1491 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,bool)", p0, p1, p2, p3));
 1492 |     |     }
 1493 |     | 
 1494 |     |     function log(address p0, address p1, uint256 p2, address p3) internal view {
 1495 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,address)", p0, p1, p2, p3));
 1496 |     |     }
 1497 |     | 
 1498 |     |     function log(address p0, address p1, string memory p2, uint256 p3) internal view {
 1499 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,uint256)", p0, p1, p2, p3));
 1500 |     |     }
 1501 |     | 
 1502 |     |     function log(address p0, address p1, string memory p2, string memory p3) internal view {
 1503 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,string)", p0, p1, p2, p3));
 1504 |     |     }
 1505 |     | 
 1506 |     |     function log(address p0, address p1, string memory p2, bool p3) internal view {
 1507 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,bool)", p0, p1, p2, p3));
 1508 |     |     }
 1509 |     | 
 1510 |     |     function log(address p0, address p1, string memory p2, address p3) internal view {
 1511 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,address)", p0, p1, p2, p3));
 1512 |     |     }
 1513 |     | 
 1514 |     |     function log(address p0, address p1, bool p2, uint256 p3) internal view {
 1515 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,uint256)", p0, p1, p2, p3));
 1516 |     |     }
 1517 |     | 
 1518 |     |     function log(address p0, address p1, bool p2, string memory p3) internal view {
 1519 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,string)", p0, p1, p2, p3));
 1520 |     |     }
 1521 |     | 
 1522 |     |     function log(address p0, address p1, bool p2, bool p3) internal view {
 1523 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,bool)", p0, p1, p2, p3));
 1524 |     |     }
 1525 |     | 
 1526 |     |     function log(address p0, address p1, bool p2, address p3) internal view {
 1527 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,address)", p0, p1, p2, p3));
 1528 |     |     }
 1529 |     | 
 1530 |     |     function log(address p0, address p1, address p2, uint256 p3) internal view {
 1531 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,uint256)", p0, p1, p2, p3));
 1532 |     |     }
 1533 |     | 
 1534 |     |     function log(address p0, address p1, address p2, string memory p3) internal view {
 1535 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,string)", p0, p1, p2, p3));
 1536 |     |     }
 1537 |     | 
 1538 |     |     function log(address p0, address p1, address p2, bool p3) internal view {
 1539 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,bool)", p0, p1, p2, p3));
 1540 |     |     }
 1541 |     | 
 1542 |     |     function log(address p0, address p1, address p2, address p3) internal view {
 1543 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,address)", p0, p1, p2, p3));
 1544 |     |     }
 1545 |     | 
 1546 |     | }

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/forge-std/src/interfaces/IMulticall3.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | pragma experimental ABIEncoderV2;
  5 |     | 
  6 |     | interface IMulticall3 {
  7 |     |     struct Call {
  8 |     |         address target;
  9 |     |         bytes callData;
 10 |     |     }
 11 |     | 
 12 |     |     struct Call3 {
 13 |     |         address target;
 14 |     |         bool allowFailure;
 15 |     |         bytes callData;
 16 |     |     }
 17 |     | 
 18 |     |     struct Call3Value {
 19 |     |         address target;
 20 |     |         bool allowFailure;
 21 |     |         uint256 value;
 22 |     |         bytes callData;
 23 |     |     }
 24 |     | 
 25 |     |     struct Result {
 26 |     |         bool success;
 27 |     |         bytes returnData;
 28 |     |     }
 29 |     | 
 30 |     |     function aggregate(Call[] calldata calls)
 31 |     |         external
 32 |     |         payable
 33 |     |         returns (uint256 blockNumber, bytes[] memory returnData);
 34 |     | 
 35 |     |     function aggregate3(Call3[] calldata calls) external payable returns (Result[] memory returnData);
 36 |     | 
 37 |     |     function aggregate3Value(Call3Value[] calldata calls) external payable returns (Result[] memory returnData);
 38 |     | 
 39 |     |     function blockAndAggregate(Call[] calldata calls)
 40 |     |         external
 41 |     |         payable
 42 |     |         returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);
 43 |     | 
 44 |     |     function getBasefee() external view returns (uint256 basefee);
 45 |     | 
 46 |     |     function getBlockHash(uint256 blockNumber) external view returns (bytes32 blockHash);
 47 |     | 
 48 |     |     function getBlockNumber() external view returns (uint256 blockNumber);
 49 |     | 
 50 |     |     function getChainId() external view returns (uint256 chainid);
 51 |     | 
 52 |     |     function getCurrentBlockCoinbase() external view returns (address coinbase);
 53 |     | 
 54 |     |     function getCurrentBlockDifficulty() external view returns (uint256 difficulty);
 55 |     | 
 56 |     |     function getCurrentBlockGasLimit() external view returns (uint256 gaslimit);
 57 |     | 
 58 |     |     function getCurrentBlockTimestamp() external view returns (uint256 timestamp);
 59 |     | 
 60 |     |     function getEthBalance(address addr) external view returns (uint256 balance);
 61 |     | 
 62 |     |     function getLastBlockHash() external view returns (bytes32 blockHash);
 63 |     | 
 64 |     |     function tryAggregate(bool requireSuccess, Call[] calldata calls)
 65 |     |         external
 66 |     |         payable
 67 |     |         returns (Result[] memory returnData);
 68 |     | 
 69 |     |     function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls)
 70 |     |         external
 71 |     |         payable
 72 |     |         returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);
 73 |     | }
 74 |     | 

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/openzeppelin-contracts/contracts/interfaces/IERC1363.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (interfaces/IERC1363.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "./IERC20.sol";
  7 |     | import "./IERC165.sol";
  8 |     | 
  9 |     | interface IERC1363 is IERC165, IERC20 {
 10 |     |     /*
 11 |     |      * Note: the ERC-165 identifier for this interface is 0x4bbee2df.
 12 |     |      * 0x4bbee2df ===
 13 |     |      *   bytes4(keccak256('transferAndCall(address,uint256)')) ^
 14 |     |      *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^
 15 |     |      *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^
 16 |     |      *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)'))
 17 |     |      */
 18 |     | 
 19 |     |     /*
 20 |     |      * Note: the ERC-165 identifier for this interface is 0xfb9ec8ce.
 21 |     |      * 0xfb9ec8ce ===
 22 |     |      *   bytes4(keccak256('approveAndCall(address,uint256)')) ^
 23 |     |      *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))
 24 |     |      */
 25 |     | 
 26 |     |     /**
 27 |     |      * @dev Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver
 28 |     |      * @param to address The address which you want to transfer to
 29 |     |      * @param value uint256 The amount of tokens to be transferred
 30 |     |      * @return true unless throwing
 31 |     |      */
 32 |     |     function transferAndCall(address to, uint256 value) external returns (bool);
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver
 36 |     |      * @param to address The address which you want to transfer to
 37 |     |      * @param value uint256 The amount of tokens to be transferred
 38 |     |      * @param data bytes Additional data with no specified format, sent in call to `to`
 39 |     |      * @return true unless throwing
 40 |     |      */
 41 |     |     function transferAndCall(
 42 |     |         address to,
 43 |     |         uint256 value,
 44 |     |         bytes memory data
 45 |     |     ) external returns (bool);
 46 |     | 
 47 |     |     /**
 48 |     |      * @dev Transfer tokens from one address to another and then call `onTransferReceived` on receiver
 49 |     |      * @param from address The address which you want to send tokens from
 50 |     |      * @param to address The address which you want to transfer to
 51 |     |      * @param value uint256 The amount of tokens to be transferred
 52 |     |      * @return true unless throwing
 53 |     |      */
 54 |     |     function transferFromAndCall(
 55 |     |         address from,
 56 |     |         address to,
 57 |     |         uint256 value
 58 |     |     ) external returns (bool);
 59 |     | 
 60 |     |     /**
 61 |     |      * @dev Transfer tokens from one address to another and then call `onTransferReceived` on receiver
 62 |     |      * @param from address The address which you want to send tokens from
 63 |     |      * @param to address The address which you want to transfer to
 64 |     |      * @param value uint256 The amount of tokens to be transferred
 65 |     |      * @param data bytes Additional data with no specified format, sent in call to `to`
 66 |     |      * @return true unless throwing
 67 |     |      */
 68 |     |     function transferFromAndCall(
 69 |     |         address from,
 70 |     |         address to,
 71 |     |         uint256 value,
 72 |     |         bytes memory data
 73 |     |     ) external returns (bool);
 74 |     | 
 75 |     |     /**
 76 |     |      * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender
 77 |     |      * and then call `onApprovalReceived` on spender.
 78 |     |      * @param spender address The address which will spend the funds
 79 |     |      * @param value uint256 The amount of tokens to be spent
 80 |     |      */
 81 |     |     function approveAndCall(address spender, uint256 value) external returns (bool);
 82 |     | 
 83 |     |     /**
 84 |     |      * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender
 85 |     |      * and then call `onApprovalReceived` on spender.
 86 |     |      * @param spender address The address which will spend the funds
 87 |     |      * @param value uint256 The amount of tokens to be spent
 88 |     |      * @param data bytes Additional data with no specified format, sent in call to `spender`
 89 |     |      */
 90 |     |     function approveAndCall(
 91 |     |         address spender,
 92 |     |         uint256 value,
 93 |     |         bytes memory data
 94 |     |     ) external returns (bool);
 95 |     | }
 96 |     | 

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/openzeppelin-contracts/contracts/interfaces/IERC1363Receiver.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (interfaces/IERC1363Receiver.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | interface IERC1363Receiver {
  7 |     |     /*
  8 |     |      * Note: the ERC-165 identifier for this interface is 0x88a7ca5c.
  9 |     |      * 0x88a7ca5c === bytes4(keccak256("onTransferReceived(address,address,uint256,bytes)"))
 10 |     |      */
 11 |     | 
 12 |     |     /**
 13 |     |      * @notice Handle the receipt of ERC1363 tokens
 14 |     |      * @dev Any ERC1363 smart contract calls this function on the recipient
 15 |     |      * after a `transfer` or a `transferFrom`. This function MAY throw to revert and reject the
 16 |     |      * transfer. Return of other than the magic value MUST result in the
 17 |     |      * transaction being reverted.
 18 |     |      * Note: the token contract address is always the message sender.
 19 |     |      * @param operator address The address which called `transferAndCall` or `transferFromAndCall` function
 20 |     |      * @param from address The address which are token transferred from
 21 |     |      * @param value uint256 The amount of tokens transferred
 22 |     |      * @param data bytes Additional data with no specified format
 23 |     |      * @return `bytes4(keccak256("onTransferReceived(address,address,uint256,bytes)"))`
 24 |     |      *  unless throwing
 25 |     |      */
 26 |     |     function onTransferReceived(
 27 |     |         address operator,
 28 |     |         address from,
 29 |     |         uint256 value,
 30 |     |         bytes memory data
 31 |     |     ) external returns (bytes4);
 32 |     | }
 33 |     | 

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/openzeppelin-contracts/contracts/interfaces/IERC1363Spender.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (interfaces/IERC1363Spender.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | interface IERC1363Spender {
  7 |     |     /*
  8 |     |      * Note: the ERC-165 identifier for this interface is 0x7b04a2d0.
  9 |     |      * 0x7b04a2d0 === bytes4(keccak256("onApprovalReceived(address,uint256,bytes)"))
 10 |     |      */
 11 |     | 
 12 |     |     /**
 13 |     |      * @notice Handle the approval of ERC1363 tokens
 14 |     |      * @dev Any ERC1363 smart contract calls this function on the recipient
 15 |     |      * after an `approve`. This function MAY throw to revert and reject the
 16 |     |      * approval. Return of other than the magic value MUST result in the
 17 |     |      * transaction being reverted.
 18 |     |      * Note: the token contract address is always the message sender.
 19 |     |      * @param owner address The address which called `approveAndCall` function
 20 |     |      * @param value uint256 The amount of tokens to be spent
 21 |     |      * @param data bytes Additional data with no specified format
 22 |     |      * @return `bytes4(keccak256("onApprovalReceived(address,uint256,bytes)"))`
 23 |     |      *  unless throwing
 24 |     |      */
 25 |     |     function onApprovalReceived(
 26 |     |         address owner,
 27 |     |         uint256 value,
 28 |     |         bytes memory data
 29 |     |     ) external returns (bytes4);
 30 |     | }
 31 |     | 

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/openzeppelin-contracts/contracts/interfaces/IERC165.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | // OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)
 3 |     | 
 4 |     | pragma solidity ^0.8.0;
 5 |     | 
 6 |     | import "../utils/introspection/IERC165.sol";
 7 |     | 

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | // OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)
 3 |     | 
 4 |     | pragma solidity ^0.8.0;
 5 |     | 
 6 |     | import "../token/ERC20/IERC20.sol";
 7 |     | 

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "./IERC20.sol";
   7 |     | import "./extensions/IERC20Metadata.sol";
   8 |     | import "../../utils/Context.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @dev Implementation of the {IERC20} interface.
  12 |     |  *
  13 |     |  * This implementation is agnostic to the way tokens are created. This means
  14 |     |  * that a supply mechanism has to be added in a derived contract using {_mint}.
  15 |     |  * For a generic mechanism see {ERC20PresetMinterPauser}.
  16 |     |  *
  17 |     |  * TIP: For a detailed writeup see our guide
  18 |     |  * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How
  19 |     |  * to implement supply mechanisms].
  20 |     |  *
  21 |     |  * We have followed general OpenZeppelin Contracts guidelines: functions revert
  22 |     |  * instead returning `false` on failure. This behavior is nonetheless
  23 |     |  * conventional and does not conflict with the expectations of ERC20
  24 |     |  * applications.
  25 |     |  *
  26 |     |  * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
  27 |     |  * This allows applications to reconstruct the allowance for all accounts just
  28 |     |  * by listening to said events. Other implementations of the EIP may not emit
  29 |     |  * these events, as it isn't required by the specification.
  30 |     |  *
  31 |     |  * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
  32 |     |  * functions have been added to mitigate the well-known issues around setting
  33 |     |  * allowances. See {IERC20-approve}.
  34 |     |  */
  35 |     | contract ERC20 is Context, IERC20, IERC20Metadata {
  36 |     |     mapping(address => uint256) private _balances;
  37 |     | 
  38 |     |     mapping(address => mapping(address => uint256)) private _allowances;
  39 |     | 
  40 |     |     uint256 private _totalSupply;
  41 |     | 
  42 |     |     string private _name;
  43 |     |     string private _symbol;
  44 |     | 
  45 |     |     /**
  46 |     |      * @dev Sets the values for {name} and {symbol}.
  47 |     |      *
  48 |     |      * The default value of {decimals} is 18. To select a different value for
  49 |     |      * {decimals} you should overload it.
  50 |     |      *
  51 |     |      * All two of these values are immutable: they can only be set once during
  52 |     |      * construction.
  53 |     |      */
  54 |     |     constructor(string memory name_, string memory symbol_) {
  55 |     |         _name = name_;
  56 |     |         _symbol = symbol_;
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Returns the name of the token.
  61 |     |      */
  62 |     |     function name() public view virtual override returns (string memory) {
  63 |     |         return _name;
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @dev Returns the symbol of the token, usually a shorter version of the
  68 |     |      * name.
  69 |     |      */
  70 |     |     function symbol() public view virtual override returns (string memory) {
  71 |     |         return _symbol;
  72 |     |     }
  73 |     | 
  74 |     |     /**
  75 |     |      * @dev Returns the number of decimals used to get its user representation.
  76 |     |      * For example, if `decimals` equals `2`, a balance of `505` tokens should
  77 |     |      * be displayed to a user as `5.05` (`505 / 10 ** 2`).
  78 |     |      *
  79 |     |      * Tokens usually opt for a value of 18, imitating the relationship between
  80 |     |      * Ether and Wei. This is the value {ERC20} uses, unless this function is
  81 |     |      * overridden;
  82 |     |      *
  83 |     |      * NOTE: This information is only used for _display_ purposes: it in
  84 |     |      * no way affects any of the arithmetic of the contract, including
  85 |     |      * {IERC20-balanceOf} and {IERC20-transfer}.
  86 |     |      */
  87 |     |     function decimals() public view virtual override returns (uint8) {
  88 |     |         return 18;
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev See {IERC20-totalSupply}.
  93 |     |      */
  94 | *r  |     function totalSupply() public view virtual override returns (uint256) {
  95 | *r  |         return _totalSupply;
  96 |     |     }
  97 |     | 
  98 |     |     /**
  99 |     |      * @dev See {IERC20-balanceOf}.
 100 |     |      */
 101 |     |     function balanceOf(address account) public view virtual override returns (uint256) {
 102 |     |         return _balances[account];
 103 |     |     }
 104 |     | 
 105 |     |     /**
 106 |     |      * @dev See {IERC20-transfer}.
 107 |     |      *
 108 |     |      * Requirements:
 109 |     |      *
 110 |     |      * - `to` cannot be the zero address.
 111 |     |      * - the caller must have a balance of at least `amount`.
 112 |     |      */
 113 |     |     function transfer(address to, uint256 amount) public virtual override returns (bool) {
 114 |     |         address owner = _msgSender();
 115 |     |         _transfer(owner, to, amount);
 116 |     |         return true;
 117 |     |     }
 118 |     | 
 119 |     |     /**
 120 |     |      * @dev See {IERC20-allowance}.
 121 |     |      */
 122 | *r  |     function allowance(address owner, address spender) public view virtual override returns (uint256) {
 123 | *r  |         return _allowances[owner][spender];
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev See {IERC20-approve}.
 128 |     |      *
 129 |     |      * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on
 130 |     |      * `transferFrom`. This is semantically equivalent to an infinite approval.
 131 |     |      *
 132 |     |      * Requirements:
 133 |     |      *
 134 |     |      * - `spender` cannot be the zero address.
 135 |     |      */
 136 | *r  |     function approve(address spender, uint256 amount) public virtual override returns (bool) {
 137 |     |         address owner = _msgSender();
 138 | *r  |         _approve(owner, spender, amount);
 139 | *r  |         return true;
 140 |     |     }
 141 |     | 
 142 |     |     /**
 143 |     |      * @dev See {IERC20-transferFrom}.
 144 |     |      *
 145 |     |      * Emits an {Approval} event indicating the updated allowance. This is not
 146 |     |      * required by the EIP. See the note at the beginning of {ERC20}.
 147 |     |      *
 148 |     |      * NOTE: Does not update the allowance if the current allowance
 149 |     |      * is the maximum `uint256`.
 150 |     |      *
 151 |     |      * Requirements:
 152 |     |      *
 153 |     |      * - `from` and `to` cannot be the zero address.
 154 |     |      * - `from` must have a balance of at least `amount`.
 155 |     |      * - the caller must have allowance for ``from``'s tokens of at least
 156 |     |      * `amount`.
 157 |     |      */
 158 | *r  |     function transferFrom(
 159 |     |         address from,
 160 |     |         address to,
 161 |     |         uint256 amount
 162 | *r  |     ) public virtual override returns (bool) {
 163 |     |         address spender = _msgSender();
 164 | *r  |         _spendAllowance(from, spender, amount);
 165 | *r  |         _transfer(from, to, amount);
 166 | *r  |         return true;
 167 |     |     }
 168 |     | 
 169 |     |     /**
 170 |     |      * @dev Atomically increases the allowance granted to `spender` by the caller.
 171 |     |      *
 172 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 173 |     |      * problems described in {IERC20-approve}.
 174 |     |      *
 175 |     |      * Emits an {Approval} event indicating the updated allowance.
 176 |     |      *
 177 |     |      * Requirements:
 178 |     |      *
 179 |     |      * - `spender` cannot be the zero address.
 180 |     |      */
 181 |     |     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
 182 |     |         address owner = _msgSender();
 183 |     |         _approve(owner, spender, allowance(owner, spender) + addedValue);
 184 |     |         return true;
 185 |     |     }
 186 |     | 
 187 |     |     /**
 188 |     |      * @dev Atomically decreases the allowance granted to `spender` by the caller.
 189 |     |      *
 190 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 191 |     |      * problems described in {IERC20-approve}.
 192 |     |      *
 193 |     |      * Emits an {Approval} event indicating the updated allowance.
 194 |     |      *
 195 |     |      * Requirements:
 196 |     |      *
 197 |     |      * - `spender` cannot be the zero address.
 198 |     |      * - `spender` must have allowance for the caller of at least
 199 |     |      * `subtractedValue`.
 200 |     |      */
 201 |     |     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
 202 |     |         address owner = _msgSender();
 203 |     |         uint256 currentAllowance = allowance(owner, spender);
 204 |     |         require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
 205 |     |         unchecked {
 206 |     |             _approve(owner, spender, currentAllowance - subtractedValue);
 207 |     |         }
 208 |     | 
 209 |     |         return true;
 210 |     |     }
 211 |     | 
 212 |     |     /**
 213 |     |      * @dev Moves `amount` of tokens from `from` to `to`.
 214 |     |      *
 215 |     |      * This internal function is equivalent to {transfer}, and can be used to
 216 |     |      * e.g. implement automatic token fees, slashing mechanisms, etc.
 217 |     |      *
 218 |     |      * Emits a {Transfer} event.
 219 |     |      *
 220 |     |      * Requirements:
 221 |     |      *
 222 |     |      * - `from` cannot be the zero address.
 223 |     |      * - `to` cannot be the zero address.
 224 |     |      * - `from` must have a balance of at least `amount`.
 225 |     |      */
 226 | *r  |     function _transfer(
 227 |     |         address from,
 228 |     |         address to,
 229 |     |         uint256 amount
 230 |     |     ) internal virtual {
 231 | *r  |         require(from != address(0), "ERC20: transfer from the zero address");
 232 | *r  |         require(to != address(0), "ERC20: transfer to the zero address");
 233 |     | 
 234 | *r  |         _beforeTokenTransfer(from, to, amount);
 235 |     | 
 236 | *r  |         uint256 fromBalance = _balances[from];
 237 | *r  |         require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");
 238 |     |         unchecked {
 239 | *r  |             _balances[from] = fromBalance - amount;
 240 |     |             // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by
 241 |     |             // decrementing then incrementing.
 242 | *r  |             _balances[to] += amount;
 243 |     |         }
 244 |     | 
 245 | *r  |         emit Transfer(from, to, amount);
 246 |     | 
 247 | *r  |         _afterTokenTransfer(from, to, amount);
 248 |     |     }
 249 |     | 
 250 |     |     /** @dev Creates `amount` tokens and assigns them to `account`, increasing
 251 |     |      * the total supply.
 252 |     |      *
 253 |     |      * Emits a {Transfer} event with `from` set to the zero address.
 254 |     |      *
 255 |     |      * Requirements:
 256 |     |      *
 257 |     |      * - `account` cannot be the zero address.
 258 |     |      */
 259 | *r  |     function _mint(address account, uint256 amount) internal virtual {
 260 | *r  |         require(account != address(0), "ERC20: mint to the zero address");
 261 |     | 
 262 |     |         _beforeTokenTransfer(address(0), account, amount);
 263 |     | 
 264 | *r  |         _totalSupply += amount;
 265 |     |         unchecked {
 266 |     |             // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.
 267 | *r  |             _balances[account] += amount;
 268 |     |         }
 269 | *r  |         emit Transfer(address(0), account, amount);
 270 |     | 
 271 |     |         _afterTokenTransfer(address(0), account, amount);
 272 |     |     }
 273 |     | 
 274 |     |     /**
 275 |     |      * @dev Destroys `amount` tokens from `account`, reducing the
 276 |     |      * total supply.
 277 |     |      *
 278 |     |      * Emits a {Transfer} event with `to` set to the zero address.
 279 |     |      *
 280 |     |      * Requirements:
 281 |     |      *
 282 |     |      * - `account` cannot be the zero address.
 283 |     |      * - `account` must have at least `amount` tokens.
 284 |     |      */
 285 |     |     function _burn(address account, uint256 amount) internal virtual {
 286 |     |         require(account != address(0), "ERC20: burn from the zero address");
 287 |     | 
 288 |     |         _beforeTokenTransfer(account, address(0), amount);
 289 |     | 
 290 |     |         uint256 accountBalance = _balances[account];
 291 |     |         require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
 292 |     |         unchecked {
 293 |     |             _balances[account] = accountBalance - amount;
 294 |     |             // Overflow not possible: amount <= accountBalance <= totalSupply.
 295 |     |             _totalSupply -= amount;
 296 |     |         }
 297 |     | 
 298 |     |         emit Transfer(account, address(0), amount);
 299 |     | 
 300 |     |         _afterTokenTransfer(account, address(0), amount);
 301 |     |     }
 302 |     | 
 303 |     |     /**
 304 |     |      * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
 305 |     |      *
 306 |     |      * This internal function is equivalent to `approve`, and can be used to
 307 |     |      * e.g. set automatic allowances for certain subsystems, etc.
 308 |     |      *
 309 |     |      * Emits an {Approval} event.
 310 |     |      *
 311 |     |      * Requirements:
 312 |     |      *
 313 |     |      * - `owner` cannot be the zero address.
 314 |     |      * - `spender` cannot be the zero address.
 315 |     |      */
 316 | *r  |     function _approve(
 317 |     |         address owner,
 318 |     |         address spender,
 319 |     |         uint256 amount
 320 |     |     ) internal virtual {
 321 | *r  |         require(owner != address(0), "ERC20: approve from the zero address");
 322 | *r  |         require(spender != address(0), "ERC20: approve to the zero address");
 323 |     | 
 324 | *r  |         _allowances[owner][spender] = amount;
 325 | *r  |         emit Approval(owner, spender, amount);
 326 |     |     }
 327 |     | 
 328 |     |     /**
 329 |     |      * @dev Updates `owner` s allowance for `spender` based on spent `amount`.
 330 |     |      *
 331 |     |      * Does not update the allowance amount in case of infinite allowance.
 332 |     |      * Revert if not enough allowance is available.
 333 |     |      *
 334 |     |      * Might emit an {Approval} event.
 335 |     |      */
 336 | *r  |     function _spendAllowance(
 337 |     |         address owner,
 338 |     |         address spender,
 339 |     |         uint256 amount
 340 | *r  |     ) internal virtual {
 341 | *r  |         uint256 currentAllowance = allowance(owner, spender);
 342 | *r  |         if (currentAllowance != type(uint256).max) {
 343 | *r  |             require(currentAllowance >= amount, "ERC20: insufficient allowance");
 344 |     |             unchecked {
 345 | *r  |                 _approve(owner, spender, currentAllowance - amount);
 346 |     |             }
 347 |     |         }
 348 |     |     }
 349 |     | 
 350 |     |     /**
 351 |     |      * @dev Hook that is called before any transfer of tokens. This includes
 352 |     |      * minting and burning.
 353 |     |      *
 354 |     |      * Calling conditions:
 355 |     |      *
 356 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 357 |     |      * will be transferred to `to`.
 358 |     |      * - when `from` is zero, `amount` tokens will be minted for `to`.
 359 |     |      * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
 360 |     |      * - `from` and `to` are never both zero.
 361 |     |      *
 362 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 363 |     |      */
 364 |     |     function _beforeTokenTransfer(
 365 |     |         address from,
 366 |     |         address to,
 367 |     |         uint256 amount
 368 |     |     ) internal virtual {}
 369 |     | 
 370 |     |     /**
 371 |     |      * @dev Hook that is called after any transfer of tokens. This includes
 372 |     |      * minting and burning.
 373 |     |      *
 374 |     |      * Calling conditions:
 375 |     |      *
 376 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 377 |     |      * has been transferred to `to`.
 378 |     |      * - when `from` is zero, `amount` tokens have been minted for `to`.
 379 |     |      * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
 380 |     |      * - `from` and `to` are never both zero.
 381 |     |      *
 382 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 383 |     |      */
 384 |     |     function _afterTokenTransfer(
 385 |     |         address from,
 386 |     |         address to,
 387 |     |         uint256 amount
 388 |     |     ) internal virtual {}
 389 |     | }
 390 |     | 

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 standard as defined in the EIP.
  8 |     |  */
  9 |     | interface IERC20 {
 10 |     |     /**
 11 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
 12 |     |      * another (`to`).
 13 |     |      *
 14 |     |      * Note that `value` may be zero.
 15 |     |      */
 16 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 20 |     |      * a call to {approve}. `value` is the new allowance.
 21 |     |      */
 22 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the amount of tokens in existence.
 26 |     |      */
 27 |     |     function totalSupply() external view returns (uint256);
 28 |     | 
 29 |     |     /**
 30 |     |      * @dev Returns the amount of tokens owned by `account`.
 31 |     |      */
 32 |     |     function balanceOf(address account) external view returns (uint256);
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Moves `amount` tokens from the caller's account to `to`.
 36 |     |      *
 37 |     |      * Returns a boolean value indicating whether the operation succeeded.
 38 |     |      *
 39 |     |      * Emits a {Transfer} event.
 40 |     |      */
 41 |     |     function transfer(address to, uint256 amount) external returns (bool);
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 45 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 46 |     |      * zero by default.
 47 |     |      *
 48 |     |      * This value changes when {approve} or {transferFrom} are called.
 49 |     |      */
 50 |     |     function allowance(address owner, address spender) external view returns (uint256);
 51 |     | 
 52 |     |     /**
 53 |     |      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
 54 |     |      *
 55 |     |      * Returns a boolean value indicating whether the operation succeeded.
 56 |     |      *
 57 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 58 |     |      * that someone may use both the old and the new allowance by unfortunate
 59 |     |      * transaction ordering. One possible solution to mitigate this race
 60 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 61 |     |      * desired value afterwards:
 62 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 63 |     |      *
 64 |     |      * Emits an {Approval} event.
 65 |     |      */
 66 |     |     function approve(address spender, uint256 amount) external returns (bool);
 67 |     | 
 68 |     |     /**
 69 |     |      * @dev Moves `amount` tokens from `from` to `to` using the
 70 |     |      * allowance mechanism. `amount` is then deducted from the caller's
 71 |     |      * allowance.
 72 |     |      *
 73 |     |      * Returns a boolean value indicating whether the operation succeeded.
 74 |     |      *
 75 |     |      * Emits a {Transfer} event.
 76 |     |      */
 77 |     |     function transferFrom(
 78 |     |         address from,
 79 |     |         address to,
 80 |     |         uint256 amount
 81 |     |     ) external returns (bool);
 82 |     | }
 83 |     | 

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../IERC20.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Interface for the optional metadata functions from the ERC20 standard.
 10 |     |  *
 11 |     |  * _Available since v4.1._
 12 |     |  */
 13 |     | interface IERC20Metadata is IERC20 {
 14 |     |     /**
 15 |     |      * @dev Returns the name of the token.
 16 |     |      */
 17 |     |     function name() external view returns (string memory);
 18 |     | 
 19 |     |     /**
 20 |     |      * @dev Returns the symbol of the token.
 21 |     |      */
 22 |     |     function symbol() external view returns (string memory);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the decimals places of the token.
 26 |     |      */
 27 |     |     function decimals() external view returns (uint8);
 28 |     | }
 29 |     | 

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/openzeppelin-contracts/contracts/utils/Address.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.1;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev Collection of functions related to the address type
   8 |     |  */
   9 |     | library Address {
  10 |     |     /**
  11 |     |      * @dev Returns true if `account` is a contract.
  12 |     |      *
  13 |     |      * [IMPORTANT]
  14 |     |      * ====
  15 |     |      * It is unsafe to assume that an address for which this function returns
  16 |     |      * false is an externally-owned account (EOA) and not a contract.
  17 |     |      *
  18 |     |      * Among others, `isContract` will return false for the following
  19 |     |      * types of addresses:
  20 |     |      *
  21 |     |      *  - an externally-owned account
  22 |     |      *  - a contract in construction
  23 |     |      *  - an address where a contract will be created
  24 |     |      *  - an address where a contract lived, but was destroyed
  25 |     |      * ====
  26 |     |      *
  27 |     |      * [IMPORTANT]
  28 |     |      * ====
  29 |     |      * You shouldn't rely on `isContract` to protect against flash loan attacks!
  30 |     |      *
  31 |     |      * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
  32 |     |      * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
  33 |     |      * constructor.
  34 |     |      * ====
  35 |     |      */
  36 |     |     function isContract(address account) internal view returns (bool) {
  37 |     |         // This method relies on extcodesize/address.code.length, which returns 0
  38 |     |         // for contracts in construction, since the code is only stored at the end
  39 |     |         // of the constructor execution.
  40 |     | 
  41 | *r  |         return account.code.length > 0;
  42 |     |     }
  43 |     | 
  44 |     |     /**
  45 |     |      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
  46 |     |      * `recipient`, forwarding all available gas and reverting on errors.
  47 |     |      *
  48 |     |      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
  49 |     |      * of certain opcodes, possibly making contracts go over the 2300 gas limit
  50 |     |      * imposed by `transfer`, making them unable to receive funds via
  51 |     |      * `transfer`. {sendValue} removes this limitation.
  52 |     |      *
  53 |     |      * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
  54 |     |      *
  55 |     |      * IMPORTANT: because control is transferred to `recipient`, care must be
  56 |     |      * taken to not create reentrancy vulnerabilities. Consider using
  57 |     |      * {ReentrancyGuard} or the
  58 |     |      * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
  59 |     |      */
  60 |     |     function sendValue(address payable recipient, uint256 amount) internal {
  61 |     |         require(address(this).balance >= amount, "Address: insufficient balance");
  62 |     | 
  63 |     |         (bool success, ) = recipient.call{value: amount}("");
  64 |     |         require(success, "Address: unable to send value, recipient may have reverted");
  65 |     |     }
  66 |     | 
  67 |     |     /**
  68 |     |      * @dev Performs a Solidity function call using a low level `call`. A
  69 |     |      * plain `call` is an unsafe replacement for a function call: use this
  70 |     |      * function instead.
  71 |     |      *
  72 |     |      * If `target` reverts with a revert reason, it is bubbled up by this
  73 |     |      * function (like regular Solidity function calls).
  74 |     |      *
  75 |     |      * Returns the raw returned data. To convert to the expected return value,
  76 |     |      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
  77 |     |      *
  78 |     |      * Requirements:
  79 |     |      *
  80 |     |      * - `target` must be a contract.
  81 |     |      * - calling `target` with `data` must not revert.
  82 |     |      *
  83 |     |      * _Available since v3.1._
  84 |     |      */
  85 |     |     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
  86 |     |         return functionCallWithValue(target, data, 0, "Address: low-level call failed");
  87 |     |     }
  88 |     | 
  89 |     |     /**
  90 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
  91 |     |      * `errorMessage` as a fallback revert reason when `target` reverts.
  92 |     |      *
  93 |     |      * _Available since v3.1._
  94 |     |      */
  95 |     |     function functionCall(
  96 |     |         address target,
  97 |     |         bytes memory data,
  98 |     |         string memory errorMessage
  99 |     |     ) internal returns (bytes memory) {
 100 |     |         return functionCallWithValue(target, data, 0, errorMessage);
 101 |     |     }
 102 |     | 
 103 |     |     /**
 104 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 105 |     |      * but also transferring `value` wei to `target`.
 106 |     |      *
 107 |     |      * Requirements:
 108 |     |      *
 109 |     |      * - the calling contract must have an ETH balance of at least `value`.
 110 |     |      * - the called Solidity function must be `payable`.
 111 |     |      *
 112 |     |      * _Available since v3.1._
 113 |     |      */
 114 |     |     function functionCallWithValue(
 115 |     |         address target,
 116 |     |         bytes memory data,
 117 |     |         uint256 value
 118 |     |     ) internal returns (bytes memory) {
 119 |     |         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
 120 |     |     }
 121 |     | 
 122 |     |     /**
 123 |     |      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
 124 |     |      * with `errorMessage` as a fallback revert reason when `target` reverts.
 125 |     |      *
 126 |     |      * _Available since v3.1._
 127 |     |      */
 128 |     |     function functionCallWithValue(
 129 |     |         address target,
 130 |     |         bytes memory data,
 131 |     |         uint256 value,
 132 |     |         string memory errorMessage
 133 |     |     ) internal returns (bytes memory) {
 134 |     |         require(address(this).balance >= value, "Address: insufficient balance for call");
 135 |     |         (bool success, bytes memory returndata) = target.call{value: value}(data);
 136 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 137 |     |     }
 138 |     | 
 139 |     |     /**
 140 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 141 |     |      * but performing a static call.
 142 |     |      *
 143 |     |      * _Available since v3.3._
 144 |     |      */
 145 |     |     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
 146 |     |         return functionStaticCall(target, data, "Address: low-level static call failed");
 147 |     |     }
 148 |     | 
 149 |     |     /**
 150 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
 151 |     |      * but performing a static call.
 152 |     |      *
 153 |     |      * _Available since v3.3._
 154 |     |      */
 155 |     |     function functionStaticCall(
 156 |     |         address target,
 157 |     |         bytes memory data,
 158 |     |         string memory errorMessage
 159 |     |     ) internal view returns (bytes memory) {
 160 |     |         (bool success, bytes memory returndata) = target.staticcall(data);
 161 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 162 |     |     }
 163 |     | 
 164 |     |     /**
 165 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 166 |     |      * but performing a delegate call.
 167 |     |      *
 168 |     |      * _Available since v3.4._
 169 |     |      */
 170 |     |     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
 171 |     |         return functionDelegateCall(target, data, "Address: low-level delegate call failed");
 172 |     |     }
 173 |     | 
 174 |     |     /**
 175 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
 176 |     |      * but performing a delegate call.
 177 |     |      *
 178 |     |      * _Available since v3.4._
 179 |     |      */
 180 |     |     function functionDelegateCall(
 181 |     |         address target,
 182 |     |         bytes memory data,
 183 |     |         string memory errorMessage
 184 |     |     ) internal returns (bytes memory) {
 185 |     |         (bool success, bytes memory returndata) = target.delegatecall(data);
 186 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 187 |     |     }
 188 |     | 
 189 |     |     /**
 190 |     |      * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling
 191 |     |      * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.
 192 |     |      *
 193 |     |      * _Available since v4.8._
 194 |     |      */
 195 |     |     function verifyCallResultFromTarget(
 196 |     |         address target,
 197 |     |         bool success,
 198 |     |         bytes memory returndata,
 199 |     |         string memory errorMessage
 200 |     |     ) internal view returns (bytes memory) {
 201 |     |         if (success) {
 202 |     |             if (returndata.length == 0) {
 203 |     |                 // only check isContract if the call was successful and the return data is empty
 204 |     |                 // otherwise we already know that it was a contract
 205 |     |                 require(isContract(target), "Address: call to non-contract");
 206 |     |             }
 207 |     |             return returndata;
 208 |     |         } else {
 209 |     |             _revert(returndata, errorMessage);
 210 |     |         }
 211 |     |     }
 212 |     | 
 213 |     |     /**
 214 |     |      * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the
 215 |     |      * revert reason or using the provided one.
 216 |     |      *
 217 |     |      * _Available since v4.3._
 218 |     |      */
 219 |     |     function verifyCallResult(
 220 |     |         bool success,
 221 |     |         bytes memory returndata,
 222 |     |         string memory errorMessage
 223 |     |     ) internal pure returns (bytes memory) {
 224 |     |         if (success) {
 225 |     |             return returndata;
 226 |     |         } else {
 227 |     |             _revert(returndata, errorMessage);
 228 |     |         }
 229 |     |     }
 230 |     | 
 231 |     |     function _revert(bytes memory returndata, string memory errorMessage) private pure {
 232 |     |         // Look for revert reason and bubble it up if present
 233 |     |         if (returndata.length > 0) {
 234 |     |             // The easiest way to bubble the revert reason is using memory via assembly
 235 |     |             /// @solidity memory-safe-assembly
 236 |     |             assembly {
 237 |     |                 let returndata_size := mload(returndata)
 238 |     |                 revert(add(32, returndata), returndata_size)
 239 |     |             }
 240 |     |         } else {
 241 |     |             revert(errorMessage);
 242 |     |         }
 243 |     |     }
 244 |     | }
 245 |     | 

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/openzeppelin-contracts/contracts/utils/Context.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Provides information about the current execution context, including the
  8 |     |  * sender of the transaction and its data. While these are generally available
  9 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 10 |     |  * manner, since when dealing with meta-transactions the account sending and
 11 |     |  * paying for execution may not be the actual sender (as far as an application
 12 |     |  * is concerned).
 13 |     |  *
 14 |     |  * This contract is only required for intermediate, library-like contracts.
 15 |     |  */
 16 |     | abstract contract Context {
 17 |     |     function _msgSender() internal view virtual returns (address) {
 18 | *r  |         return msg.sender;
 19 |     |     }
 20 |     | 
 21 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 22 |     |         return msg.data;
 23 |     |     }
 24 |     | }
 25 |     | 

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "./IERC165.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Implementation of the {IERC165} interface.
 10 |     |  *
 11 |     |  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 12 |     |  * for the additional interface id that will be supported. For example:
 13 |     |  *
 14 |     |  * ```solidity
 15 |     |  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 16 |     |  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 17 |     |  * }
 18 |     |  * ```
 19 |     |  *
 20 |     |  * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
 21 |     |  */
 22 |     | abstract contract ERC165 is IERC165 {
 23 |     |     /**
 24 |     |      * @dev See {IERC165-supportsInterface}.
 25 |     |      */
 26 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 27 |     |         return interfaceId == type(IERC165).interfaceId;
 28 |     |     }
 29 |     | }
 30 |     | 

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC165 standard, as defined in the
  8 |     |  * https://eips.ethereum.org/EIPS/eip-165[EIP].
  9 |     |  *
 10 |     |  * Implementers can declare support of contract interfaces, which can then be
 11 |     |  * queried by others ({ERC165Checker}).
 12 |     |  *
 13 |     |  * For an implementation, see {ERC165}.
 14 |     |  */
 15 |     | interface IERC165 {
 16 |     |     /**
 17 |     |      * @dev Returns true if this contract implements the interface defined by
 18 |     |      * `interfaceId`. See the corresponding
 19 |     |      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
 20 |     |      * to learn more about how these ids are created.
 21 |     |      *
 22 |     |      * This function call must use less than 30 000 gas.
 23 |     |      */
 24 |     |     function supportsInterface(bytes4 interfaceId) external view returns (bool);
 25 |     | }
 26 |     | 

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/script/Counter.s.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity ^0.8.13;
  3 |     | 
  4 |     | import "forge-std/Script.sol";
  5 |     | 
  6 |     | contract SanctionTokenScript is Script {
  7 |     |     function setUp() public {}
  8 |     | 
  9 |     |     function run() public {
 10 |     |         vm.broadcast();
 11 |     |     }
 12 |     | }
 13 |     | 

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/script/SanctionTokenScript.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity ^0.8.13;
  3 |     | 
  4 |     | import "forge-std/Script.sol";
  5 |     | 
  6 |     | contract SanctionTokenScript is Script {
  7 |     |     function setUp() public {}
  8 |     | 
  9 |     |     function run() public {
 10 |     |         vm.broadcast();
 11 |     |     }
 12 |     | }
 13 |     | 

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/src/BondingCurveToken.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity ^0.8.13;
   4 |     | 
   5 |     | import "openzeppelin-contracts/contracts/token/ERC20/ERC20.sol";
   6 |     | import "openzeppelin-contracts/contracts/utils/Address.sol";
   7 |     | import "openzeppelin-contracts/contracts/utils/introspection/ERC165.sol";
   8 |     | import "openzeppelin-contracts/contracts/interfaces/IERC20.sol";
   9 |     | import "openzeppelin-contracts/contracts/interfaces/IERC1363.sol";
  10 |     | import "openzeppelin-contracts/contracts/interfaces/IERC1363Receiver.sol";
  11 |     | import "openzeppelin-contracts/contracts/interfaces/IERC1363Spender.sol";
  12 |     | 
  13 |     | /**
  14 |     |  * @title ERC1363
  15 |     |  * @dev Implementation of an ERC1363 interface.
  16 | *r  |  */
  17 |     | contract BondingCurveToken is ERC20, IERC1363, ERC165, IERC1363Receiver, IERC1363Spender {
  18 |     |     using Address for address;
  19 |     | 
  20 |     |     event TokensReceived(address indexed operator, address indexed sender, uint256 amount, bytes data);
  21 |     | 
  22 |     |     address public immutable _owner;
  23 | *r  |     uint8 public constant _decimals = 18;
  24 |     |     IERC1363 public immutable _reserveToken;
  25 |     | 
  26 |     |     // TODO: add admins to constructor
  27 |     |     constructor(IERC1363 reserveToken) ERC20("BondingCurveToken", "BCT") {
  28 |     |         _owner = msg.sender;
  29 |     |         _reserveToken = reserveToken;
  30 |     |     }
  31 |     | 
  32 |     |     modifier onlyOwner() {
  33 |     |         _isOwner();
  34 |     |         _;
  35 |     |     }
  36 |     | 
  37 |     |     // y = x where x is the supply
  38 |     |     function getCurrentPrice() internal view returns (uint256) {
  39 |     |         return totalSupply();
  40 |     |     }
  41 |     | 
  42 |     |     /*
  43 |     |     //useful for another curve
  44 |     |     function calculatePrice(uint256 supply) internal pure returns (uint256) {
  45 |     |         return supply * 1;
  46 |     |     }
  47 |     |     */
  48 |     | 
  49 | *r  |     function sqrt(uint256 x) internal pure returns (uint256 y) {
  50 | *r  |         uint256 z = (x + 1) / 2;
  51 | *r  |         y = x;
  52 | *r  |         while (z < y) {
  53 | *r  |             y = z;
  54 | *r  |             z = (x / z + z) / 2;
  55 |     |         }
  56 | *r  |         return y;
  57 |     |     }
  58 |     | 
  59 |     |     // Swap exact reserve for tokens
  60 | *r  |     function calculateBuyPriceOnlyIn(uint256 amountIn) public view returns (uint256) {
  61 | *r  |         uint256 currentSupply = totalSupply();
  62 | *r  |         uint256 futureSupply = sqrt(amountIn * 2 + (currentSupply ** 2));
  63 | *r  |         return futureSupply - currentSupply;
  64 |     |     }
  65 |     | 
  66 |     |     // TODO: implement swap exact token for reserve, give back additional reserve
  67 |     |     /* 
  68 |     |     function calculatePriceInAndOut(uint256 amountIn, uint256 amountOut) public returns (uint256) {}
  69 |     |     */
  70 |     | 
  71 |     |     // Swap exact tokens for reserve
  72 | *r  |     function calculateSellPriceOnlyOut(uint256 amountOut) public view returns (uint256) {
  73 |     |         uint256 currentSupply = totalSupply();
  74 |     |         uint256 reserveToPay = ((currentSupply ** 2) - ((currentSupply - amountOut) ** 2)) / 2;
  75 | *r  |         return reserveToPay / 10 ** _decimals;
  76 |     |     }
  77 |     |     /*
  78 |     |     // TODO: Swap tokens for exact reserve
  79 |     |     function calculateSellAmountToGet(uint256 amountToGet) public view returns (uint256) {}
  80 |     |     */
  81 |     | 
  82 | *r  |     function buy(uint256 amountIn) public {
  83 | *r  |         uint256 amountOut = calculateBuyPriceOnlyIn(amountIn * 10 ** _decimals);
  84 | *r  |         _reserveToken.transferFromAndCall(msg.sender, address(this), amountIn);
  85 | *r  |         ERC20._mint(msg.sender, amountOut);
  86 |     |     }
  87 |     | 
  88 |     |     function sell(uint256 amountOut) public {
  89 |     |         uint256 reserveToPay = calculateSellPriceOnlyOut(amountOut);
  90 |     |         _reserveToken.transfer(address(this), reserveToPay);
  91 |     |         ERC20._burn(msg.sender, amountOut);
  92 |     |     }
  93 |     | 
  94 |     |     function decimals() public view override returns (uint8) {
  95 |     |         return _decimals;
  96 |     |     }
  97 |     | 
  98 |     |     function _isOwner() internal view virtual {
  99 |     |         require(_owner == msg.sender, "OnlyOwner: caller is not the Owner");
 100 |     |     }
 101 |     | 
 102 |     |     /**
 103 |     |      * @dev See {IERC165-supportsInterface}.
 104 |     |      */
 105 | *r  |     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
 106 | *r  |         return interfaceId == type(IERC1363).interfaceId || super.supportsInterface(interfaceId);
 107 |     |     }
 108 |     | 
 109 |     |     /**
 110 |     |      * @dev Transfer tokens to a specified address and then execute a callback on `to`.
 111 |     |      * @param to The address to transfer to.
 112 |     |      * @param amount The amount to be transferred.
 113 |     |      * @return A boolean that indicates if the operation was successful.
 114 |     |      */
 115 | *r  |     function transferAndCall(address to, uint256 amount) public virtual override returns (bool) {
 116 | *r  |         return transferAndCall(to, amount, "");
 117 |     |     }
 118 |     | 
 119 |     |     /**
 120 |     |      * @dev Transfer tokens to a specified address and then execute a callback on `to`.
 121 |     |      * @param to The address to transfer to
 122 |     |      * @param amount The amount to be transferred
 123 |     |      * @param data Additional data with no specified format
 124 |     |      * @return A boolean that indicates if the operation was successful.
 125 |     |      */
 126 |     |     function transferAndCall(address to, uint256 amount, bytes memory data) public virtual override returns (bool) {
 127 |     |         transfer(to, amount);
 128 |     |         require(_checkOnTransferReceived(_msgSender(), to, amount, data), "ERC1363: receiver returned wrong data");
 129 |     |         return true;
 130 |     |     }
 131 |     | 
 132 |     |     /**
 133 |     |      * @dev Transfer tokens from one address to another and then execute a callback on `to`.
 134 |     |      * @param from The address which you want to send tokens from
 135 |     |      * @param to The address which you want to transfer to
 136 |     |      * @param amount The amount of tokens to be transferred
 137 |     |      * @return A boolean that indicates if the operation was successful.
 138 |     |      */
 139 |     |     function transferFromAndCall(address from, address to, uint256 amount) public virtual override returns (bool) {
 140 |     |         return transferFromAndCall(from, to, amount, "");
 141 |     |     }
 142 |     | 
 143 |     |     /**
 144 |     |      * @dev Transfer tokens from one address to another and then execute a callback on `to`.
 145 |     |      * @param from The address which you want to send tokens from
 146 |     |      * @param to The address which you want to transfer to
 147 |     |      * @param amount The amount of tokens to be transferred
 148 |     |      * @param data Additional data with no specified format
 149 |     |      * @return A boolean that indicates if the operation was successful.
 150 |     |      */
 151 |     |     function transferFromAndCall(address from, address to, uint256 amount, bytes memory data)
 152 |     |         public
 153 |     |         virtual
 154 |     |         override
 155 |     |         returns (bool)
 156 |     |     {
 157 |     |         transferFrom(from, to, amount);
 158 |     |         require(_checkOnTransferReceived(from, to, amount, data), "ERC1363: receiver returned wrong data");
 159 |     |         return true;
 160 |     |     }
 161 |     | 
 162 |     |     /**
 163 |     |      * @dev Approve spender to transfer tokens and then execute a callback on `spender`.
 164 |     |      * @param spender The address allowed to transfer to
 165 |     |      * @param amount The amount allowed to be transferred
 166 |     |      * @return A boolean that indicates if the operation was successful.
 167 |     |      */
 168 |     |     function approveAndCall(address spender, uint256 amount) public virtual override returns (bool) {
 169 |     |         return approveAndCall(spender, amount, "");
 170 |     |     }
 171 |     | 
 172 |     |     /**
 173 |     |      * @dev Approve spender to transfer tokens and then execute a callback on `spender`.
 174 |     |      * @param spender The address allowed to transfer to.
 175 |     |      * @param amount The amount allowed to be transferred.
 176 |     |      * @param data Additional data with no specified format.
 177 |     |      * @return A boolean that indicates if the operation was successful.
 178 |     |      */
 179 |     |     function approveAndCall(address spender, uint256 amount, bytes memory data)
 180 |     |         public
 181 |     |         virtual
 182 |     |         override
 183 |     |         returns (bool)
 184 |     |     {
 185 |     |         approve(spender, amount);
 186 |     |         require(_checkOnApprovalReceived(spender, amount, data), "ERC1363: spender returned wrong data");
 187 |     |         return true;
 188 |     |     }
 189 |     | 
 190 |     |     /**
 191 |     |      * @dev Internal function to invoke {IERC1363Receiver-onTransferReceived} on a target address.
 192 |     |      *  The call is not executed if the target address is not a contract.
 193 |     |      * @param sender address Representing the previous owner of the given token amount
 194 |     |      * @param recipient address Target address that will receive the tokens
 195 |     |      * @param amount uint256 The amount mount of tokens to be transferred
 196 |     |      * @param data bytes Optional data to send along with the call
 197 |     |      * @return whether the call correctly returned the expected magic value
 198 |     |      */
 199 |     |     function _checkOnTransferReceived(address sender, address recipient, uint256 amount, bytes memory data)
 200 |     |         internal
 201 |     |         virtual
 202 |     |         returns (bool)
 203 |     |     {
 204 |     |         if (!recipient.isContract()) {
 205 |     |             revert("ERC1363: transfer to non contract address");
 206 |     |         }
 207 |     | 
 208 |     |         try IERC1363Receiver(recipient).onTransferReceived(_msgSender(), sender, amount, data) returns (bytes4 retval) {
 209 |     |             return retval == IERC1363Receiver.onTransferReceived.selector;
 210 |     |         } catch (bytes memory reason) {
 211 |     |             if (reason.length == 0) {
 212 |     |                 revert("ERC1363: transfer to non ERC1363Receiver implementer");
 213 |     |             } else {
 214 |     |                 /// @solidity memory-safe-assembly
 215 |     |                 assembly {
 216 |     |                     revert(add(32, reason), mload(reason))
 217 |     |                 }
 218 |     |             }
 219 |     |         }
 220 |     |     }
 221 |     | 
 222 |     |     /**
 223 |     |      * @dev Internal function to invoke {IERC1363Receiver-onApprovalReceived} on a target address.
 224 |     |      *  The call is not executed if the target address is not a contract.
 225 |     |      * @param spender address The address which will spend the funds
 226 |     |      * @param amount uint256 The amount of tokens to be spent
 227 |     |      * @param data bytes Optional data to send along with the call
 228 |     |      * @return whether the call correctly returned the expected magic value
 229 |     |      */
 230 |     |     function _checkOnApprovalReceived(address spender, uint256 amount, bytes memory data)
 231 |     |         internal
 232 |     |         virtual
 233 |     |         returns (bool)
 234 |     |     {
 235 |     |         if (!spender.isContract()) {
 236 |     |             revert("ERC1363: approve a non contract address");
 237 |     |         }
 238 |     | 
 239 |     |         try IERC1363Spender(spender).onApprovalReceived(_msgSender(), amount, data) returns (bytes4 retval) {
 240 |     |             return retval == IERC1363Spender.onApprovalReceived.selector;
 241 |     |         } catch (bytes memory reason) {
 242 |     |             if (reason.length == 0) {
 243 |     |                 revert("ERC1363: approve a non ERC1363Spender implementer");
 244 |     |             } else {
 245 |     |                 /// @solidity memory-safe-assembly
 246 |     |                 assembly {
 247 |     |                     revert(add(32, reason), mload(reason))
 248 |     |                 }
 249 |     |             }
 250 |     |         }
 251 |     |     }
 252 |     | 
 253 | *r  |     function onTransferReceived(address operator, address from, uint256 value, bytes memory data)
 254 |     |         external
 255 |     |         override
 256 | *r  |         returns (bytes4)
 257 |     |     {
 258 | *r  |         emit TokensReceived(operator, from, value, data);
 259 |     |         return IERC1363Receiver.onTransferReceived.selector;
 260 |     |     }
 261 |     | 
 262 | *r  |     function onApprovalReceived(address owner, uint256 value, bytes memory data) external override returns (bytes4) {}
 263 |     | }
 264 |     | 

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/src/EchidnaBonding.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./BondingCurveToken.sol";
  5 |     | import "./SanctionToken.sol";
  6 |     | 
  7 | *r  | 
  8 |     | contract EchidnaBonding {
  9 |     |   BondingCurveToken bondingToken;
 10 |     |   SanctionToken reserveToken;
 11 |     |   address[] adminList = new address[](1);
 12 |     |     /* ================================================================
 13 |     |        Events used for debugging or showing information.
 14 |     |        ================================================================ */
 15 |     |     event Value(string reason, uint256 val);
 16 |     |     event LogErr(bytes error);
 17 |     |     event Debug(int128, int128);
 18 |     |     event Addy(address);
 19 |     | 
 20 |     |   // setup
 21 |     |   constructor() {
 22 |     |     adminList[0] = address(this);
 23 |     |     reserveToken = new SanctionToken(adminList);
 24 |     |     bondingToken = new BondingCurveToken(reserveToken);
 25 |     |   }
 26 |     | 
 27 | *r  |   function testBuying(uint _amountIn) public{
 28 |     |     // Pre conditions
 29 | *r  |     _amountIn = 1 + (_amountIn % 1500);
 30 |     |     // Action
 31 | *r  |     uint256 preBuyPrice = bondingToken.calculateBuyPriceOnlyIn(_amountIn);
 32 | *r  |     reserveToken.approve(address(bondingToken), _amountIn);
 33 | *r  |     try bondingToken.buy(_amountIn){
 34 | *r  |       assert(preBuyPrice > bondingToken.calculateBuyPriceOnlyIn(_amountIn));
 35 |     |     } catch (bytes memory err) {
 36 |     |       assert(false);
 37 |     |     }
 38 |     |   }
 39 |     | 
 40 |     |   function testSelling(uint _amountOut) private{
 41 |     |     // Pre conditions
 42 |     |     _amountOut = 1 + (_amountOut % bondingToken.balanceOf(address(this)));
 43 |     |     // Action
 44 |     |     uint256 preSellPrice = bondingToken.calculateSellPriceOnlyOut(_amountOut);
 45 |     |     try bondingToken.sell(_amountOut){
 46 |     |       assert(preSellPrice < bondingToken.calculateSellPriceOnlyOut(_amountOut));
 47 |     |     } catch (bytes memory err) {
 48 |     |       assert(false);
 49 |     |     }
 50 |     |   }
 51 |     | 
 52 |     | }
 53 |     | 

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/src/GodModeToken.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity ^0.8.13;
   4 |     | 
   5 |     | import "openzeppelin-contracts/contracts/token/ERC20/ERC20.sol";
   6 |     | import "openzeppelin-contracts/contracts/utils/Address.sol";
   7 |     | import "openzeppelin-contracts/contracts/utils/introspection/ERC165.sol";
   8 |     | import "openzeppelin-contracts/contracts/interfaces/IERC1363.sol";
   9 |     | import "openzeppelin-contracts/contracts/interfaces/IERC1363Receiver.sol";
  10 |     | import "openzeppelin-contracts/contracts/interfaces/IERC1363Spender.sol";
  11 |     | 
  12 |     | /**
  13 |     |  * @title ERC1363
  14 |     |  * @dev Implementation of an ERC1363 interface.
  15 |     |  */
  16 |     | 
  17 |     | abstract contract ERC1363Implementer is ERC20, IERC1363 {
  18 |     |     using Address for address;
  19 |     |     /**
  20 |     |      * @dev Transfer tokens to a specified address and then execute a callback on `to`.
  21 |     |      * @param to The address to transfer to.
  22 |     |      * @param amount The amount to be transferred.
  23 |     |      * @return A boolean that indicates if the operation was successful.
  24 |     |      */
  25 |     | 
  26 |     |     function transferAndCall(address to, uint256 amount) public override returns (bool) {
  27 |     |         return transferAndCall(to, amount, "");
  28 |     |     }
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Transfer tokens to a specified address and then execute a callback on `to`.
  32 |     |      * @param to The address to transfer to
  33 |     |      * @param amount The amount to be transferred
  34 |     |      * @param data Additional data with no specified format
  35 |     |      * @return A boolean that indicates if the operation was successful.
  36 |     |      */
  37 |     |     function transferAndCall(address to, uint256 amount, bytes memory data) public override returns (bool) {
  38 |     |         transfer(to, amount);
  39 |     |         require(_checkOnTransferReceived(_msgSender(), to, amount, data), "ERC1363: receiver returned wrong data");
  40 |     |         return true;
  41 |     |     }
  42 |     | 
  43 |     |     /**
  44 |     |      * @dev Transfer tokens from one address to another and then execute a callback on `to`.
  45 |     |      * @param from The address which you want to send tokens from
  46 |     |      * @param to The address which you want to transfer to
  47 |     |      * @param amount The amount of tokens to be transferred
  48 |     |      * @return A boolean that indicates if the operation was successful.
  49 |     |      */
  50 |     |     function transferFromAndCall(address from, address to, uint256 amount) public override returns (bool) {
  51 |     |         return transferFromAndCall(from, to, amount, "");
  52 |     |     }
  53 |     | 
  54 |     |     /**
  55 |     |      * @dev Transfer tokens from one address to another and then execute a callback on `to`.
  56 |     |      * @param from The address which you want to send tokens from
  57 |     |      * @param to The address which you want to transfer to
  58 |     |      * @param amount The amount of tokens to be transferred
  59 |     |      * @param data Additional data with no specified format
  60 |     |      * @return A boolean that indicates if the operation was successful.
  61 |     |      */
  62 |     |     function transferFromAndCall(address from, address to, uint256 amount, bytes memory data)
  63 |     |         public
  64 |     |         override
  65 |     |         returns (bool)
  66 |     |     {
  67 |     |         transferFrom(from, to, amount);
  68 |     |         require(_checkOnTransferReceived(from, to, amount, data), "ERC1363: receiver returned wrong data");
  69 |     |         return true;
  70 |     |     }
  71 |     | 
  72 |     |     /**
  73 |     |      * @dev Approve spender to transfer tokens and then execute a callback on `spender`.
  74 |     |      * @param spender The address allowed to transfer to
  75 |     |      * @param amount The amount allowed to be transferred
  76 |     |      * @return A boolean that indicates if the operation was successful.
  77 |     |      */
  78 |     |     function approveAndCall(address spender, uint256 amount) public override returns (bool) {
  79 |     |         return approveAndCall(spender, amount, "");
  80 |     |     }
  81 |     | 
  82 |     |     /**
  83 |     |      * @dev Approve spender to transfer tokens and then execute a callback on `spender`.
  84 |     |      * @param spender The address allowed to transfer to.
  85 |     |      * @param amount The amount allowed to be transferred.
  86 |     |      * @param data Additional data with no specified format.
  87 |     |      * @return A boolean that indicates if the operation was successful.
  88 |     |      */
  89 |     |     function approveAndCall(address spender, uint256 amount, bytes memory data) public override returns (bool) {
  90 |     |         approve(spender, amount);
  91 |     |         require(_checkOnApprovalReceived(spender, amount, data), "ERC1363: spender returned wrong data");
  92 |     |         return true;
  93 |     |     }
  94 |     | 
  95 |     |     /**
  96 |     |      * @dev Internal function to invoke {IERC1363Receiver-onTransferReceived} on a target address.
  97 |     |      *  The call is not executed if the target address is not a contract.
  98 |     |      * @param sender address Representing the previous owner of the given token amount
  99 |     |      * @param recipient address Target address that will receive the tokens
 100 |     |      * @param amount uint256 The amount mount of tokens to be transferred
 101 |     |      * @param data bytes Optional data to send along with the call
 102 |     |      * @return whether the call correctly returned the expected magic value
 103 |     |      */
 104 |     |     function _checkOnTransferReceived(address sender, address recipient, uint256 amount, bytes memory data)
 105 |     |         internal
 106 |     |         returns (bool)
 107 |     |     {
 108 |     |         if (!recipient.isContract()) {
 109 |     |             revert("ERC1363: transfer to non contract address");
 110 |     |         }
 111 |     | 
 112 |     |         try IERC1363Receiver(recipient).onTransferReceived(_msgSender(), sender, amount, data) returns (bytes4 retval) {
 113 |     |             return retval == IERC1363Receiver.onTransferReceived.selector;
 114 |     |         } catch (bytes memory reason) {
 115 |     |             if (reason.length == 0) {
 116 |     |                 revert("ERC1363: transfer to non ERC1363Receiver implementer");
 117 |     |             } else {
 118 |     |                 /// @solidity memory-safe-assembly
 119 |     |                 assembly {
 120 |     |                     revert(add(32, reason), mload(reason))
 121 |     |                 }
 122 |     |             }
 123 |     |         }
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev Internal function to invoke {IERC1363Receiver-onApprovalReceived} on a target address.
 128 |     |      *  The call is not executed if the target address is not a contract.
 129 |     |      * @param spender address The address which will spend the funds
 130 |     |      * @param amount uint256 The amount of tokens to be spent
 131 |     |      * @param data bytes Optional data to send along with the call
 132 |     |      * @return whether the call correctly returned the expected magic value
 133 |     |      */
 134 |     |     function _checkOnApprovalReceived(address spender, uint256 amount, bytes memory data) internal returns (bool) {
 135 |     |         if (!spender.isContract()) {
 136 |     |             revert("ERC1363: approve a non contract address");
 137 |     |         }
 138 |     | 
 139 |     |         try IERC1363Spender(spender).onApprovalReceived(_msgSender(), amount, data) returns (bytes4 retval) {
 140 |     |             return retval == IERC1363Spender.onApprovalReceived.selector;
 141 |     |         } catch (bytes memory reason) {
 142 |     |             if (reason.length == 0) {
 143 |     |                 revert("ERC1363: approve a non ERC1363Spender implementer");
 144 |     |             } else {
 145 |     |                 /// @solidity memory-safe-assembly
 146 |     |                 assembly {
 147 |     |                     revert(add(32, reason), mload(reason))
 148 |     |                 }
 149 |     |             }
 150 |     |         }
 151 |     |     }
 152 |     | }
 153 |     | 
 154 |     | contract GodModeToken is ERC1363Implementer, ERC165 {
 155 |     |     address public _owner;
 156 |     |     uint8 public _decimals = 18;
 157 |     |     mapping(address => bool) private _gods;
 158 |     |     uint256 private _totalSupply = 1500;
 159 |     | 
 160 |     |     constructor(address[] memory gods) ERC20("GodModeToken", "GodMode") {
 161 |     |         ERC20._mint(msg.sender, _totalSupply * 10 ** _decimals);
 162 |     |         _owner = msg.sender;
 163 |     |         for (uint256 i = 0; i < gods.length; ++i) {
 164 |     |             setGods(gods[i]);
 165 |     |         }
 166 |     |     }
 167 |     | 
 168 |     |     modifier onlyOwner() {
 169 |     |         _isOwner();
 170 |     |         _;
 171 |     |     }
 172 |     | 
 173 |     |     modifier onlyGod() {
 174 |     |         _isGod();
 175 |     |         _;
 176 |     |     }
 177 |     | 
 178 |     |     function decimals() public view override returns (uint8) {
 179 |     |         return _decimals;
 180 |     |     }
 181 |     | 
 182 |     |     function _isOwner() internal view {
 183 |     |         require(_owner == msg.sender, "OnlyOwner: caller is not the Owner");
 184 |     |     }
 185 |     | 
 186 |     |     function _isGod() internal view {
 187 |     |         require(isGod(msg.sender), "OnlyGod: caller is not a God");
 188 |     |     }
 189 |     | 
 190 |     |     function setGods(address addy) public onlyOwner {
 191 |     |         _gods[addy] = true;
 192 |     |     }
 193 |     | 
 194 |     |     function removeGod(address addy) public onlyOwner {
 195 |     |         delete _gods[addy];
 196 |     |     }
 197 |     | 
 198 |     |     function isGod(address addy) public view returns (bool) {
 199 |     |         return _gods[addy];
 200 |     |     }
 201 |     | 
 202 |     |     function godTransferFrom(address from, address to, uint256 amount) public onlyGod returns (bool) {
 203 |     |         _transfer(from, to, amount);
 204 |     |         return true;
 205 |     |     }
 206 |     | 
 207 |     |     function transferFrom(address from, address to, uint256 amount) public override(ERC20, IERC20) returns (bool) {
 208 |     |         address spender = _msgSender();
 209 |     |         _spendAllowance(from, spender, amount);
 210 |     |         _transfer(from, to, amount);
 211 |     |         return true;
 212 |     |     }
 213 |     | 
 214 |     |     /**
 215 |     |      * @dev See {IERC165-supportsInterface}.
 216 |     |      */
 217 |     |     function supportsInterface(bytes4 interfaceId) public view override(ERC165, IERC165) returns (bool) {
 218 |     |         return interfaceId == type(IERC1363).interfaceId || super.supportsInterface(interfaceId);
 219 |     |     }
 220 |     | }
 221 |     | 

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/src/SanctionToken.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity ^0.8.13;
   4 |     | 
   5 |     | import "openzeppelin-contracts/contracts/token/ERC20/ERC20.sol";
   6 |     | import "openzeppelin-contracts/contracts/utils/Address.sol";
   7 |     | import "openzeppelin-contracts/contracts/utils/introspection/ERC165.sol";
   8 |     | import "openzeppelin-contracts/contracts/interfaces/IERC1363.sol";
   9 |     | import "openzeppelin-contracts/contracts/interfaces/IERC1363Receiver.sol";
  10 |     | import "openzeppelin-contracts/contracts/interfaces/IERC1363Spender.sol";
  11 |     | 
  12 |     | /**
  13 |     |  * @title ERC1363
  14 |     |  * @dev Implementation of an ERC1363 interface.
  15 | *r  |  */
  16 |     | contract SanctionToken is ERC20, IERC1363, ERC165 {
  17 |     |     using Address for address;
  18 |     | 
  19 |     |     address public _owner;
  20 |     |     uint8 public _decimals = 18;
  21 |     |     mapping(address => bool) private _admins;
  22 |     |     mapping(address => bool) private _sanctioned;
  23 |     | 
  24 |     |     constructor(address[] memory admins) ERC20("SanctionToken", "SANCTION") {
  25 |     |         ERC20._mint(msg.sender, 1500 * 10 ** _decimals);
  26 |     |         _owner = msg.sender;
  27 |     |         for (uint256 i = 0; i < admins.length; ++i) {
  28 |     |             setAdmin(admins[i]);
  29 |     |         }
  30 |     |     }
  31 |     | 
  32 |     |     modifier onlyAdmin() {
  33 |     |         _isAdmin();
  34 |     |         _;
  35 |     |     }
  36 |     | 
  37 |     |     modifier onlyOwner() {
  38 |     |         _isOwner();
  39 |     |         _;
  40 |     |     }
  41 |     | 
  42 |     |     function decimals() public view override returns (uint8) {
  43 |     |         return _decimals;
  44 |     |     }
  45 |     | 
  46 |     |     function _isOwner() internal view virtual {
  47 |     |         require(_owner == msg.sender, "OnlyOwner: caller is not the Owner");
  48 |     |     }
  49 |     | 
  50 |     |     function _isAdmin() internal view virtual {
  51 |     |         require(isAdmin(msg.sender), "OnlyAdmin: caller is not an Admin");
  52 |     |     }
  53 |     | 
  54 |     |     function setAdmin(address addy) public onlyOwner {
  55 |     |         _admins[addy] = true;
  56 |     |     }
  57 |     | 
  58 |     |     function removeAdmin(address addy) public onlyOwner {
  59 |     |         delete _admins[addy];
  60 |     |     }
  61 |     | 
  62 |     |     function isAdmin(address addy) public view returns (bool) {
  63 |     |         return _admins[addy];
  64 |     |     }
  65 |     | 
  66 |     |     function sanction(address[] memory addies) public onlyAdmin {
  67 |     |         for (uint256 i = 0; i < addies.length; ++i) {
  68 |     |             _sanctioned[addies[i]] = true;
  69 |     |         }
  70 |     |     }
  71 |     | 
  72 |     |     function unsanction(address addy) public onlyAdmin {
  73 |     |         delete _sanctioned[addy];
  74 |     |     }
  75 |     | 
  76 | *r  |     function isSanctioned(address addy) public view returns (bool) {
  77 | *r  |         return _sanctioned[addy];
  78 |     |     }
  79 |     | 
  80 | *r  |     function _beforeTokenTransfer(address from, address to, uint256 amount) internal view override {
  81 | *r  |         require(!isSanctioned(from) && !isSanctioned(to), "Sanctioned: Cannot transfer to or from a sanctioned address");
  82 |     |     }
  83 |     | 
  84 |     |     /**
  85 |     |      * @dev See {IERC165-supportsInterface}.
  86 |     |      */
  87 | *r  |     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
  88 |     |         return interfaceId == type(IERC1363).interfaceId || super.supportsInterface(interfaceId);
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev Transfer tokens to a specified address and then execute a callback on `to`.
  93 |     |      * @param to The address to transfer to.
  94 |     |      * @param amount The amount to be transferred.
  95 |     |      * @return A boolean that indicates if the operation was successful.
  96 |     |      */
  97 | *r  |     function transferAndCall(address to, uint256 amount) public virtual override returns (bool) {
  98 | *r  |         return transferAndCall(to, amount, "");
  99 |     |     }
 100 |     | 
 101 |     |     /**
 102 |     |      * @dev Transfer tokens to a specified address and then execute a callback on `to`.
 103 |     |      * @param to The address to transfer to
 104 |     |      * @param amount The amount to be transferred
 105 |     |      * @param data Additional data with no specified format
 106 |     |      * @return A boolean that indicates if the operation was successful.
 107 |     |      */
 108 |     |     function transferAndCall(address to, uint256 amount, bytes memory data) public virtual override returns (bool) {
 109 |     |         transfer(to, amount);
 110 |     |         require(_checkOnTransferReceived(_msgSender(), to, amount, data), "ERC1363: receiver returned wrong data");
 111 |     |         return true;
 112 |     |     }
 113 |     | 
 114 |     |     /**
 115 |     |      * @dev Transfer tokens from one address to another and then execute a callback on `to`.
 116 |     |      * @param from The address which you want to send tokens from
 117 |     |      * @param to The address which you want to transfer to
 118 |     |      * @param amount The amount of tokens to be transferred
 119 |     |      * @return A boolean that indicates if the operation was successful.
 120 |     |      */
 121 | *r  |     function transferFromAndCall(address from, address to, uint256 amount) public virtual override returns (bool) {
 122 | *r  |         return transferFromAndCall(from, to, amount, "");
 123 |     |     }
 124 |     | 
 125 |     |     /**
 126 |     |      * @dev Transfer tokens from one address to another and then execute a callback on `to`.
 127 |     |      * @param from The address which you want to send tokens from
 128 |     |      * @param to The address which you want to transfer to
 129 |     |      * @param amount The amount of tokens to be transferred
 130 |     |      * @param data Additional data with no specified format
 131 |     |      * @return A boolean that indicates if the operation was successful.
 132 |     |      */
 133 | *r  |     function transferFromAndCall(address from, address to, uint256 amount, bytes memory data)
 134 |     |         public
 135 |     |         virtual
 136 |     |         override
 137 | *r  |         returns (bool)
 138 |     |     {
 139 | *r  |         transferFrom(from, to, amount);
 140 | *r  |         require(_checkOnTransferReceived(from, to, amount, data), "ERC1363: receiver returned wrong data");
 141 |     |         return true;
 142 |     |     }
 143 |     | 
 144 |     |     /**
 145 |     |      * @dev Approve spender to transfer tokens and then execute a callback on `spender`.
 146 |     |      * @param spender The address allowed to transfer to
 147 |     |      * @param amount The amount allowed to be transferred
 148 |     |      * @return A boolean that indicates if the operation was successful.
 149 |     |      */
 150 |     |     function approveAndCall(address spender, uint256 amount) public virtual override returns (bool) {
 151 |     |         return approveAndCall(spender, amount, "");
 152 |     |     }
 153 |     | 
 154 |     |     /**
 155 |     |      * @dev Approve spender to transfer tokens and then execute a callback on `spender`.
 156 |     |      * @param spender The address allowed to transfer to.
 157 |     |      * @param amount The amount allowed to be transferred.
 158 |     |      * @param data Additional data with no specified format.
 159 |     |      * @return A boolean that indicates if the operation was successful.
 160 |     |      */
 161 |     |     function approveAndCall(address spender, uint256 amount, bytes memory data)
 162 |     |         public
 163 |     |         virtual
 164 |     |         override
 165 |     |         returns (bool)
 166 |     |     {
 167 |     |         approve(spender, amount);
 168 |     |         require(_checkOnApprovalReceived(spender, amount, data), "ERC1363: spender returned wrong data");
 169 |     |         return true;
 170 |     |     }
 171 |     | 
 172 |     |     /**
 173 |     |      * @dev Internal function to invoke {IERC1363Receiver-onTransferReceived} on a target address.
 174 |     |      *  The call is not executed if the target address is not a contract.
 175 |     |      * @param sender address Representing the previous owner of the given token amount
 176 |     |      * @param recipient address Target address that will receive the tokens
 177 |     |      * @param amount uint256 The amount mount of tokens to be transferred
 178 |     |      * @param data bytes Optional data to send along with the call
 179 |     |      * @return whether the call correctly returned the expected magic value
 180 |     |      */
 181 | *r  |     function _checkOnTransferReceived(address sender, address recipient, uint256 amount, bytes memory data)
 182 |     |         internal
 183 |     |         virtual
 184 | *r  |         returns (bool)
 185 |     |     {
 186 | *r  |         if (!recipient.isContract()) {
 187 |     |             revert("ERC1363: transfer to non contract address");
 188 |     |         }
 189 |     | 
 190 | *r  |         try IERC1363Receiver(recipient).onTransferReceived(_msgSender(), sender, amount, data) returns (bytes4 retval) {
 191 | *r  |             return retval == IERC1363Receiver.onTransferReceived.selector;
 192 |     |         } catch (bytes memory reason) {
 193 |     |             if (reason.length == 0) {
 194 |     |                 revert("ERC1363: transfer to non ERC1363Receiver implementer");
 195 |     |             } else {
 196 |     |                 /// @solidity memory-safe-assembly
 197 |     |                 assembly {
 198 |     |                     revert(add(32, reason), mload(reason))
 199 |     |                 }
 200 |     |             }
 201 |     |         }
 202 |     |     }
 203 |     | 
 204 |     |     /**
 205 |     |      * @dev Internal function to invoke {IERC1363Receiver-onApprovalReceived} on a target address.
 206 |     |      *  The call is not executed if the target address is not a contract.
 207 |     |      * @param spender address The address which will spend the funds
 208 |     |      * @param amount uint256 The amount of tokens to be spent
 209 |     |      * @param data bytes Optional data to send along with the call
 210 |     |      * @return whether the call correctly returned the expected magic value
 211 |     |      */
 212 |     |     function _checkOnApprovalReceived(address spender, uint256 amount, bytes memory data)
 213 |     |         internal
 214 |     |         virtual
 215 |     |         returns (bool)
 216 |     |     {
 217 |     |         if (!spender.isContract()) {
 218 |     |             revert("ERC1363: approve a non contract address");
 219 |     |         }
 220 |     | 
 221 |     |         try IERC1363Spender(spender).onApprovalReceived(_msgSender(), amount, data) returns (bytes4 retval) {
 222 |     |             return retval == IERC1363Spender.onApprovalReceived.selector;
 223 |     |         } catch (bytes memory reason) {
 224 |     |             if (reason.length == 0) {
 225 |     |                 revert("ERC1363: approve a non ERC1363Spender implementer");
 226 |     |             } else {
 227 |     |                 /// @solidity memory-safe-assembly
 228 |     |                 assembly {
 229 |     |                     revert(add(32, reason), mload(reason))
 230 |     |                 }
 231 |     |             }
 232 |     |         }
 233 |     |     }
 234 |     | }
 235 |     | 

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/test/BondingCurveToken.t.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity ^0.8.13;
  3 |     | 
  4 |     | import "forge-std/Test.sol";
  5 |     | import "../src/SanctionToken.sol";
  6 |     | import "../src/BondingCurveToken.sol";
  7 |     | 
  8 |     | contract BondingCurveTokenTest is Test {
  9 |     |     SanctionToken sanctionToken;
 10 |     |     BondingCurveToken bondingCurveToken;
 11 |     |     address owner;
 12 |     |     address admin;
 13 |     |     address testUser;
 14 |     |     address[] adminsList = new address[](1);
 15 |     |     uint256 decimals = 10 ** 18;
 16 |     | 
 17 |     |     function setUp() public {
 18 |     |         owner = address(this);
 19 |     |         admin = address(0);
 20 |     |         testUser = address(1);
 21 |     |         adminsList[0] = admin;
 22 |     | 
 23 |     |         sanctionToken = new SanctionToken(adminsList);
 24 |     |         bondingCurveToken = new BondingCurveToken(sanctionToken);
 25 |     |     }
 26 |     | 
 27 |     |     function testSetUp() public {
 28 |     |         assertEq(sanctionToken.totalSupply(), 1500 * decimals);
 29 |     |         assertEq(sanctionToken.balanceOf(owner), 1500 * decimals);
 30 |     |         assertEq(bondingCurveToken.totalSupply(), 0 * decimals);
 31 |     |     }
 32 |     | 
 33 |     |     function testBuy() public {
 34 |     |         sanctionToken.approve(address(bondingCurveToken), 10 * decimals);
 35 |     |         bondingCurveToken.buy(10 * decimals);
 36 |     |         // total received should be sqrt(20)
 37 |     |         assertEq(bondingCurveToken.balanceOf(owner), 4_472_135_954_999_579_392);
 38 |     |         assertEq(bondingCurveToken.totalSupply(), 4_472_135_954_999_579_392);
 39 |     |         sanctionToken.approve(address(bondingCurveToken), 10 * decimals);
 40 |     |         bondingCurveToken.buy(10 * decimals);
 41 |     |         // total supply should be sqrt(40), received last tx should be sqrt(40) - sqrt(20)
 42 |     |         assertEq(bondingCurveToken.balanceOf(owner), 6_324_555_320_336_758_663);
 43 |     |         assertEq(bondingCurveToken.totalSupply(), 6_324_555_320_336_758_663);
 44 |     |     }
 45 |     | 
 46 |     |     function testSell() public {
 47 |     |         sanctionToken.approve(address(bondingCurveToken), 10 * decimals);
 48 |     |         bondingCurveToken.buy(10 * decimals);
 49 |     |         assert(bondingCurveToken.balanceOf(owner) > 0);
 50 |     |         bondingCurveToken.sell(4_472_135_954_999_579_392);
 51 |     |         assert(bondingCurveToken.balanceOf(owner) == 0);
 52 |     |     }
 53 |     | }
 54 |     | 

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/test/GodModeToken.t.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity ^0.8.13;
  3 |     | 
  4 |     | import "forge-std/Test.sol";
  5 |     | import "../src/GodModeToken.sol";
  6 |     | 
  7 |     | contract GodModeTokenTest is Test {
  8 |     |     GodModeToken public godModeToken;
  9 |     |     address owner;
 10 |     |     address zeus;
 11 |     |     address poseidon;
 12 |     |     address peasant;
 13 |     |     address testUser;
 14 |     |     address[] godsList = new address[](2);
 15 |     |     uint256 decimals = 10 ** 18;
 16 |     | 
 17 |     |     function setUp() public {
 18 |     |         owner = address(this);
 19 |     |         zeus = address(0);
 20 |     |         poseidon = address(1);
 21 |     |         peasant = address(2);
 22 |     |         testUser = address(3);
 23 |     |         godsList[0] = zeus;
 24 |     |         godsList[1] = poseidon;
 25 |     | 
 26 |     |         godModeToken = new GodModeToken(godsList);
 27 |     |     }
 28 |     | 
 29 |     |     function testSetUp() public {
 30 |     |         assertEq(godModeToken.totalSupply(), 1500 * decimals);
 31 |     |     }
 32 |     | 
 33 |     |     function testTransfers() public {
 34 |     |         godModeToken.transfer(peasant, 100 * decimals);
 35 |     |         assertEq(godModeToken.balanceOf(owner), 1400 * decimals);
 36 |     |         assertEq(godModeToken.balanceOf(peasant), 100 * decimals);
 37 |     |     }
 38 |     | 
 39 |     |     function testSetGod() public {
 40 |     |         godModeToken.setGods(testUser);
 41 |     |         assertEq(godModeToken.isGod(testUser), true);
 42 |     |     }
 43 |     | 
 44 |     |     function testRemoveGod() public {
 45 |     |         testSetGod();
 46 |     |         godModeToken.removeGod(testUser);
 47 |     |         assertEq(godModeToken.isGod(testUser), false);
 48 |     |     }
 49 |     | 
 50 |     |     function testPeasantTransfer() public {
 51 |     |         testTransfers();
 52 |     |         vm.expectRevert("OnlyGod: caller is not a God");
 53 |     |         godModeToken.godTransferFrom(peasant, owner, 100 * decimals);
 54 |     |     }
 55 |     | 
 56 |     |     function testGodTransfer() public {
 57 |     |         testTransfers();
 58 |     |         vm.prank(zeus);
 59 |     |         godModeToken.godTransferFrom(peasant, owner, 100 * decimals);
 60 |     |         assertEq(godModeToken.balanceOf(owner), 1500 * decimals);
 61 |     |         assertEq(godModeToken.balanceOf(peasant), 0);
 62 |     |     }
 63 |     | }
 64 |     | 

/Users/hebiscus/Documents/Rareskills - Solidity/Tokens/test/SanctionToken.t copy.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity ^0.8.13;
  3 |     | 
  4 |     | import "forge-std/Test.sol";
  5 |     | import "../src/SanctionToken.sol";
  6 |     | 
  7 |     | contract SanctionTokenTest is Test {
  8 |     |     SanctionToken public sanctionToken;
  9 |     |     address owner;
 10 |     |     address admin0;
 11 |     |     address admin1;
 12 |     |     address sanctionedUser;
 13 |     |     address testUser;
 14 |     |     address[] toSanction = new address[](1);
 15 |     |     address[] adminsList = new address[](2);
 16 |     |     uint256 decimals = 10 ** 18;
 17 |     | 
 18 |     |     function setUp() public {
 19 |     |         owner = address(this);
 20 |     |         admin0 = address(0);
 21 |     |         admin1 = address(1);
 22 |     |         sanctionedUser = address(2);
 23 |     |         testUser = address(3);
 24 |     |         toSanction[0] = sanctionedUser;
 25 |     |         adminsList[0] = admin0;
 26 |     |         adminsList[1] = admin1;
 27 |     | 
 28 |     |         sanctionToken = new SanctionToken(adminsList);
 29 |     |     }
 30 |     | 
 31 |     |     function testSetUp() public {
 32 |     |         assertEq(sanctionToken.totalSupply(), 1500 * decimals);
 33 |     |     }
 34 |     | 
 35 |     |     function testTransfers() public {
 36 |     |         sanctionToken.transfer(sanctionedUser, 100 * decimals);
 37 |     |         assertEq(sanctionToken.balanceOf(owner), 1400 * decimals);
 38 |     |         assertEq(sanctionToken.balanceOf(sanctionedUser), 100 * decimals);
 39 |     |     }
 40 |     | 
 41 |     |     function testNotAllowedSanctioning() public {
 42 |     |         vm.expectRevert("OnlyAdmin: caller is not an Admin");
 43 |     |         vm.prank(testUser);
 44 |     |         sanctionToken.sanction(toSanction);
 45 |     |         assertEq(sanctionToken.isSanctioned(sanctionedUser), false);
 46 |     |     }
 47 |     | 
 48 |     |     function testSetAdmin() public {
 49 |     |         assertEq(sanctionToken.isAdmin(testUser), false);
 50 |     |         sanctionToken.setAdmin(testUser);
 51 |     |         assertEq(sanctionToken.isAdmin(testUser), true);
 52 |     |     }
 53 |     | 
 54 |     |     function testSanctioning() public {
 55 |     |         assertEq(sanctionToken.isSanctioned(sanctionedUser), false);
 56 |     |         vm.prank(admin0);
 57 |     |         sanctionToken.sanction(toSanction);
 58 |     |         assertEq(sanctionToken.isSanctioned(sanctionedUser), true);
 59 |     |     }
 60 |     | 
 61 |     |     function testReceiveAsSanctioned() public {
 62 |     |         testSanctioning();
 63 |     |         vm.expectRevert("Sanctioned: Cannot transfer to or from a sanctioned address");
 64 |     |         sanctionToken.transfer(sanctionedUser, 200 * decimals);
 65 |     |     }
 66 |     | 
 67 |     |     function testSendAsSanctioned() public {
 68 |     |         testSanctioning();
 69 |     |         vm.prank(sanctionedUser);
 70 |     |         vm.expectRevert("Sanctioned: Cannot transfer to or from a sanctioned address");
 71 |     |         sanctionToken.transfer(testUser, 200 * decimals);
 72 |     |     }
 73 |     | 
 74 |     |     function testUnsanction() public {
 75 |     |         testSanctioning();
 76 |     |         vm.prank(admin0);
 77 |     |         sanctionToken.unsanction(sanctionedUser);
 78 |     |         assertEq(sanctionToken.isSanctioned(sanctionedUser), false);
 79 |     |     }
 80 |     | 
 81 |     |     function testUnsanctionAndSend() public {
 82 |     |         testTransfers();
 83 |     |         testUnsanction();
 84 |     |         vm.prank(sanctionedUser);
 85 |     |         sanctionToken.transfer(owner, 100 * decimals);
 86 |     |         assertEq(sanctionToken.balanceOf(owner), 1500 * decimals);
 87 |     |         assertEq(sanctionToken.balanceOf(sanctionedUser), 0);
 88 |     |     }
 89 |     | }
 90 |     | 

